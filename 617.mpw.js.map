{"version":3,"file":"./617.mpw.js","mappings":"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","sources":["webpack://MPW/webpack/runtime/chunk loaded","webpack://MPW/webpack/runtime/create fake namespace object","webpack://MPW/webpack/runtime/startup chunk dependencies","webpack://MPW/./scripts/utils.js","webpack://MPW/./scripts/chain_params.js","webpack://MPW/./scripts/prices.js","webpack://MPW/./scripts/settings.js","webpack://MPW/./scripts/script.js","webpack://MPW/./scripts/database.js","webpack://MPW/./scripts/misc.js","webpack://MPW/./scripts/i18n.js","webpack://MPW/./scripts/event_bus.js","webpack://MPW/./scripts/mempool.js","webpack://MPW/./scripts/global.js","webpack://MPW/./scripts/network.js","webpack://MPW/./scripts/aes-gcm.js","webpack://MPW/./scripts/wallet.js","webpack://MPW/./scripts/vanitygen_worker.js","webpack://MPW/webpack/bootstrap","webpack://MPW/webpack/runtime/compat get default export","webpack://MPW/webpack/runtime/define property getters","webpack://MPW/webpack/runtime/ensure chunk","webpack://MPW/webpack/runtime/get javascript chunk filename","webpack://MPW/webpack/runtime/get mini-css chunk filename","webpack://MPW/webpack/runtime/global","webpack://MPW/webpack/runtime/hasOwnProperty shorthand","webpack://MPW/webpack/runtime/make namespace object","webpack://MPW/webpack/runtime/node module decorator","webpack://MPW/webpack/runtime/publicPath","webpack://MPW/webpack/runtime/importScripts chunk loading","webpack://MPW/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));\n\t}\n\tdef['default'] = () => (value);\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn Promise.all([\n\t\t__webpack_require__.e(621),\n\t\t__webpack_require__.e(369)\n\t]).then(next);\n};","import { Buffer } from 'buffer';\nimport { sha256 } from '@noble/hashes/sha256';\n\nexport function hexToBytes(str) {\n    return Buffer.from(str, 'hex');\n}\n\nexport function bytesToHex(bytes) {\n    return Buffer.from(bytes).toString('hex');\n}\n\n/**\n * Double SHA256 hash a byte array\n * @param {Array<number>} buff - Bytes to hash\n * @returns {Uint8Array} Hash buffer\n */\nexport function dSHA256(buff) {\n    return sha256(sha256(new Uint8Array(buff)));\n}\n","// In most BTC-derived coins, the below parameters can be found in the 'src/chainparams.cpp' Mainnet configuration.\n// These below params share the same names as the CPP params, so finding and editing these is easy-peasy!\n// <[network_byte] [32_byte_payload] [0x01] [4_byte_checksum]>\nexport const PRIVKEY_BYTE_LENGTH = 38;\n\nexport const COIN_DECIMALS = 8;\nexport const COIN = 10 ** 8;\n\n/** The maximum gap (absence of transactions within a range of derived addresses) before an account search ends */\nexport const MAX_ACCOUNT_GAP = 20;\n\n/* Internal tweaking parameters */\n// A new encryption password must be 'at least' this long.\nexport const MIN_PASS_LENGTH = 6;\n\n/** BIP21 coin prefix */\nexport const BIP21_PREFIX = 'pivx';\n\n/* chainparams */\nexport const cChainParams = {\n    current: null,\n    main: {\n        name: 'mainnet',\n        collateralInSats: 10000 * COIN,\n        isTestnet: false,\n        TICKER: 'PIV',\n        PUBKEY_PREFIX: ['D'],\n        STAKING_PREFIX: 'S',\n        PUBKEY_ADDRESS: 30,\n        SECRET_KEY: 212,\n        BIP44_TYPE: 119,\n        BIP44_TYPE_LEDGER: 77,\n        PROTOCOL_VERSION: 70926,\n        MASTERNODE_PORT: 51472,\n        // A list of Labs-trusted explorers\n        Explorers: [\n            // Display name      Blockbook-compatible API base\n            { name: 'rockdev', url: 'https://explorer.rockdev.org' },\n            { name: 'zkBitcoin', url: 'https://zkbitcoin.com' },\n            { name: 'Duddino', url: 'https://explorer.duddino.com' },\n        ],\n        Nodes: [{ name: 'Duddino', url: 'https://rpc.duddino.com/mainnet' }],\n        Consensus: {\n            // Network upgrades\n            UPGRADE_V6_0: undefined,\n        },\n        budgetCycleBlocks: 43200,\n        proposalFee: 50 * COIN,\n        maxPaymentCycles: 6,\n        maxPayment: 10 * 43200 * COIN, // 43200 blocks of 10 PIV\n    },\n    testnet: {\n        name: 'testnet',\n        collateralInSats: 10000 * COIN,\n        isTestnet: true,\n        TICKER: 'tPIV',\n        PUBKEY_PREFIX: ['x', 'y'],\n        STAKING_PREFIX: 'W',\n        PUBKEY_ADDRESS: 139,\n        SECRET_KEY: 239,\n        BIP44_TYPE: 1,\n        BIP44_TYPE_LEDGER: 1,\n        PROTOCOL_VERSION: 70926,\n        MASTERNODE_PORT: 51474,\n        // A list of Labs-trusted explorers\n        Explorers: [\n            // Display name      Blockbook-compatible API base\n            { name: 'rockdev', url: 'https://testnet.rockdev.org' },\n        ],\n        Nodes: [{ name: 'Duddino', url: 'https://rpc.duddino.com/testnet' }],\n        Consensus: {\n            // Network upgrades\n            UPGRADE_V6_0: undefined,\n        },\n        budgetCycleBlocks: 144,\n        proposalFee: 50 * COIN,\n        maxPaymentCycles: 20,\n        maxPayment: 10 * 144 * COIN, // 144 blocks of 10 tPIV\n    },\n};\n// Set default chain\ncChainParams.current = cChainParams.main;\n","import { getBalance } from './global';\nimport { cMarket, fillCurrencySelect } from './settings';\n\n/**\n * CoinGecko's endpoint for PIVX data, optimised for least bandwidth\n * - No localisation, tickers, community data, developer data or sparklines\n */\nexport const COINGECKO_ENDPOINT =\n    'https://api.coingecko.com/api/v3/coins/pivx?localization=false&tickers=false&market_data=true&community_data=false&developer_data=false&sparkline=false';\n\n/**\n * The generic market data source template, used to build site-specific classes\n */\nexport class MarketSource {\n    /** The storage object for raw market data */\n    cData = {};\n\n    /** The name of the market source */\n    strName = '';\n\n    /** The customised API endpoint of the market source */\n    strEndpoint = '';\n\n    /**\n     * Ensure a market data cache exists, if not, fetch it and resume\n     */\n    async ensureCacheExists() {\n        if (!this.cData || !Object.keys(this.cData).length) await this.fetch();\n    }\n\n    /**\n     * Fetches the raw market source data\n     * @returns {Promise<object>}\n     */\n    async fetch() {\n        return (this.cData = await (await fetch(this.strEndpoint)).json());\n    }\n}\n\n/**\n * The CoinGecko market data source\n */\nexport class CoinGecko extends MarketSource {\n    constructor() {\n        super();\n        this.strName = 'CoinGecko';\n        this.strEndpoint = COINGECKO_ENDPOINT;\n    }\n\n    /**\n     * Get the price in a specific display currency\n     * @param {string} strCurrency - The CoinGecko-supported display currency\n     * @return {Promise<number>}\n     */\n    async getPrice(strCurrency) {\n        await this.ensureCacheExists();\n        return this.cData.market_data.current_price[strCurrency];\n    }\n\n    /**\n     * Get a list of the supported display currencies\n     * @returns {Promise<Array<string>>} - A list of CoinGecko-supported display currencies\n     */\n    async getCurrencies() {\n        await this.ensureCacheExists();\n        return Object.keys(this.cData.market_data.current_price);\n    }\n}\n\n/**\n * Refreshes market data from the user's data source, then re-renders currency options and price displays\n */\nexport async function refreshPriceDisplay() {\n    // Refresh our price data\n    await cMarket.fetch();\n\n    // Update the currency customisation menu from the selected data source\n    await fillCurrencySelect();\n\n    // Update price values\n    getBalance(true);\n}\n","import {\n    doms,\n    getBalance,\n    getStakingBalance,\n    refreshChainData,\n    updateActivityGUI,\n    updateGovernanceTab,\n} from './global.js';\nimport { fWalletLoaded, masterKey } from './wallet.js';\nimport { cChainParams } from './chain_params.js';\nimport { setNetwork, ExplorerNetwork, getNetwork } from './network.js';\nimport { createAlert } from './misc.js';\nimport {\n    switchTranslation,\n    ALERTS,\n    translation,\n    arrActiveLangs,\n} from './i18n.js';\nimport { CoinGecko, refreshPriceDisplay } from './prices.js';\nimport { Database } from './database.js';\n\n// --- Default Settings\n/** A mode that emits verbose console info for internal MPW operations */\nexport let debug = false;\n/**\n * The user-selected display currency from market-aggregator sites\n * @type {string}\n */\nexport let strCurrency = 'usd';\n/**\n * The global market data source\n * @type {CoinGecko}\n */\nexport let cMarket = new CoinGecko();\n/** The user-selected explorer, used for most of MPW's data synchronisation */\nexport let cExplorer = cChainParams.current.Explorers[0];\n/** The user-selected MPW node, used for alternative blockchain data */\nexport let cNode = cChainParams.current.Nodes[0];\n/** A mode which allows MPW to automatically select it's data sources */\nexport let fAutoSwitch = true;\n/** The active Cold Staking address: default is the PIVX Labs address */\nexport let strColdStakingAddress = 'SdgQDpS8jDRJDX8yK8m9KnTMarsE84zdsy';\n\nlet transparencyReport;\n\nexport class Settings {\n    /**\n     * @type {String} analytics level\n     */\n    analytics;\n    /**\n     * @type {String} Explorer url to use\n     */\n    explorer;\n    /**\n     * @type {String} Node url to use\n     */\n    node;\n    /**\n     * @type {Boolean} The Auto-Switch mode state\n     */\n    autoswitch;\n    /**\n     * @type {String} The user's active Cold Staking address\n     */\n    coldAddress;\n    /**\n     * @type {String} translation to use\n     */\n    translation;\n    /**\n     * @type {String} Currency to display\n     */\n    displayCurrency;\n    constructor({\n        analytics,\n        explorer,\n        node,\n        autoswitch = true,\n        coldAddress = strColdStakingAddress,\n        translation = 'en',\n        displayCurrency = 'usd',\n    } = {}) {\n        this.analytics = analytics;\n        this.explorer = explorer;\n        this.node = node;\n        this.autoswitch = autoswitch;\n        this.coldAddress = coldAddress;\n        this.translation = translation;\n        this.displayCurrency = displayCurrency;\n    }\n}\n\n// A list of statistic keys and their descriptions\nexport let STATS = {\n    // Stat key   // Description of the stat, it's data, and it's purpose\n    hit: 'A ping indicating an app load, no unique data is sent.',\n    time_to_sync: 'The time in seconds it took for MPW to last synchronise.',\n    transaction:\n        'A ping indicating a Tx, no unique data is sent, but may be inferred from on-chain time.',\n};\n\nexport const cStatKeys = Object.keys(STATS);\n\n// A list of Analytics 'levels' at which the user may set depending on their privacy preferences\nlet arrAnalytics = [\n    // Statistic level  // Allowed statistics\n    { name: 'Disabled', stats: [] },\n    { name: 'Minimal', stats: [STATS.hit, STATS.time_to_sync] },\n    {\n        name: 'Balanced',\n        stats: [STATS.hit, STATS.time_to_sync, STATS.transaction],\n    },\n];\n\nexport let cAnalyticsLevel = arrAnalytics[2];\n\n// Users need not look below here.\n// ------------------------------\n// Global Keystore / Wallet Information\n\n// --- DOM Cache\nexport async function start() {\n    //TRANSLATIONS\n    //to make translations work we need to change it so that we just enable or disable the visibility of the text\n    doms.domTestnet.style.display = cChainParams.current.isTestnet\n        ? ''\n        : 'none';\n    doms.domDebug.style.display = debug ? '' : 'none';\n\n    // Hook up the 'currency' select UI\n    document.getElementById('currency').onchange = function (evt) {\n        setCurrency(evt.target.value);\n    };\n\n    // Hook up the 'explorer' select UI\n    document.getElementById('explorer').onchange = function (evt) {\n        setExplorer(\n            cChainParams.current.Explorers.find(\n                (a) => a.url === evt.target.value\n            )\n        );\n    };\n\n    // Hook up the 'translation' select UI\n    document.getElementById('translation').onchange = function (evt) {\n        setTranslation(evt.target.value);\n    };\n\n    // Hook up the 'analytics' select UI\n    document.getElementById('analytics').onchange = function (evt) {\n        setAnalytics(arrAnalytics.find((a) => a.name === evt.target.value));\n    };\n\n    await Promise.all([\n        fillExplorerSelect(),\n        fillNodeSelect(),\n        fillTranslationSelect(),\n    ]);\n\n    // Fetch price data, then fetch chain data\n    if (getNetwork().enabled) {\n        refreshPriceDisplay().finally(refreshChainData);\n    }\n\n    // Add each analytics level into the UI selector\n    const domAnalyticsSelect = document.getElementById('analytics');\n    for (const analLevel of arrAnalytics) {\n        const opt = document.createElement('option');\n        opt.value = opt.innerHTML = analLevel.name;\n        domAnalyticsSelect.appendChild(opt);\n    }\n\n    const database = await Database.getInstance();\n\n    // Fetch settings from Database\n    const {\n        analytics: strSettingAnalytics,\n        autoswitch,\n        coldAddress,\n    } = await database.getSettings();\n\n    // Set the Cold Staking address\n    strColdStakingAddress = coldAddress;\n\n    // Set any Toggles to their default or DB state\n    fAutoSwitch = autoswitch;\n    doms.domAutoSwitchToggle.checked = fAutoSwitch;\n\n    // Apply translations to the transparency report\n    STATS = {\n        // Stat key   // Description of the stat, it's data, and it's purpose\n        hit: translation.hit,\n        time_to_sync: translation.time_to_sync,\n        transaction: translation.transaction,\n    };\n    transparencyReport = translation.transparencyReport;\n    arrAnalytics = [\n        // Statistic level  // Allowed statistics\n        { name: 'Disabled', stats: [] },\n        { name: 'Minimal', stats: [STATS.hit, STATS.time_to_sync] },\n        {\n            name: 'Balanced',\n            stats: [STATS.hit, STATS.time_to_sync, STATS.transaction],\n        },\n    ];\n\n    // Initialise status icons as their default variables\n    doms.domNetwork.innerHTML =\n        '<i class=\"fa-solid fa-' +\n        (getNetwork().enabled ? 'wifi' : 'ban') +\n        '\"></i>';\n\n    // Honour the \"Do Not Track\" header by default\n    if (!strSettingAnalytics && navigator.doNotTrack === '1') {\n        // Disabled\n        setAnalytics(arrAnalytics[0], true);\n        doms.domAnalyticsDescriptor.innerHTML =\n            '<h6 style=\"color:#dcdf6b;font-family:mono !important;\"><pre style=\"color: inherit;\">Analytics disabled to honour \"Do Not Track\" browser setting, you may manually enable if desired, though!</pre></h6>';\n    } else {\n        // Load from storage, or use defaults\n        setAnalytics(\n            (cAnalyticsLevel =\n                arrAnalytics.find((a) => a.name === strSettingAnalytics) ||\n                cAnalyticsLevel),\n            true\n        );\n    }\n\n    // And update the UI to reflect them\n    domAnalyticsSelect.value = cAnalyticsLevel.name;\n}\n// --- Settings Functions\nexport async function setExplorer(explorer, fSilent = false) {\n    const database = await Database.getInstance();\n    database.setSettings({ explorer: explorer.url });\n    cExplorer = explorer;\n\n    // Enable networking + notify if allowed\n    const network = new ExplorerNetwork(cExplorer.url, masterKey);\n    setNetwork(network);\n\n    // Update the selector UI\n    doms.domExplorerSelect.value = cExplorer.url;\n\n    if (!fSilent)\n        createAlert(\n            'success',\n            ALERTS.SWITCHED_EXPLORERS,\n            [{ explorerName: cExplorer.name }],\n            2250\n        );\n}\n\nasync function setNode(node, fSilent = false) {\n    cNode = node;\n    const database = await Database.getInstance();\n    database.setSettings({ node: node.url });\n\n    // Enable networking + notify if allowed\n    getNetwork().enable();\n    if (!fSilent)\n        createAlert(\n            'success',\n            ALERTS.SWITCHED_NODE,\n            [{ node: cNode.name }],\n            2250\n        );\n}\n\n//TRANSLATION\n/**\n * Switches the translation and sets the translation preference to database\n * @param {string} lang\n * @param {bool} fSilent\n */\nasync function setTranslation(lang) {\n    switchTranslation(lang);\n    const database = await Database.getInstance();\n    database.setSettings({ translation: lang });\n}\n\n/**\n * Sets and saves the display currency setting in runtime and database\n * @param {string} currency - The currency string name\n */\nasync function setCurrency(currency) {\n    strCurrency = currency;\n    const database = await Database.getInstance();\n    database.setSettings({ displayCurrency: strCurrency });\n    // Update the UI to reflect the new currency\n    getBalance(true);\n}\n\n/**\n * Sets and saves the active Cold Staking address\n * @param {string} strColdAddress - The Cold Staking address\n */\nexport async function setColdStakingAddress(strColdAddress) {\n    strColdStakingAddress = strColdAddress;\n    const database = await Database.getInstance();\n    database.setSettings({ coldAddress: strColdAddress });\n}\n\n/**\n * Fills the translation dropbox on the settings page\n */\nasync function fillTranslationSelect() {\n    while (doms.domTranslationSelect.options.length > 0) {\n        doms.domTranslationSelect.remove(0);\n    }\n\n    // Add each trusted explorer into the UI selector\n    for (const lang of arrActiveLangs) {\n        const opt = document.createElement('option');\n        opt.innerHTML = opt.value = lang;\n        doms.domTranslationSelect.appendChild(opt);\n    }\n\n    const database = await Database.getInstance();\n    const { translation } = await database.getSettings();\n    // And update the UI to reflect them\n    doms.domTranslationSelect.value = translation;\n}\n\n/**\n * Fills the display currency dropbox on the settings page\n */\nexport async function fillCurrencySelect() {\n    while (doms.domCurrencySelect.options.length > 0) {\n        doms.domCurrencySelect.remove(0);\n    }\n\n    // Add each data source currency into the UI selector\n    for (const currency of await cMarket.getCurrencies()) {\n        const opt = document.createElement('option');\n        opt.innerHTML = currency.toUpperCase();\n        opt.value = currency;\n        doms.domCurrencySelect.appendChild(opt);\n    }\n\n    const database = await Database.getInstance();\n    const { displayCurrency } = await database.getSettings();\n\n    // And update the UI to reflect them\n    strCurrency = doms.domCurrencySelect.value = displayCurrency;\n}\n\nasync function setAnalytics(level, fSilent = false) {\n    cAnalyticsLevel = level;\n    const database = await Database.getInstance();\n    await database.setSettings({ analytics: level.name });\n\n    // For total transparency, we'll 'describe' the various analytic keys of this chosen level\n    let strDesc = '<center>--- ' + transparencyReport + ' ---</center><br>',\n        i = 0;\n    const nLongestKeyLen = cStatKeys.reduce((prev, e) =>\n        prev.length >= e.length ? prev : e\n    ).length;\n    for (i; i < cAnalyticsLevel.stats.length; i++) {\n        const cStat = cAnalyticsLevel.stats[i];\n        // This formats Stat keys into { $key $(padding) $description }\n        strDesc +=\n            cStatKeys\n                .find((a) => STATS[a] === cStat)\n                .padEnd(nLongestKeyLen, ' ') +\n            ': ' +\n            cStat +\n            '<br>';\n    }\n\n    // Set display + notify if allowed\n    doms.domAnalyticsDescriptor.innerHTML =\n        cAnalyticsLevel.name === arrAnalytics[0].name\n            ? ''\n            : '<h6 style=\"color:#dcdf6b;font-family:mono !important;\"><pre style=\"color: inherit;\">' +\n              strDesc +\n              '</pre></h6>';\n    if (!fSilent)\n        createAlert(\n            'success',\n            ALERTS.SWITCHED_ANALYTICS,\n            [{ level: cAnalyticsLevel.name }],\n            2250\n        );\n}\n\nexport function toggleTestnet() {\n    if (fWalletLoaded) {\n        // Revert testnet toggle\n        doms.domTestnetToggler.checked = !doms.domTestnetToggler.checked;\n        return createAlert('warning', ALERTS.UNABLE_SWITCH_TESTNET, [], 3250);\n    }\n\n    // Update current chain config\n    cChainParams.current = cChainParams.current.isTestnet\n        ? cChainParams.main\n        : cChainParams.testnet;\n\n    // Update UI and static tickers\n    //TRANSLATIONS\n    doms.domTestnet.style.display = cChainParams.current.isTestnet\n        ? ''\n        : 'none';\n    doms.domGuiBalanceTicker.innerText = cChainParams.current.TICKER;\n    doms.domGuiBalanceStakingTicker.innerText = cChainParams.current.TICKER;\n    doms.domPrefixNetwork.innerText =\n        cChainParams.current.PUBKEY_PREFIX.join(' or ');\n\n    // Update testnet toggle in settings\n    doms.domTestnetToggler.checked = cChainParams.current.isTestnet;\n\n    fillExplorerSelect();\n    fillNodeSelect();\n    getBalance(true);\n    getStakingBalance(true);\n    updateActivityGUI();\n    updateGovernanceTab();\n}\n\nexport function toggleDebug() {\n    debug = !debug;\n    doms.domDebug.style.display = debug ? '' : 'none';\n}\n\n/**\n * Toggle the Auto-Switch mode at runtime and in DB\n */\nexport async function toggleAutoSwitch() {\n    fAutoSwitch = !fAutoSwitch;\n\n    // Update the setting in the DB\n    const database = await Database.getInstance();\n    await database.setSettings({ autoswitch: fAutoSwitch });\n}\n\nasync function fillExplorerSelect() {\n    cExplorer = cChainParams.current.Explorers[0];\n\n    while (doms.domExplorerSelect.options.length > 0) {\n        doms.domExplorerSelect.remove(0);\n    }\n\n    // Add each trusted explorer into the UI selector\n    for (const explorer of cChainParams.current.Explorers) {\n        const opt = document.createElement('option');\n        opt.value = explorer.url;\n        opt.innerHTML =\n            explorer.name + ' (' + explorer.url.replace('https://', '') + ')';\n        doms.domExplorerSelect.appendChild(opt);\n    }\n\n    // Fetch settings from Database\n    const database = await Database.getInstance();\n    const { explorer: strSettingExplorer } = await database.getSettings();\n\n    // For any that exist: load them, or use the defaults\n    await setExplorer(\n        cChainParams.current.Explorers.find(\n            (a) => a.url === strSettingExplorer\n        ) || cExplorer,\n        true\n    );\n\n    // And update the UI to reflect them\n    doms.domExplorerSelect.value = cExplorer.url;\n}\n\nasync function fillNodeSelect() {\n    cNode = cChainParams.current.Nodes[0];\n\n    while (doms.domNodeSelect.options.length > 0) {\n        doms.domNodeSelect.remove(0);\n    }\n\n    // Add each trusted node into the UI selector\n    for (const node of cChainParams.current.Nodes) {\n        const opt = document.createElement('option');\n        opt.value = node.url;\n        opt.innerHTML =\n            node.name + ' (' + node.url.replace('https://', '') + ')';\n        doms.domNodeSelect.appendChild(opt);\n    }\n\n    // Fetch settings from Database\n    const database = await Database.getInstance();\n    const { node: strSettingNode } = await database.getSettings();\n\n    // For any that exist: load them, or use the defaults\n    setNode(\n        cChainParams.current.Nodes.find((a) => a.url === strSettingNode) ||\n            cNode,\n        true\n    );\n\n    // And update the UI to reflect them\n    doms.domNodeSelect.value = cNode.url;\n}\n","export const OP = {\n    // push value\n    0: 0x00,\n    FALSE: 0x00, // ALIAS FOR: 0\n    PUSHDATA1: 0x4c,\n    PUSHDATA2: 0x4d,\n    PUSHDATA4: 0x4e,\n    '1NEGATE': 0x4f,\n    RESERVED: 0x50,\n    1: 0x51,\n    TRUE: 0x51, // ALIAS FOR: 1\n    2: 0x52,\n    3: 0x53,\n    4: 0x54,\n    5: 0x55,\n    6: 0x56,\n    7: 0x57,\n    8: 0x58,\n    9: 0x59,\n    10: 0x5a,\n    11: 0x5b,\n    12: 0x5c,\n    13: 0x5d,\n    14: 0x5e,\n    15: 0x5f,\n    16: 0x60,\n\n    // control\n    NOP: 0x61,\n    VER: 0x62,\n    IF: 0x63,\n    NOTIF: 0x64,\n    VERIF: 0x65,\n    VERNOTIF: 0x66,\n    ELSE: 0x67,\n    ENDIF: 0x68,\n    VERIFY: 0x69,\n    RETURN: 0x6a,\n\n    // stack ops\n    TOALTSTACK: 0x6b,\n    FROMALTSTACK: 0x6c,\n    '2DROP': 0x6d,\n    '2DUP': 0x6e,\n    '3DUP': 0x6f,\n    '2OVER': 0x70,\n    '2ROT': 0x71,\n    '2SWAP': 0x72,\n    IFDUP: 0x73,\n    DEPTH: 0x74,\n    DROP: 0x75,\n    DUP: 0x76,\n    NIP: 0x77,\n    OVER: 0x78,\n    PICK: 0x79,\n    ROLL: 0x7a,\n    ROT: 0x7b,\n    SWAP: 0x7c,\n    TUCK: 0x7d,\n\n    // splice ops\n    CAT: 0x7e,\n    SUBSTR: 0x7f,\n    LEFT: 0x80,\n    RIGHT: 0x81,\n    SIZE: 0x82,\n\n    // bit logic\n    INVERT: 0x83,\n    AND: 0x84,\n    OR: 0x85,\n    XOR: 0x86,\n    EQUAL: 0x87,\n    EQUALVERIFY: 0x88,\n    RESERVED1: 0x89,\n    RESERVED2: 0x8a,\n\n    // numeric\n    '1ADD': 0x8b,\n    '1SUB': 0x8c,\n    '2MUL': 0x8d,\n    '2DIV': 0x8e,\n    NEGATE: 0x8f,\n    ABS: 0x90,\n    NOT: 0x91,\n    '0NOTEQUAL': 0x92,\n\n    ADD: 0x93,\n    SUB: 0x94,\n    MUL: 0x95,\n    DIV: 0x96,\n    MOD: 0x97,\n    LSHIFT: 0x98,\n    RSHIFT: 0x99,\n\n    BOOLAND: 0x9a,\n    BOOLOR: 0x9b,\n    NUMEQUAL: 0x9c,\n    NUMEQUALVERIFY: 0x9d,\n    NUMNOTEQUAL: 0x9e,\n    LESSTHAN: 0x9f,\n    GREATERTHAN: 0xa0,\n    LESSTHANOREQUAL: 0xa1,\n    GREATERTHANOREQUAL: 0xa2,\n    MIN: 0xa3,\n    MAX: 0xa4,\n\n    WITHIN: 0xa5,\n\n    // crypto\n    RIPEMD160: 0xa6,\n    SHA1: 0xa7,\n    SHA256: 0xa8,\n    HASH160: 0xa9,\n    HASH256: 0xaa,\n    CODESEPARATOR: 0xab,\n    CHECKSIG: 0xac,\n    CHECKSIGVERIFY: 0xad,\n    CHECKMULTISIG: 0xae,\n    CHECKMULTISIGVERIFY: 0xaf,\n\n    // expansion\n    NOP1: 0xb0,\n    NOP2: 0xb1,\n    CHECKLOCKTIMEVERIFY: 0xb1, // ALIAS FOR: NOP2\n    NOP3: 0xb2,\n    NOP4: 0xb3,\n    NOP5: 0xb4,\n    NOP6: 0xb5,\n    NOP7: 0xb6,\n    NOP8: 0xb7,\n    NOP9: 0xb8,\n    NOP10: 0xb9,\n\n    // zerocoin\n    ZEROCOINMINT: 0xc1,\n    ZEROCOINSPEND: 0xc2,\n    ZEROCOINPUBLICSPEND: 0xc3,\n\n    // cold staking\n    CHECKCOLDSTAKEVERIFY_LOF: 0xd1, // last output free for masternode/budget payments\n    CHECKCOLDSTAKEVERIFY: 0xd2,\n\n    INVALIDOPCODE: 0xff,\n};\nObject.freeze(OP);\n\nexport function getScriptForBurn(data) {\n    let cScript = [];\n    // Check if we're fitting any data into the TX\n    if (typeof data === 'string' && data.length > 0) {\n        let bData = new TextEncoder().encode(data);\n        cScript.push(OP['RETURN']);\n        cScript.push(OP['PUSHDATA1']);\n        // Append the byte array length\n        cScript.push(bData.length);\n        // Convert from uint8 to array and append the byte array\n        cScript = cScript.concat(Array.prototype.slice.call(bData));\n    } else {\n        // Empty data, create a simple RETURN script\n        cScript.push(OP['RETURN']);\n    }\n    // Return the burn script\n    return cScript;\n}\n","import { openDB, IDBPDatabase } from 'idb';\nimport Masternode from './masternode.js';\nimport { Settings } from './settings.js';\nimport { cChainParams } from './chain_params.js';\nimport { confirmPopup, sanitizeHTML, createAlert } from './misc.js';\nimport { PromoWallet } from './promos.js';\n\n/** The current version of the DB - increasing this will prompt the Upgrade process for clients with an older version */\nexport const DB_VERSION = 2;\n\n/**\n *\n */\nexport class Database {\n    /**\n     * Current Database Version.\n     * Version 1 = Add index DB (PR #[FILL])\n     * @type{Number}\n     */\n    static version = 1;\n\n    /**\n     * @type{IDBPDatabase}\n     */\n    #db;\n\n    constructor({ db }) {\n        this.#db = db;\n    }\n\n    close() {\n        this.#db.close();\n        this.#db = null;\n    }\n\n    /**\n     * Add masternode to the database\n     * @param {Masternode} masternode\n     * @param {Masterkey} _masterKey - Masterkey associated to the masternode. Currently unused\n     */\n    async addMasternode(masternode, _masterKey) {\n        const store = this.#db\n            .transaction('masternodes', 'readwrite')\n            .objectStore('masternodes');\n        // For now the key is 'masternode' since we don't support multiple masternodes\n        await store.put(masternode, 'masternode');\n    }\n    /**\n     * Removes a masternode\n     * @param {Masterkey} _masterKey - Masterkey associated to the masternode. Currently unused\n     */\n    async removeMasternode(_masterKey) {\n        const store = this.#db\n            .transaction('masternodes', 'readwrite')\n            .objectStore('masternodes');\n        await store.delete('masternode');\n    }\n\n    /**\n     * Add Promo Code to the database for tracking and management\n     * @param {PromoWallet} promo\n     */\n    async addPromo(promo) {\n        const store = this.#db\n            .transaction('promos', 'readwrite')\n            .objectStore('promos');\n        // The plaintext code is our key, since codes are unique and deterministic anyway\n        await store.put(promo, promo.code);\n    }\n    /**\n     * Removes a Promo Code from the Promo management system\n     * @param {string} promo - the promo code to remove\n     */\n    async removePromo(promo) {\n        const store = this.#db\n            .transaction('promos', 'readwrite')\n            .objectStore('promos');\n        await store.delete(promo);\n    }\n\n    /**\n     * Adds an account to the database\n     * @param {Object} o\n     * @param {String} o.publicKey - Public key associated to the account. Can be an xpub\n     * @param {String} o.encWif - Encrypted private key associated to the account\n     * @param {Array<any>} o.localProposals - Local proposals awaiting to be finalized\n     */\n    async addAccount({ publicKey, encWif, localProposals = [] }) {\n        const oldAccount = await this.getAccount();\n        const newAccount = { publicKey, encWif, localProposals };\n        const store = this.#db\n            .transaction('accounts', 'readwrite')\n            .objectStore('accounts');\n        // When the account system is going to be added, the key is gonna be the publicKey\n        await store.put({ ...oldAccount, ...newAccount }, 'account');\n    }\n\n    /**\n     * Removes an account from the database\n     * @param {Object} o\n     * @param {String} o.publicKey - Public key associated to the account.\n     */\n    async removeAccount({ publicKey }) {\n        const store = this.#db\n            .transaction('accounts', 'readwrite')\n            .objectStore('accounts');\n        // When the account system is going to be added, the key is gonna be the publicKey\n        await store.delete('account');\n    }\n\n    /**\n     * Gets an account from the database\n     * @returns {Promise<{publicKey: String, encWif: String?, localProposals: Array<any>}?>}\n     */\n    async getAccount() {\n        const store = this.#db\n            .transaction('accounts', 'readonly')\n            .objectStore('accounts');\n        return await store.get('account');\n    }\n\n    /**\n     * @returns {Promise<Masternode?>} the masternode stored in the db\n     */\n    async getMasternode(_masterKey) {\n        const store = this.#db\n            .transaction('masternodes', 'readonly')\n            .objectStore('masternodes');\n        return new Masternode(await store.get('masternode'));\n    }\n\n    /**\n     * @returns {Promise<Array<PromoWallet>>} all Promo Codes stored in the db\n     */\n    async getAllPromos() {\n        const store = this.#db\n            .transaction('promos', 'readonly')\n            .objectStore('promos');\n        // Convert all promo objects in to their Class and return them as a new array\n        return (await store.getAll()).map((promo) => new PromoWallet(promo));\n    }\n\n    /**\n     * @returns {Promise<Settings>}\n     */\n    async getSettings() {\n        const store = this.#db\n            .transaction('settings', 'readonly')\n            .objectStore('settings');\n        return new Settings(await store.get('settings'));\n    }\n\n    /**\n     * @param {Settings} settings - settings to use\n     * @returns {Promise<void>}\n     */\n    async setSettings(settings) {\n        const oldSettings = await this.getSettings();\n        const store = this.#db\n            .transaction('settings', 'readwrite')\n            .objectStore('settings');\n        await store.put(\n            {\n                ...oldSettings,\n                ...settings,\n            },\n            'settings'\n        );\n    }\n\n    /**\n     * Migrates from local storage\n     * @param {IDBPDatabase} db\n     */\n    async #migrateLocalStorage() {\n        if (localStorage.length === 0) return;\n        const settings = new Settings({\n            analytics: localStorage.analytics,\n            explorer: localStorage.explorer,\n            node: localStorage.node,\n            translation: localStorage.translation,\n            displayCurrency: localStorage.displayCurrency,\n        });\n        await this.setSettings(settings);\n\n        if (localStorage.masternode) {\n            try {\n                const masternode = JSON.parse(localStorage.masternode);\n                await this.addMasternode(masternode);\n            } catch (e) {\n                console.error(e);\n                createAlert(\n                    'warning',\n                    'Failed to recover your masternode. Please reimport it.'\n                );\n            }\n        }\n\n        if (localStorage.encwif || localStorage.publicKey) {\n            try {\n                const localProposals = JSON.parse(\n                    localStorage.localProposals || '[]'\n                );\n                await this.addAccount({\n                    publicKey: localStorage.publicKey,\n                    encWif: localStorage.encwif,\n                    localProposals,\n                });\n            } catch (e) {\n                console.error(e);\n                createAlert(\n                    'warning',\n                    'Failed to recover your account. Please reimport it.'\n                );\n                if (localStorage.encwif) {\n                    await confirmPopup({\n                        title: 'Failed to recover account',\n                        html: `There was an error recovering your account. <br> Please reimport your wallet using the following key: <code id=\"exportPrivateKeyText\">${sanitizeHTML(\n                            localStorage.encwif\n                        )} </code>`,\n                    });\n                }\n            }\n        }\n    }\n\n    static async create(name) {\n        let migrate = false;\n        const database = new Database({ db: null });\n        const db = await openDB(`MPW-${name}`, DB_VERSION, {\n            upgrade: (db, oldVersion) => {\n                console.log(\n                    'DB: Upgrading from ' + oldVersion + ' to ' + DB_VERSION\n                );\n                if (oldVersion == 0) {\n                    db.createObjectStore('masternodes');\n                    db.createObjectStore('accounts');\n                    db.createObjectStore('settings');\n                    migrate = true;\n                }\n\n                // The introduction of PIVXPromos (safely added during <v2 upgrades)\n                if (oldVersion <= 1) {\n                    db.createObjectStore('promos');\n                }\n            },\n            blocking: () => {\n                // Another instance is waiting to upgrade, and we're preventing it\n                // Close the database and refresh the page\n                // (This would only happen if the user opened another window after MPW got an update)\n                database.close();\n                alert('New update received!');\n                window.location.reload();\n            },\n        });\n        database.#db = db;\n        if (migrate) {\n            database.#migrateLocalStorage();\n        }\n        return database;\n    }\n\n    /**\n     * Map name->instnace\n     * @type{Map<String, Database>}\n     */\n    static #instances = new Map();\n\n    /**\n     * @return {Promise<Database>} the default database instance\n     */\n    static async getInstance() {\n        const name = cChainParams.current.name;\n        const instance = this.#instances.get(name);\n        if (!instance || !instance.#db) {\n            this.#instances.set(name, await Database.create(name));\n        }\n\n        return this.#instances.get(name);\n    }\n}\n","import { translateAlerts } from './i18n.js';\nimport { doms } from './global.js';\nimport qrcode from 'qrcode-generator';\nimport bs58 from 'bs58';\nimport { bech32 } from 'bech32';\nimport { BIP21_PREFIX, cChainParams } from './chain_params';\nimport { dSHA256 } from './utils.js';\n\n/* MPW constants */\nexport const pubKeyHashNetworkLen = 21;\nexport const pubChksum = 4;\nexport const pubPrebaseLen = pubKeyHashNetworkLen + pubChksum;\n\n// Base58 Encoding Map\nexport const MAP_B58 =\n    '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nexport const LEN_B58 = MAP_B58.length;\n\n/* --- UTILS --- */\n// Cryptographic Random-Gen\nexport function getSafeRand(nSize = 32) {\n    return crypto.getRandomValues(new Uint8Array(nSize));\n}\n\nexport const MAP_ALPHANUMERIC =\n    'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n\n/**\n * Generate a random Alpha-Numeric sequence\n * @param {number} nSize - The amount of characters to generate\n * @returns {string} - A random alphanumeric string of nSize length\n */\nexport function getAlphaNumericRand(nSize = 32) {\n    let result = '';\n    const randValues = getSafeRand(nSize);\n    for (const byte of randValues) {\n        const index = byte % MAP_ALPHANUMERIC.length;\n        result += MAP_ALPHANUMERIC.charAt(index);\n    }\n    return result;\n}\n\n// Writes a sequence of Array-like bytes into a location within a Uint8Array\nexport function writeToUint8(arr, bytes, pos) {\n    const arrLen = arr.length;\n    // Sanity: ensure an overflow cannot occur, if one is detected, somewhere in MPW's state could be corrupted.\n    if (arrLen - pos - bytes.length < 0) {\n        const strERR =\n            'CRITICAL: Overflow detected (' +\n            (arrLen - pos - bytes.length) +\n            '), possible state corruption, backup and refresh advised.';\n        createAlert('warning', strERR, 5000);\n        throw Error(strERR);\n    }\n    let i = 0;\n    while (pos < arrLen) arr[pos++] = bytes[i++];\n}\n\n/* --- NOTIFICATIONS --- */\n// Alert - Do NOT display arbitrary / external errors, the use of `.innerHTML` allows for input styling at this cost.\n// Supported types: success, info, warning\nexport function createAlert(type, message, alertVariables = [], timeout = 0) {\n    const domAlert = document.createElement('div');\n    domAlert.classList.add('notifyWrapper');\n    domAlert.classList.add(type);\n    setTimeout(() => {\n        domAlert.style.opacity = '1';\n        domAlert.style.zIndex = '999999';\n        domAlert.classList.add('bounce-ani');\n        domAlert.classList.add('bounce');\n    }, 100);\n\n    // Maintainer QoL adjustment: if `alertVariables` is a number, it is instead assumed to be `timeout`\n    if (typeof alertVariables === 'number') {\n        timeout = alertVariables;\n        alertVariables = [];\n    }\n\n    // Apply translations\n    const translatedMessage = translateAlerts(message, alertVariables);\n\n    // Colors for types\n    let typeIcon;\n    switch (type) {\n        case 'warning':\n            typeIcon = 'fa-exclamation';\n            break;\n        case 'info':\n            typeIcon = 'fa-info';\n            break;\n        default:\n            // If no valid type is set, default to success\n            type == 'success';\n            typeIcon = 'fa-check';\n            break;\n    }\n\n    // Message\n    domAlert.innerHTML = `\n    <div class=\"notifyIcon notify-${type}\">\n        <i class=\"fas ${typeIcon} fa-xl\"></i>\n    </div>\n    <div class=\"notifyText\">\n        ${translatedMessage}\n    </div>`;\n    domAlert.destroy = () => {\n        // Fully destroy timers + DOM elements, no memory leaks!\n        clearTimeout(domAlert.timer);\n        domAlert.style.opacity = '0';\n        setTimeout(() => {\n            domAlert.remove();\n        }, 600);\n    };\n    // On Click: Delete alert from DOM after close animation.\n    domAlert.addEventListener('click', domAlert.destroy);\n    // On Timeout: Delete alert from DOM after a period of inactive time.\n    if (timeout > 0) domAlert.timer = setTimeout(domAlert.destroy, timeout);\n    doms.domAlertPos.appendChild(domAlert);\n}\n\n/**\n * Shows a Confirm popup with custom HTML.\n *\n * If `resolvePromise` has a value, the popup won't have\n * Confirm/Cancel buttons and will wait for the promise to resolve.\n *\n * Returns the awaited value of `resolvePromise` or `true/false` if the\n * user used a Cancel/Confirm button.\n * @param {object} options\n * @param {string?} options.title - The optional title of the popup\n * @param {string} options.html - The HTML of the popup contents\n * @param {Promise<any>} options.resolvePromise - A promise to resolve before closing the modal\n * @param {boolean?} options.hideConfirm - Whether to hide the Confirm button or not\n * @returns {Promise<boolean|any>}\n */\nexport async function confirmPopup({\n    title,\n    html,\n    resolvePromise,\n    hideConfirm,\n}) {\n    // If there's a title provided: display the header and text\n    doms.domConfirmModalHeader.style.display = title ? 'block' : 'none';\n    doms.domConfirmModalTitle.innerHTML = title || '';\n\n    // If there's a promise to resolve, don't display buttons; the modal visibility will be controlled by the promise (f.e: a 'pls wait' screen)\n    doms.domConfirmModalButtons.style.setProperty(\n        'display',\n        resolvePromise ? 'none' : 'block',\n        resolvePromise ? 'important' : undefined\n    );\n    $('#confirmModal').modal(resolvePromise ? 'show' : { keyboard: false });\n\n    // Show or hide the confirm button, and replace 'Cancel' with 'Close'\n    doms.domConfirmModalConfirmButton.style.display = hideConfirm ? 'none' : '';\n    doms.domConfirmModalCancelButton.innerText = hideConfirm\n        ? 'Close'\n        : 'Cancel';\n\n    // Set content display\n    doms.domConfirmModalContent.innerHTML = html;\n\n    // If there's an input in the prompt, focus the cursor upon it\n    for (const domElement of doms.domConfirmModalContent.children) {\n        if (domElement.type === 'text' || domElement.type === 'password') {\n            domElement.focus();\n            break;\n        }\n    }\n\n    // Wait for the promise to resolve OR create a new one which resolves upon a modal button click\n    resolvePromise =\n        resolvePromise ||\n        new Promise((res, _) => {\n            doms.domConfirmModalConfirmButton.onclick = () => {\n                res(true);\n            };\n            doms.domConfirmModalCancelButton.onclick = () => {\n                res(false);\n            };\n        });\n    try {\n        return await resolvePromise;\n    } finally {\n        // We want to hide the modal even if an exception occurs\n        $('#confirmModal').modal('hide');\n    }\n}\n\n// Generates and sets a QRCode image from a string and dom element\nexport function createQR(strData = '', domImg, size = 4) {\n    // QRCode class consists of 'typeNumber' & 'errorCorrectionLevel'\n    const cQR = qrcode(size, 'L');\n    cQR.addData(strData);\n    cQR.make();\n    domImg.innerHTML = cQR.createImgTag(2, 2);\n    domImg.firstChild.style.borderRadius = '8px';\n}\n\n/**\n * Attempt to safely parse a BIP21 Payment Request\n * @param {string} strReq - BIP21 Payment Request string\n * @returns {object | false}\n */\nexport function parseBIP21Request(strReq) {\n    // Format should match: pivx:addr[?amount=x&label=x]\n    if (!strReq.includes(BIP21_PREFIX + ':')) return false;\n\n    const [addressPart, optionsPart] = strReq.includes('?')\n        ? strReq.split('?')\n        : [strReq, false];\n    const strAddress = addressPart.substring(BIP21_PREFIX.length + 1); // remove 'pivx:' prefix\n    let cOptions = {};\n\n    // Ensure the address is valid\n    if (\n        // Standard address\n        (strAddress.length !== 34 ||\n            !cChainParams.current.PUBKEY_PREFIX.includes(strAddress[0])) &&\n        // Shield address\n        !isValidBech32(strAddress).valid\n    ) {\n        return false;\n    }\n\n    if (optionsPart) {\n        cOptions = Object.fromEntries(\n            optionsPart\n                .split('&')\n                .map((opt) => opt.split('=').map(decodeURIComponent))\n        );\n    }\n\n    return { address: strAddress, options: cOptions };\n}\n\n/**\n * @typedef {object} Bech32Check\n * @property {boolean} valid - If the string is a valid bech32 address\n * @property {object} res - The results of the bech32 decoding\n */\n\n/**\n * A safe bech32 wrapper for quickly checking if an address is valid\n * @param {string} str - Bech32 Address\n * @returns {Bech32Check} - Both the validity and decoding results\n */\nexport function isValidBech32(str) {\n    try {\n        return { valid: true, res: bech32.decode(str) };\n    } catch (e) {\n        return { valid: false, res: e };\n    }\n}\n\n/**\n * Generate an encoded private key for masternodes\n */\nexport function generateMasternodePrivkey() {\n    // Prefix the network byte with the private key (32 random bytes)\n    const data = [cChainParams.current.SECRET_KEY, ...getSafeRand(32)];\n\n    // Compute and concatenate the checksum, then encode the private key as Base58\n    return bs58.encode([...data, ...dSHA256(data).slice(0, 4)]);\n}\n\nexport function sanitizeHTML(text) {\n    const element = document.createElement('div');\n    element.innerText = text;\n    return element.innerHTML;\n}\n\n/**\n * Check if a string is valid Base64 encoding\n * @param {string} str - String to check\n * @returns {boolean}\n */\nexport function isBase64(str) {\n    const base64Regex = /^[A-Za-z0-9+/=]+$/;\n\n    // Check if the string contains only Base64 characters:\n    if (!base64Regex.test(str)) {\n        return false;\n    }\n\n    // Check if the length is a multiple of 4 (required for Base64):\n    if (str.length % 4 !== 0) {\n        return false;\n    }\n\n    // Try decoding the Base64 string to check for errors:\n    try {\n        atob(str);\n    } catch (e) {\n        return false;\n    }\n\n    // The string is likely Base64-encoded:\n    return true;\n}\n\n/**\n * An artificial sleep function to pause code execution\n *\n * @param {Number} ms - The milliseconds to sleep\n *\n * @example\n * // Pause an asynchronous script for 1 second\n * await sleep(1000);\n */\nexport function sleep(ms) {\n    return new Promise((res, _) => setTimeout(res, ms));\n}\n","import { en_translation } from '../locale/en/translation.js';\nimport { uwu_translation } from '../locale/uwu/translation.js';\nimport { Database } from './database.js';\n\nexport const ALERTS = {};\nexport let translation = {};\n\n// TRANSLATION\n//Create an object of objects filled with all the translations\nexport const translatableLanguages = {\n    en: en_translation,\n    uwu: uwu_translation,\n};\n\n/**\n * Takes the language name and sets the translation settings based on the language file\n * @param {string} langName\n */\nexport function switchTranslation(langName) {\n    if (arrActiveLangs.includes(langName)) {\n        translation = translatableLanguages[langName];\n        translate(translation);\n        loadAlerts();\n        return true;\n    } else {\n        console.log(\n            'i18n: The language (' +\n                langName +\n                \") is not supported yet, if you'd like to contribute translations (for rewards!) contact us on GitHub or Discord!\"\n        );\n        translation = translatableLanguages.en_translation;\n        return false;\n    }\n}\n\n/**\n * Takes a string that includes {x} and replaces that based on what is in the array of objects\n * @param {string} message\n * @param {array<Object>} variables\n * @returns a string with the variables implemented in the string\n *\n * @example\n * //returns \"test this\"\n * translateAlerts(\"test {x}\" [x : \"this\"])\n */\nexport function translateAlerts(message, variables) {\n    variables.forEach((element) => {\n        message = message.replaceAll(\n            '{' + Object.keys(element)[0] + '}',\n            Object.values(element)[0]\n        );\n    });\n    return message;\n}\n\n/**\n * Translates all the static html based on the tag data-i18n\n * @param {Array} i18nLangs\n *\n */\nexport function translate(i18nLangs) {\n    if (!i18nLangs) return;\n\n    document.querySelectorAll('[data-i18n]').forEach(function (element) {\n        if (!i18nLangs[element.dataset.i18n]) return;\n\n        if (element.dataset.i18n_target) {\n            element[element.dataset.i18n_target] =\n                i18nLangs[element.dataset.i18n];\n        } else {\n            switch (element.tagName.toLowerCase()) {\n                case 'input':\n                case 'textarea':\n                    element.placeholder = i18nLangs[element.dataset.i18n];\n                    break;\n                default:\n                    element.innerHTML = i18nLangs[element.dataset.i18n];\n                    break;\n            }\n        }\n    });\n    loadAlerts();\n}\n\n/**\n * Translates the alerts by loading the data into the ALERTS object\n */\nexport function loadAlerts() {\n    // Alerts are designated by a special 'ALERTS' entry in each translation file\n    let fFoundAlerts = false;\n    for (const [alert_key, alert_translation] of Object.entries(translation)) {\n        if (fFoundAlerts) {\n            ALERTS[alert_key] = alert_translation;\n        }\n        // Skip all entries until we find the ALERTS flag\n        if (alert_key === 'ALERTS') fFoundAlerts = true;\n    }\n}\nfunction parseUserAgentLang(strUA, arrLangsWithSubset) {\n    if (arrLangsWithSubset.some((strLang) => strUA.includes(strLang))) {\n        // Split the lang in to 'primary' and 'subset', only use the primary lang\n        return strUA.substring(0, 2);\n    }\n    // Otherwise, just use the full language spec\n    return strUA;\n}\n\n// When adding a lang remember to add it to the object translatableLanguages as well as here.\nexport const arrActiveLangs = ['en', 'uwu'];\n\nexport async function start() {\n    // We use this function to parse the UA lang in a safer way: for example, there's multiple `en` definitions\n    // ... but we shouldn't duplicate the language files, we can instead cut the affix (US, GB) and simply use 'en'.\n    // ... This logic may apply to other languages with such subsets as well, so take care of them here!\n    const arrLangsWithSubset = ['en'];\n\n    const strLang = parseUserAgentLang(\n        window.navigator.userLanguage || window.navigator.language,\n        arrLangsWithSubset\n    );\n\n    // When removing you do not have to remove from translatableLanguages\n    const database = await Database.getInstance();\n    const { translation: localTranslation } = await database.getSettings();\n\n    // Check if set in local storage\n    if (localTranslation != null) {\n        switchTranslation(localTranslation);\n    } else {\n        // Check if we support the user's browser locale\n        if (arrActiveLangs.includes(strLang)) {\n            switchTranslation(strLang);\n        } else {\n            // Default to EN if the locale isn't supported yet\n            console.log(\n                'i18n: Your language (' +\n                    strLang +\n                    \") is not supported yet, if you'd like to contribute translations (for rewards!) contact us on GitHub or Discord!\"\n            );\n            switchTranslation('en');\n        }\n    }\n    translate(translation);\n}\n","import { EventEmitter } from 'events';\n\nconst eventEmitter = new EventEmitter();\n\n/**\n * Get the application wide event emitter.\n * @returns {EventEmitter}\n */\nexport function getEventEmitter() {\n    return eventEmitter;\n}\n","import { getNetwork } from './network.js';\nimport { getBalance, isMasternodeUTXO, getStakingBalance } from './global.js';\nimport { sleep } from './misc.js';\nimport { debug } from './settings.js';\nimport { getEventEmitter } from './event_bus.js';\n\n/** An Unspent Transaction Output, used as Inputs of future transactions */\nexport class UTXO {\n    /**\n     * @param {Object} UTXO\n     * @param {String} UTXO.id - Transaction ID\n     * @param {String} UTXO.path - If applicable, the HD Path of the owning address\n     * @param {Number} UTXO.sats - Satoshi value in this UTXO\n     * @param {String} UTXO.script - HEX encoded spending script\n     * @param {Number} UTXO.vout - Output position of this transaction\n     * @param {Number} UTXO.height - Block height of the UTXO\n     * @param {Number} UTXO.status - UTXO status enum state\n     * @param {bool} UTXO.isDelegate - Whether the UTXO is a cold stake delegation\n     */\n    constructor({\n        id,\n        path,\n        sats,\n        script,\n        vout,\n        height,\n        status,\n        isDelegate = false,\n        isReward = false,\n    } = {}) {\n        /** Transaction ID\n         * @type {String} */\n        this.id = id;\n\n        /** HD Path of the owning address\n         *  @type {String} */\n        this.path = path;\n\n        /** Satoshi value in this UTXO\n         *  @type {Number} */\n        this.sats = sats;\n\n        /** HEX encoded spending script\n         *  @type {String} */\n        this.script = script;\n\n        /** Output position of this transaction\n         *  @type {Number} */\n        this.vout = vout;\n\n        /** Block height of the UTXO\n         *  @type {Number} */\n        this.height = height;\n\n        /** UTXO status enum state\n         *  @type {Number} */\n        this.status = status;\n\n        /** If it's a delegation UTXO\n         * @type {bool} */\n        this.isDelegate = isDelegate;\n\n        this.isReward = isReward;\n    }\n\n    /**\n     * Check for equality between this UTXO and another UTXO\n     * @param {UTXO} cUTXO - UTXO to compare against\n     * @returns {Boolean} `true` if equal, `false` if unequal\n     */\n    equalsUTXO(cUTXO) {\n        return (\n            this.id === cUTXO.id &&\n            this.vout === cUTXO.vout &&\n            this.status === cUTXO.status\n        );\n    }\n}\n\n/** A Mempool instance, stores and handles UTXO data for the wallet */\nexport class Mempool {\n    constructor() {\n        /**\n         * An array of all known UTXOs\n         * @type {Array<UTXO>}\n         */\n        this.UTXOs = [];\n        this.subscribeToNetwork();\n    }\n\n    /** The CONFIRMED state (UTXO is spendable) */\n    static CONFIRMED = 0;\n\n    /** The REMOVED state (UTXO was spent and will be removed soon) */\n    static REMOVED = 1;\n\n    /** The PENDING state (standard UTXO is in mempool, pending confirmation) */\n    static PENDING = 2;\n\n    /**\n     * Remove a UTXO after a set amount of time\n     * @param {Number} nBlocks - Estimated blocks to wait\n     * @param {UTXO} cUTXO - UTXO to remove\n     */\n    async removeWithDelay(nBlocks, cUTXO) {\n        await sleep(nBlocks * 60 * 1000);\n        this.removeUTXO(cUTXO);\n    }\n\n    /**\n     * Check if an exact UTXO match can be found in our wallet\n     * @param {Object} UTXO\n     * @param {String} UTXO.id - Transaction ID\n     * @param {Number} UTXO.vout - Output position of this transaction\n     * @param {Number} [UTXO.status] - UTXO status enum state. If it's undefined, it will ignore it.\n     * @returns {Boolean} `true` or `false`\n     */\n    isAlreadyStored({ id, vout, status }) {\n        return this.UTXOs.some(\n            (cUTXO) =>\n                cUTXO.id === id &&\n                cUTXO.vout === vout &&\n                (!status || cUTXO.status === status)\n        );\n    }\n\n    /**\n     * Fetches an array of UTXOs filtered by their state\n     * @param {Number} nState - Specific UTXO state\n     * @returns {Array<UTXO>} `array` - An array of UTXOs\n     */\n    getUTXOsByState(nState) {\n        return this.UTXOs.filter((cUTXO) => cUTXO.status === nState);\n    }\n\n    /**\n     * Removes a UTXO from a specific state\n     * @param {UTXO} cNewUTXO - Pending UTXO to remove\n     * @param {Number} nState - Specific state of this UTXO to search for\n     */\n    removeFromState(cNewUTXO, nState) {\n        const arrPendingUTXOs = this.getUTXOsByState(nState);\n        // Loop each pending UTXO\n        for (const cUTXO of arrPendingUTXOs) {\n            // Search for matching ID + output number\n            if (cUTXO.id === cNewUTXO.id && cUTXO.vout === cNewUTXO.vout) {\n                // Nuke it from orbit\n                this.removeUTXO(cUTXO);\n                break;\n            }\n        }\n    }\n\n    /**\n     * Add a new UTXO to the wallet\n     * @param {Object} UTXO\n     * @param {String} UTXO.id - Transaction ID\n     * @param {String} UTXO.path - If applicable, the HD Path of the owning address\n     * @param {Number} UTXO.sats - Satoshi value in this UTXO\n     * @param {String} UTXO.script - HEX encoded spending script\n     * @param {Number} UTXO.vout - Output position of this transaction\n     * @param {Number} UTXO.height - Block height of the UTXO\n     * @param {Number} UTXO.status - UTXO status enum state\n     * @param {Boolean} UTXO.isDelegate - If this is a Cold Delegation\n     */\n    addUTXO({\n        id,\n        path,\n        sats,\n        script,\n        vout,\n        height,\n        status,\n        isDelegate,\n        isReward,\n    }) {\n        const newUTXO = new UTXO({\n            id,\n            path,\n            sats,\n            script,\n            vout,\n            height,\n            status,\n            isDelegate,\n            isReward,\n        });\n\n        if (this.isAlreadyStored({ id, vout })) {\n            this.updateUTXO({ id, vout });\n        } else {\n            this.UTXOs.push(newUTXO);\n        }\n        getBalance(true);\n        getStakingBalance(true);\n    }\n\n    /**\n     * Update an existing UTXO, by confirming its pending status\n     * The UTXO must be in\n     * @param {Object} UTXO - Object to be deconstructed\n     * @param {String} UTXO.id - Transaction id\n     * @param {Number} UTXO.vout - vout\n     */\n    updateUTXO({ id, vout }) {\n        if (debug) {\n            console.assert(\n                this.isAlreadyStored({ id, vout }),\n                'updateUTXO must be called with an existing UTXO'\n            );\n        }\n        const cUTXO = this.UTXOs.find(\n            (utxo) => utxo.id === id && utxo.vout == vout\n        );\n        switch (cUTXO.status) {\n            case Mempool.PENDING:\n                cUTXO.status = Mempool.CONFIRMED;\n                break;\n        }\n        getBalance(true);\n        getStakingBalance(true);\n    }\n\n    /**\n     * Remove a UTXO completely from our wallet\n     * @param {UTXO} cUTXO - UTXO to remove\n     */\n    removeUTXO(cUTXO) {\n        this.UTXOs = this.UTXOs.filter((utxo) => !utxo.equalsUTXO(cUTXO));\n    }\n\n    /**\n     * Remove a UTXO completely from our wallet, with a 12 minute delay given his id, path and vout\n     * @param {Object} UTXO\n     * @param {String} UTXO.id - Transaction ID\n     * @param {Number} UTXO.vout - Output position of this transaction\n     */\n    autoRemoveUTXO({ id, vout }) {\n        for (const cUTXO of this.UTXOs) {\n            // Loop given + internal UTXOs to find a match, then start the delayed removal\n            if (cUTXO.id === id && cUTXO.vout === vout) {\n                cUTXO.status = Mempool.REMOVED;\n                this.removeWithDelay(12, cUTXO);\n                return;\n            }\n        }\n        console.error(\n            'Mempool: Failed to find UTXO ' +\n                id +\n                ' (' +\n                vout +\n                ') for auto-removal!'\n        );\n    }\n\n    /**\n     * Remove many UTXOs completely from our wallet, with a 12 minute delay\n     * @param {Array<UTXO>} arrUTXOs - UTXOs to remove\n     */\n    autoRemoveUTXOs(arrUTXOs) {\n        for (const cNewUTXO of arrUTXOs) {\n            for (const cUTXO of this.UTXOs) {\n                // Loop given + internal UTXOs to find a match, then start the delayed removal\n                if (cUTXO.equalsUTXO(cNewUTXO)) {\n                    cUTXO.status = Mempool.REMOVED;\n                    this.removeWithDelay(12, cUTXO);\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * Fetches an array of confirmed UTXOs, an easier alias to {@link getUTXOsByState}\n     * @returns {Array<UTXO>} `array` - An array of UTXOs\n     */\n    getConfirmed() {\n        return this.getUTXOsByState(Mempool.CONFIRMED);\n    }\n\n    /**\n     * Get standard, non delegated, UTXOs\n     * @returns {Array<UTXO>} Non delegated utxos\n     */\n    getStandardUTXOs() {\n        return this.UTXOs.filter(\n            (cUTXO) => cUTXO.status !== Mempool.REMOVED && !cUTXO.isDelegate\n        );\n    }\n\n    /**\n     * Get delegated UTXOs\n     * @returns {Array<UTXO>} Delegated UTXOs\n     */\n    getDelegatedUTXOs() {\n        return this.UTXOs.filter(\n            (cUTXO) => cUTXO.status !== Mempool.REMOVED && cUTXO.isDelegate\n        );\n    }\n\n    /**\n     * Returns the real-time balance of the wallet (all addresses)\n     * @returns {Number} Balance in satoshis\n     */\n    getBalance() {\n        // Fetch 'standard' balances: the sum of all Confirmed or Unconfirmed transactions (excluding Masternode collaterals)\n        return this.getStandardUTXOs()\n            .filter((cUTXO) => !isMasternodeUTXO(cUTXO)) // TODO: add masternode\n            .reduce((a, b) => a + b.sats, 0);\n    }\n\n    /**\n     * Returns if a UTXO is valid\n     * @param {UTXO} cUTXO - UTXO\n     * @returns {Boolean} `true` if the reward UTXO is spendable, `false` if not\n     */\n    static isValidUTXO(cUTXO) {\n        if (cUTXO.isReward) {\n            return getNetwork().cachedBlockCount - cUTXO.height > 100;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Returns the real-time delegated balance of the wallet (all addresses)\n     * @returns {Number} Delegated balance in satoshis\n     */\n    getDelegatedBalance() {\n        return this.getDelegatedUTXOs().reduce((a, b) => a + b.sats, 0);\n    }\n\n    /**\n     * Subscribes to network events\n     * @param {Network} network\n     */\n    subscribeToNetwork() {\n        getEventEmitter().on('utxo', async (utxos) => {\n            for (const utxo of utxos) {\n                if (this.isAlreadyStored({ id: utxo.txid, vout: utxo.vout })) {\n                    this.updateUTXO({ id: utxo.txid, vout: utxo.vout });\n                    continue;\n                }\n                this.addUTXO(await getNetwork().getUTXOFullInfo(utxo));\n            }\n        });\n    }\n}\n","import { Mempool } from './mempool.js';\nimport Masternode from './masternode.js';\nimport { ALERTS, start as i18nStart, translation } from './i18n.js';\nimport * as jdenticon from 'jdenticon';\nimport {\n    masterKey,\n    hasEncryptedWallet,\n    importWallet,\n    encryptWallet,\n    decryptWallet,\n    getNewAddress,\n    getDerivationPath,\n    LegacyMasterKey,\n} from './wallet.js';\nimport { getNetwork, HistoricalTxType } from './network.js';\nimport {\n    start as settingsStart,\n    cExplorer,\n    debug,\n    cMarket,\n    strCurrency,\n    setColdStakingAddress,\n    strColdStakingAddress,\n} from './settings.js';\nimport { createAndSendTransaction, signTransaction } from './transactions.js';\nimport {\n    createAlert,\n    confirmPopup,\n    sanitizeHTML,\n    MAP_B58,\n    parseBIP21Request,\n    isValidBech32,\n    isBase64,\n    sleep,\n} from './misc.js';\nimport { cChainParams, COIN, MIN_PASS_LENGTH } from './chain_params.js';\nimport { decrypt } from './aes-gcm.js';\n\nimport { registerWorker } from './native.js';\nimport { refreshPriceDisplay } from './prices.js';\nimport { Address6 } from 'ip-address';\nimport { getEventEmitter } from './event_bus.js';\nimport { scanQRCode } from './scanner.js';\nimport { Database } from './database.js';\nimport bitjs from './bitTrx.js';\nimport { checkForUpgrades } from './changelog.js';\nimport { FlipDown } from './flipdown.js';\n\n/** A flag showing if base MPW is fully loaded or not */\nexport let fIsLoaded = false;\n\n/** A getter for the flag showing if base MPW is fully loaded or not */\nexport function isLoaded() {\n    return fIsLoaded;\n}\n\nexport let doms = {};\n\nexport async function start() {\n    doms = {\n        domNavbarToggler: document.getElementById('navbarToggler'),\n        domDashboard: document.getElementById('dashboard'),\n        domGuiStaking: document.getElementById('guiStaking'),\n        domGuiWallet: document.getElementById('guiWallet'),\n        domGuiBalance: document.getElementById('guiBalance'),\n        domGuiBalanceTicker: document.getElementById('guiBalanceTicker'),\n        domGuiBalanceValue: document.getElementById('guiBalanceValue'),\n        domGuiBalanceValueCurrency: document.getElementById(\n            'guiBalanceValueCurrency'\n        ),\n        domGuiStakingValue: document.getElementById('guiStakingValue'),\n        domGuiStakingValueCurrency: document.getElementById(\n            'guiStakingValueCurrency'\n        ),\n        domGuiBalanceBox: document.getElementById('guiBalanceBox'),\n        domBalanceReload: document.getElementById('balanceReload'),\n        domBalanceReloadStaking: document.getElementById(\n            'balanceReloadStaking'\n        ),\n        domGuiBalanceStaking: document.getElementById('guiBalanceStaking'),\n        domGuiBalanceStakingTicker: document.getElementById(\n            'guiBalanceStakingTicker'\n        ),\n        domGuiStakingLoadMore: document.getElementById('stakingLoadMore'),\n        domGuiStakingLoadMoreIcon: document.getElementById(\n            'stakingLoadMoreIcon'\n        ),\n        domGuiBalanceBoxStaking: document.getElementById(\n            'guiBalanceBoxStaking'\n        ),\n        domStakeAmount: document.getElementById('delegateAmount'),\n        domUnstakeAmount: document.getElementById('undelegateAmount'),\n        domStakeTab: document.getElementById('stakeTab'),\n        domAddress1s: document.getElementById('address1s'),\n        domSendAmountCoins: document.getElementById('sendAmountCoins'),\n        domSendAmountCoinsTicker: document.getElementById(\n            'sendAmountCoinsTicker'\n        ),\n        domSendAmountValue: document.getElementById('sendAmountValue'),\n        domSendAmountValueCurrency: document.getElementById(\n            'sendAmountValueCurrency'\n        ),\n        domStakeAmountCoinsTicker: document.getElementById(\n            'stakeAmountCoinsTicker'\n        ),\n        domStakeAmountValueCurrency: document.getElementById(\n            'stakeAmountValueCurrency'\n        ),\n        domStakeAmountValue: document.getElementById('stakeAmountValue'),\n        domUnstakeAmountCoinsTicker: document.getElementById(\n            'unstakeAmountCoinsTicker'\n        ),\n        domUnstakeAmountValueCurrency: document.getElementById(\n            'unstakeAmountValueCurrency'\n        ),\n\n        domUnstakeAmountValue: document.getElementById('unstakeAmountValue'),\n        domGuiViewKey: document.getElementById('guiViewKey'),\n        domModalQR: document.getElementById('ModalQR'),\n        domModalQrLabel: document.getElementById('ModalQRLabel'),\n        domModalQRReader: document.getElementById('qrReaderModal'),\n        domQrReaderStream: document.getElementById('qrReaderStream'),\n        domCloseQrReaderBtn: document.getElementById('closeQrReader'),\n        domModalWalletBreakdown: document.getElementById(\n            'walletBreakdownModal'\n        ),\n        domWalletBreakdownCanvas: document.getElementById(\n            'walletBreakdownCanvas'\n        ),\n        domPrefix: document.getElementById('prefix'),\n        domPrefixNetwork: document.getElementById('prefixNetwork'),\n        domWalletToggle: document.getElementById('wToggle'),\n        domGenerateWallet: document.getElementById('generateWallet'),\n        domGenVanityWallet: document.getElementById('generateVanityWallet'),\n        domGenHardwareWallet: document.getElementById('generateHardwareWallet'),\n        //GOVERNANCE ELEMENTS\n        domGovTab: document.getElementById('governanceTab'),\n        domGovProposalsTable: document.getElementById('proposalsTable'),\n        domGovProposalsTableBody: document.getElementById('proposalsTableBody'),\n        domTotalGovernanceBudget: document.getElementById(\n            'totalGovernanceBudget'\n        ),\n        domTotalGovernanceBudgetValue: document.getElementById(\n            'totalGovernanceBudgetValue'\n        ),\n        domAllocatedGovernanceBudget: document.getElementById(\n            'allocatedGovernanceBudget'\n        ),\n        domAllocatedGovernanceBudgetValue: document.getElementById(\n            'allocatedGovernanceBudgetValue'\n        ),\n        domAllocatedGovernanceBudget2: document.getElementById(\n            'allocatedGovernanceBudget2'\n        ),\n        domAllocatedGovernanceBudgetValue2: document.getElementById(\n            'allocatedGovernanceBudgetValue2'\n        ),\n        domGovProposalsContestedTable: document.getElementById(\n            'proposalsContestedTable'\n        ),\n        domGovProposalsContestedTableBody: document.getElementById(\n            'proposalsContestedTableBody'\n        ),\n        //MASTERNODE ELEMENTS\n        domCreateMasternode: document.getElementById('createMasternode'),\n        domControlMasternode: document.getElementById('controlMasternode'),\n        domAccessMasternode: document.getElementById('accessMasternode'),\n        domMnAccessMasternodeText: document.getElementById(\n            'accessMasternodeText'\n        ),\n        domMnCreateType: document.getElementById('mnCreateType'),\n        domMnTextErrors: document.getElementById('mnTextErrors'),\n        domMnIP: document.getElementById('mnIP'),\n        domMnTxId: document.getElementById('mnTxId'),\n        domMnPrivateKey: document.getElementById('mnPrivateKey'),\n        domMnDashboard: document.getElementById('mnDashboard'),\n        domMnProtocol: document.getElementById('mnProtocol'),\n        domMnStatus: document.getElementById('mnStatus'),\n        domMnNetType: document.getElementById('mnNetType'),\n        domMnNetIP: document.getElementById('mnNetIP'),\n        domMnLastSeen: document.getElementById('mnLastSeen'),\n\n        domAccessWallet: document.getElementById('accessWallet'),\n        domImportWallet: document.getElementById('importWallet'),\n        domImportWalletText: document.getElementById('importWalletText'),\n        domAccessWalletBtn: document.getElementById('accessWalletBtn'),\n        domVanityUiButtonTxt: document.getElementById('vanButtonText'),\n        domGenKeyWarning: document.getElementById('genKeyWarning'),\n        domEncryptWarningTxt: document.getElementById('encryptWarningText'),\n        domEncryptBtnTxt: document.getElementById('encryptButton'),\n        domEncryptPasswordBox: document.getElementById('encryptPassword'),\n        domEncryptPasswordFirst: document.getElementById('newPassword'),\n        domEncryptPasswordSecond: document.getElementById('newPasswordRetype'),\n        domGuiAddress: document.getElementById('guiAddress'),\n        domGenIt: document.getElementById('genIt'),\n        domHumanReadable: document.getElementById('HumanReadable'),\n        domReqDesc: document.getElementById('reqDesc'),\n        domReqDisplay: document.getElementById('reqDescDisplay'),\n        domIdenticon: document.getElementById('identicon'),\n        domPrivKey: document.getElementById('privateKey'),\n        domPrivKeyPassword: document.getElementById('privateKeyPassword'),\n        domAvailToDelegate: document.getElementById('availToDelegate'),\n        domAvailToUndelegate: document.getElementById('availToUndelegate'),\n        domAnalyticsDescriptor: document.getElementById('analyticsDescriptor'),\n        domStakingRewardsList: document.getElementById(\n            'staking-rewards-content'\n        ),\n        domStakingRewardsTitle: document.getElementById(\n            'staking-rewards-title'\n        ),\n        domMnemonicModalContent: document.getElementById(\n            'ModalMnemonicContent'\n        ),\n        domMnemonicModalButton: document.getElementById(\n            'modalMnemonicConfirmButton'\n        ),\n        domMnemonicModalPassphrase: document.getElementById(\n            'ModalMnemonicPassphrase'\n        ),\n        domExportPrivateKey: document.getElementById('exportPrivateKeyText'),\n        domExportWallet: document.getElementById('guiExportWalletItem'),\n        domWipeWallet: document.getElementById('guiWipeWallet'),\n        domRestoreWallet: document.getElementById('guiRestoreWallet'),\n        domNewAddress: document.getElementById('guiNewAddress'),\n        domRedeemTitle: document.getElementById('redeemCodeModalTitle'),\n        domRedeemCodeUse: document.getElementById('redeemCodeUse'),\n        domRedeemCodeCreate: document.getElementById('redeemCodeCreate'),\n        domRedeemCodeGiftIconBox: document.getElementById(\n            'redeemCodeGiftIconBox'\n        ),\n        domRedeemCodeGiftIcon: document.getElementById('redeemCodeGiftIcon'),\n        domRedeemCodeETA: document.getElementById('redeemCodeETA'),\n        domRedeemCodeProgress: document.getElementById('redeemCodeProgress'),\n        domRedeemCodeInputBox: document.getElementById('redeemCodeInputBox'),\n        domRedeemCodeInput: document.getElementById('redeemCodeInput'),\n        domRedeemCodeConfirmBtn: document.getElementById(\n            'redeemCodeModalConfirmButton'\n        ),\n        domRedeemCodeModeRedeemBtn: document.getElementById(\n            'redeemCodeModeRedeem'\n        ),\n        domRedeemCodeModeCreateBtn: document.getElementById(\n            'redeemCodeModeCreate'\n        ),\n        domRedeemCodeCreateInput: document.getElementById(\n            'redeemCodeCreateInput'\n        ),\n        domRedeemCodeCreateAmountInput: document.getElementById(\n            'redeemCodeCreateAmountInput'\n        ),\n        domRedeemCodeCreatePendingList: document.getElementById(\n            'redeemCodeCreatePendingList'\n        ),\n        domPromoTable: document.getElementById('promo-table'),\n        domActivityList: document.getElementById('activity-list-content'),\n        domActivityLoadMore: document.getElementById('activityLoadMore'),\n        domActivityLoadMoreIcon: document.getElementById(\n            'activityLoadMoreIcon'\n        ),\n        domConfirmModalHeader: document.getElementById('confirmModalHeader'),\n        domConfirmModalTitle: document.getElementById('confirmModalTitle'),\n        domConfirmModalContent: document.getElementById('confirmModalContent'),\n        domConfirmModalButtons: document.getElementById('confirmModalButtons'),\n        domConfirmModalConfirmButton: document.getElementById(\n            'confirmModalConfirmButton'\n        ),\n        domConfirmModalCancelButton: document.getElementById(\n            'confirmModalCancelButton'\n        ),\n\n        masternodeLegacyAccessText:\n            'Access the masternode linked to this address<br> Note: the masternode MUST have been already created (however it can be online or offline)<br>  If you want to create a new masternode access with a HD wallet',\n        masternodeHDAccessText:\n            \"Access your masternodes if you have any! If you don't you can create one\",\n        // Aggregate menu screens and links for faster switching\n        arrDomScreens: document.getElementsByClassName('tabcontent'),\n        arrDomScreenLinks: document.getElementsByClassName('tablinks'),\n        // Alert DOM element\n        domAlertPos: document.getElementsByClassName('alertPositioning')[0],\n        domNetwork: document.getElementById('Network'),\n        domDebug: document.getElementById('Debug'),\n        domTestnet: document.getElementById('Testnet'),\n        domCurrencySelect: document.getElementById('currency'),\n        domExplorerSelect: document.getElementById('explorer'),\n        domNodeSelect: document.getElementById('node'),\n        domAutoSwitchToggle: document.getElementById('autoSwitchToggler'),\n        domTranslationSelect: document.getElementById('translation'),\n        domBlackBack: document.getElementById('blackBack'),\n        domWalletSettings: document.getElementById('settingsWallet'),\n        domDisplaySettings: document.getElementById('settingsDisplay'),\n        domWalletSettingsBtn: document.getElementById('settingsWalletBtn'),\n        domDisplaySettingsBtn: document.getElementById('settingsDisplayBtn'),\n        domVersion: document.getElementById('version'),\n        domFlipdown: document.getElementById('flipdown'),\n        domTestnetToggler: document.getElementById('testnetToggler'),\n    };\n    await i18nStart();\n    await loadImages();\n\n    // Enable all Bootstrap Tooltips\n    $(function () {\n        $('[data-toggle=\"tooltip\"]').tooltip();\n    });\n\n    // Register Input Pair events\n    doms.domSendAmountCoins.oninput = () => {\n        updateAmountInputPair(\n            doms.domSendAmountCoins,\n            doms.domSendAmountValue,\n            true\n        );\n    };\n    doms.domSendAmountValue.oninput = () => {\n        updateAmountInputPair(\n            doms.domSendAmountCoins,\n            doms.domSendAmountValue,\n            false\n        );\n    };\n\n    /** Staking (Stake) */\n    doms.domStakeAmount.oninput = () => {\n        updateAmountInputPair(\n            doms.domStakeAmount,\n            doms.domStakeAmountValue,\n            true\n        );\n    };\n    doms.domStakeAmountValue.oninput = () => {\n        updateAmountInputPair(\n            doms.domStakeAmount,\n            doms.domStakeAmountValue,\n            false\n        );\n    };\n\n    /** Staking (Unstake) */\n    doms.domUnstakeAmount.oninput = () => {\n        updateAmountInputPair(\n            doms.domUnstakeAmount,\n            doms.domUnstakeAmountValue,\n            true\n        );\n    };\n    doms.domUnstakeAmountValue.oninput = () => {\n        updateAmountInputPair(\n            doms.domUnstakeAmount,\n            doms.domUnstakeAmountValue,\n            false\n        );\n    };\n\n    // Register native app service\n    registerWorker();\n\n    // Configure Identicon\n    jdenticon.configure();\n\n    // URL-Query request processing\n    const urlParams = new URLSearchParams(window.location.search);\n\n    // Check for a payment request address\n    const reqTo = urlParams.has('pay') ? urlParams.get('pay') : '';\n\n    // Check for a payment request amount\n    const reqAmount = urlParams.has('amount')\n        ? parseFloat(urlParams.get('amount'))\n        : 0;\n    await settingsStart();\n\n    // Customise the UI if a saved wallet exists\n    if (await hasEncryptedWallet()) {\n        // Hide the 'Generate wallet' buttons\n        doms.domGenerateWallet.style.display = 'none';\n        doms.domGenVanityWallet.style.display = 'none';\n        const database = await Database.getInstance();\n        const { publicKey } = await database.getAccount();\n\n        // Import the wallet, and toggle the startup flag, which delegates the chain data refresh to settingsStart();\n        if (publicKey) {\n            await importWallet({ newWif: publicKey, fStartup: true });\n\n            // Payment processor popup\n            if (reqTo.length || reqAmount > 0) {\n                guiPreparePayment(\n                    reqTo,\n                    reqAmount,\n                    urlParams.has('desc') ? urlParams.get('desc') : ''\n                );\n            }\n        } else {\n            // Display the password unlock upfront\n            await accessOrImportWallet();\n        }\n    } else {\n        // Just load the block count, for use in non-wallet areas\n        getNetwork().getBlockCount();\n    }\n\n    subscribeToNetworkEvents();\n\n    doms.domPrefix.value = '';\n    doms.domPrefixNetwork.innerText =\n        cChainParams.current.PUBKEY_PREFIX.join(' or ');\n    // If allowed by settings: submit a simple 'hit' (app load) to Labs Analytics\n    getNetwork().submitAnalytics('hit');\n    setInterval(() => {\n        // Refresh blockchain data\n        refreshChainData();\n\n        // Fetch the PIVX prices\n        refreshPriceDisplay();\n    }, 15000);\n\n    // After reaching here; we know MPW's base is fully loaded!\n    fIsLoaded = true;\n\n    // Check for recent upgrades, display the changelog\n    checkForUpgrades();\n\n    // If we haven't already (due to having no wallet, etc), display the Dashboard\n    doms.domDashboard.click();\n}\n\nfunction subscribeToNetworkEvents() {\n    getEventEmitter().on('network-toggle', (value) => {\n        doms.domNetwork.innerHTML =\n            '<i class=\"fa-solid fa-' + (value ? 'wifi' : 'ban') + '\"></i>';\n    });\n\n    getEventEmitter().on('sync-status', (value) => {\n        switch (value) {\n            case 'start':\n                // Play reload anim\n                doms.domBalanceReload.classList.add('playAnim');\n                doms.domBalanceReloadStaking.classList.add('playAnim');\n                break;\n            case 'stop':\n                doms.domBalanceReload.classList.remove('playAnim');\n                doms.domBalanceReloadStaking.classList.remove('playAnim');\n                break;\n        }\n    });\n\n    getEventEmitter().on('transaction-sent', (success, result) => {\n        if (success) {\n            doms.domAddress1s.value = '';\n            doms.domSendAmountCoins.innerHTML = '';\n            createAlert(\n                'success',\n                `Transaction sent!<br>${sanitizeHTML(result)}`,\n                result ? 1250 + result.length * 50 : 3000\n            );\n            // If allowed by settings: submit a simple 'tx' ping to Labs Analytics\n            getNetwork().submitAnalytics('transaction');\n        } else {\n            console.error('Error sending transaction:');\n            console.error(result);\n            createAlert('warning', 'Transaction Failed!', 2500);\n        }\n    });\n}\n\n// WALLET STATE DATA\nexport const mempool = new Mempool();\nlet exportHidden = false;\nlet isTestnetLastState = cChainParams.current.isTestnet;\n\n/**\n * @type {FlipDown | null}\n */\nlet governanceFlipdown = null;\n\n/**\n * Open a UI 'tab' menu, and close all other tabs, intended for frontend use\n * @param {Event} evt - The click event target\n * @param {string} tabName - The name of the tab to load\n */\nexport function openTab(evt, tabName) {\n    // Only allow switching tabs if MPw is loaded\n    if (!isLoaded()) return;\n\n    // Hide all screens and deactivate link highlights\n    for (const domScreen of doms.arrDomScreens)\n        domScreen.style.display = 'none';\n    for (const domLink of doms.arrDomScreenLinks)\n        domLink.classList.remove('active');\n\n    // Show and activate the given screen\n    document.getElementById(tabName).style.display = 'block';\n    evt.currentTarget.classList.add('active');\n\n    // Close the navbar if it's not already closed\n    if (!doms.domNavbarToggler.className.includes('collapsed'))\n        doms.domNavbarToggler.click();\n\n    if (tabName === 'Governance') {\n        updateGovernanceTab();\n    } else if (tabName === 'Masternode') {\n        updateMasternodeTab();\n    } else if (\n        tabName === 'StakingTab' &&\n        getNetwork().arrTxHistory.length === 0\n    ) {\n        // Refresh the TX list\n        updateActivityGUI(true, false);\n    } else if (\n        tabName === 'keypair' &&\n        getNetwork().arrTxHistory.length === 0\n    ) {\n        // Refresh the TX list\n        updateActivityGUI(false, false);\n    }\n}\n\n/**\n * Updates the GUI ticker among all elements; useful for Network Switching\n */\nexport function updateTicker() {\n    // Update the Dashboard currency\n    doms.domGuiBalanceValueCurrency.innerText = strCurrency.toUpperCase();\n\n    // Update the Send menu ticker and currency\n    doms.domSendAmountValueCurrency.innerText = strCurrency.toUpperCase();\n    doms.domSendAmountCoinsTicker.innerText = cChainParams.current.TICKER;\n\n    // Update the Stake/Unstake menu ticker and currency\n    // Stake\n    doms.domStakeAmountValueCurrency.innerText = strCurrency.toUpperCase();\n    doms.domStakeAmountCoinsTicker.innerText = cChainParams.current.TICKER;\n\n    // Unstake\n    doms.domStakeAmountValueCurrency.innerText = strCurrency.toUpperCase();\n    doms.domUnstakeAmountCoinsTicker.innerText = cChainParams.current.TICKER;\n}\n\n/**\n * Return locale settings best for displaying the user-selected currency\n * @param {Number} nAmount - The amount in Currency\n */\nexport function optimiseCurrencyLocale(nAmount) {\n    // Allow manipulating the value, if necessary\n    let nValue = nAmount;\n\n    // Find the best fitting native-locale\n    const cLocale = Intl.supportedValuesOf('currency').includes(\n        strCurrency.toUpperCase()\n    )\n        ? {\n              style: 'currency',\n              currency: strCurrency,\n              currencyDisplay: 'narrowSymbol',\n          }\n        : { maximumFractionDigits: 8, minimumFractionDigits: 8 };\n\n    // Catch display edge-cases; like Satoshis having decimals.\n    switch (strCurrency) {\n        case 'sats':\n            nValue = Math.round(nValue);\n            cLocale.maximumFractionDigits = 0;\n            cLocale.minimumFractionDigits = 0;\n    }\n\n    // Return display-optimised Value and Locale pair.\n    return { nValue, cLocale };\n}\n\n/**\n * Update a 'price value' DOM display for the given balance type\n * @param {HTMLElement} domValue\n * @param {boolean} fCold\n */\nexport function updatePriceDisplay(domValue, fCold = false) {\n    // Update currency values\n    cMarket.getPrice(strCurrency).then((nPrice) => {\n        // Calculate the value\n        const nCurrencyValue =\n            ((fCold ? getStakingBalance() : getBalance()) / COIN) * nPrice;\n\n        const { nValue, cLocale } = optimiseCurrencyLocale(nCurrencyValue);\n\n        // Update the DOM\n        domValue.innerText = nValue.toLocaleString('en-gb', cLocale);\n    });\n}\n\nexport function getBalance(updateGUI = false) {\n    const nBalance = mempool.getBalance();\n    const nCoins = nBalance / COIN;\n\n    // Update the GUI too, if chosen\n    if (updateGUI) {\n        // Set the balance, and adjust font-size for large balance strings\n        const nLen = nCoins.toFixed(2).length;\n        doms.domGuiBalance.innerText = nCoins.toFixed(nLen >= 6 ? 0 : 2);\n        doms.domAvailToDelegate.innerText =\n            nCoins.toFixed(2) + ' ' + cChainParams.current.TICKER;\n\n        // Update tickers\n        updateTicker();\n\n        // Update price displays\n        updatePriceDisplay(doms.domGuiBalanceValue);\n    }\n\n    return nBalance;\n}\n\nexport function getStakingBalance(updateGUI = false) {\n    const nBalance = mempool.getDelegatedBalance();\n\n    if (updateGUI) {\n        // Set the balance, and adjust font-size for large balance strings\n        doms.domGuiBalanceStaking.innerText = Math.floor(nBalance / COIN);\n        doms.domAvailToUndelegate.innerText =\n            (nBalance / COIN).toFixed(2) + ' ' + cChainParams.current.TICKER;\n\n        // Update tickers\n        updateTicker();\n\n        // Update price displays\n        updatePriceDisplay(doms.domGuiStakingValue, true);\n    }\n\n    return nBalance;\n}\n\n/**\n * Fill a 'Coin Amount' with all of a balance type, and update the 'Coin Value'\n * @param {HTMLInputElement} domCoin - The 'Coin Amount' input element\n * @param {HTMLInputElement} domValue - Th 'Coin Value' input element\n * @param {boolean} fCold - Use the Cold Staking balance, or Available balance\n */\nexport function selectMaxBalance(domCoin, domValue, fCold = false) {\n    domCoin.value = (fCold ? getStakingBalance() : getBalance()) / COIN;\n    // Update the Send menu's value (assumption: if it's not a Cold balance, it's probably for Sending!)\n    updateAmountInputPair(domCoin, domValue, true);\n}\n\n/**\n * Prompt a QR scan for a Payment (Address or BIP21)\n */\nexport async function openSendQRScanner() {\n    const cScan = await scanQRCode();\n\n    if (!cScan || !cScan.data) return;\n\n    /* Check what data the scan contains - for the various QR request types */\n\n    // Plain address (Length and prefix matches)\n    if (\n        cScan.data.length === 34 &&\n        cChainParams.current.PUBKEY_PREFIX.includes(cScan.data[0])\n    ) {\n        return guiPreparePayment(cScan.data);\n    }\n\n    // Shield address (Valid bech32 string)\n    if (isValidBech32(cScan.data).valid) {\n        return guiPreparePayment(cScan.data);\n    }\n\n    // BIP21 Payment Request (Optional 'amount' and 'label')\n    const cBIP21Req = parseBIP21Request(cScan.data);\n    if (cBIP21Req) {\n        return guiPreparePayment(\n            cBIP21Req.address,\n            cBIP21Req.options.amount || 0,\n            cBIP21Req.options.label || ''\n        );\n    }\n\n    // No idea what this is...\n    createAlert(\n        'warning',\n        `\"${sanitizeHTML(\n            cScan.data.substring(0, Math.min(cScan.data.length, 6))\n        )}\" is not a valid payment receiver`,\n        [],\n        7500\n    );\n}\n\n/**\n * Generate a DOM-optimised activity list\n * @param {Array<import('./network.js').HistoricalTx>} arrTXs - The TX array to compute the list from\n * @param {boolean} fRewards - If this list is for Reward transactions\n * @returns {Promise<string>} HTML - The Activity List in HTML string form\n */\nexport async function createActivityListHTML(arrTXs, fRewards = false) {\n    const cNet = getNetwork();\n\n    // Prepare the table HTML\n    let strList = `\n    <table class=\"table table-responsive table-sm stakingTx table-mobile-scroll\">\n        <thead>\n            <tr>\n                <th scope=\"col\" class=\"tx1\">Time</th>\n                <th scope=\"col\" class=\"tx2\">${\n                    fRewards ? 'ID' : 'Description'\n                }</th>\n                <th scope=\"col\" class=\"tx3\">Amount</th>\n                <th scope=\"col\" class=\"tx4 text-right\"></th>\n            </tr>\n        </thead>\n        <tbody>`;\n\n    // Prepare time formatting\n    const dateOptions = {\n        year: '2-digit',\n        month: '2-digit',\n        day: '2-digit',\n    };\n    const timeOptions = {\n        hour: '2-digit',\n        minute: '2-digit',\n        hour12: true,\n    };\n\n    // And also keep track of our last Tx's timestamp, to re-use a cache, which is much faster than the slow `.toLocaleDateString`\n    let prevDateString = '';\n    let prevTimestamp = 0;\n\n    // Generate the TX list\n    for (const cTx of arrTXs) {\n        const dateTime = new Date(cTx.time * 1000);\n\n        // If this Tx is older than 24h, then hit the `Date` cache logic, otherwise, use a `Time` and skip it\n        let strDate =\n            Date.now() / 1000 - cTx.time > 86400\n                ? ''\n                : dateTime.toLocaleTimeString(undefined, timeOptions);\n        if (!strDate) {\n            if (\n                prevDateString &&\n                prevTimestamp - cTx.time * 1000 < 12 * 60 * 60 * 1000\n            ) {\n                // Use our date cache\n                strDate = prevDateString;\n            } else {\n                // Create a new date, this Tx is too old to use the cache\n                prevDateString = dateTime.toLocaleDateString(\n                    undefined,\n                    dateOptions\n                );\n                strDate = prevDateString;\n            }\n        }\n\n        // Update the time cache\n        prevTimestamp = cTx.time * 1000;\n\n        // Coinbase Transactions (rewards) require 100 confs\n        const fConfirmed =\n            cNet.cachedBlockCount - cTx.blockHeight >= fRewards ? 100 : 6;\n\n        // Choose the correct icon and colour for the Tx type, or a question mark if the type is unknown\n        // Defaults: Reward Activity\n        let icon = 'fa-gift';\n        let colour = 'white';\n\n        // Choose the content type, for the Dashboard; use a generative description, otherwise, a TX-ID\n        let txContent = fRewards ? cTx.id : 'Block Reward';\n\n        // Format the amount to reduce text size\n        let formattedAmt = '';\n        if (cTx.amount < 0.01) {\n            formattedAmt = '<0.01';\n        } else if (cTx.amount >= 100) {\n            formattedAmt = Math.round(cTx.amount).toString();\n        } else {\n            formattedAmt = cTx.amount.toFixed(2);\n        }\n\n        // For 'Send' or 'Receive' TXs: Check if this is a send-to-self transaction\n        let fSendToSelf = true;\n        if (\n            cTx.type === HistoricalTxType.SENT ||\n            cTx.type === HistoricalTxType.RECEIVED\n        ) {\n            // Check all addresses to find our own, caching them for performance\n            for (const strAddr of cTx.receivers.concat(cTx.senders)) {\n                // If a previous Tx checked this address, skip it, otherwise, check it against our own address(es)\n                if (!(await masterKey.isOwnAddress(strAddr))) {\n                    // External address, this is not a self-only Tx\n                    fSendToSelf = false;\n                }\n            }\n        }\n\n        // Generate an icon, colour and description for the Tx\n        if (!fRewards) {\n            switch (cTx.type) {\n                case HistoricalTxType.STAKE:\n                    icon = 'fa-gift';\n                    break;\n                case HistoricalTxType.SENT:\n                    icon = 'fa-minus';\n                    colour = '#f93c3c';\n                    // Figure out WHO this was sent to, and focus on them contextually\n                    if (fSendToSelf) {\n                        txContent = 'Sent to self';\n                    } else {\n                        // Otherwise, anything to us is likely change, so filter it away\n                        const arrExternalAddresses = (\n                            await Promise.all(\n                                cTx.receivers.map(async (addr) => [\n                                    await masterKey.isOwnAddress(addr),\n                                    addr,\n                                ])\n                            )\n                        )\n                            .filter(([isOwnAddress, _]) => {\n                                return !isOwnAddress;\n                            })\n                            .map(([_, addr]) => addr);\n                        txContent =\n                            'Sent to ' +\n                            (cTx.shieldedOutputs\n                                ? 'Shielded address'\n                                : [\n                                      ...new Set(\n                                          arrExternalAddresses.map((addr) =>\n                                              addr.length >= 32\n                                                  ? addr.substring(0, 6)\n                                                  : addr\n                                          )\n                                      ),\n                                  ].join(', ') + '...');\n                    }\n                    break;\n                case HistoricalTxType.RECEIVED: {\n                    icon = 'fa-plus';\n                    colour = '#5cff5c';\n                    // Figure out WHO this was sent from, and focus on them contextually\n                    // Filter away any of our own addresses\n                    const arrExternalAddresses = (\n                        await Promise.all(\n                            cTx.senders.map(async (addr) => [\n                                await masterKey.isOwnAddress(addr),\n                                addr,\n                            ])\n                        )\n                    )\n                        .filter(([isOwnAddress, _]) => {\n                            return !isOwnAddress;\n                        })\n                        .map(([_, addr]) => addr);\n\n                    if (cTx.shieldedOutputs) {\n                        txContent = 'Received from Shielded address';\n                    } else {\n                        txContent =\n                            'Received from ' +\n                            [\n                                ...new Set(\n                                    arrExternalAddresses.map((addr) =>\n                                        addr?.length >= 32\n                                            ? addr.substring(0, 6)\n                                            : addr\n                                    )\n                                ),\n                            ].join(', ') +\n                            '...';\n                    }\n                    break;\n                }\n                case HistoricalTxType.DELEGATION:\n                    icon = 'fa-snowflake';\n                    txContent =\n                        'Delegated to ' +\n                        cTx.receivers[0].substring(0, 6) +\n                        '...';\n                    break;\n                case HistoricalTxType.UNDELEGATION:\n                    icon = 'fa-fire';\n                    txContent = 'Undelegated';\n                    break;\n                default:\n                    icon = 'fa-question';\n                    txContent = 'Unknown Tx';\n            }\n        }\n\n        // Render the list element from Tx data\n        strList += `\n            <tr>\n                <td class=\"align-middle pr-10px\" style=\"font-size:12px;\">\n                    <i style=\"opacity: 0.75;\">${strDate}</i>\n                </td>\n                <td class=\"align-middle pr-10px txcode\">\n                    <a href=\"${cExplorer.url}/tx/${sanitizeHTML(\n            cTx.id\n        )}\" target=\"_blank\" rel=\"noopener noreferrer\">\n                        <code class=\"wallet-code text-center active ptr\" style=\"padding: 4px 9px;\">${sanitizeHTML(\n                            txContent\n                        )}</code>\n                    </a>\n                </td>\n                <td class=\"align-middle pr-10px\">\n                    <b style=\"font-family: monospace;\"><i class=\"fa-solid ${icon}\" style=\"color: ${colour}; padding-right: 3px;\"></i> ${formattedAmt} ${\n            cChainParams.current.TICKER\n        }</b>\n                </td>\n                <td class=\"text-right pr-10px align-middle\">\n                    <span class=\"badge ${\n                        fConfirmed ? 'badge-purple' : 'bg-danger'\n                    } mb-0\">${\n            fConfirmed\n                ? '<i class=\"fas fa-check\"></i>'\n                : `<i class=\"fas fa-hourglass-end\"></i>`\n        }</span>\n                </td>\n            </tr>`;\n    }\n\n    // End the table\n    strList += `</tbody></table>`;\n\n    // Return the HTML string\n    return strList;\n}\n\n/**\n * Refreshes the specified activity table, charts and related information\n */\nexport async function updateActivityGUI(fStaking = false, fNewOnly = false) {\n    const cNet = getNetwork();\n\n    // Prevent the user from spamming refreshes\n    if (cNet.historySyncing) return;\n\n    // Remember how much history we had previously\n    const nPrevHistory = cNet.arrTxHistory.length;\n\n    // Choose the Dashboard or Staking UI accordingly\n    let domLoadMore = doms.domActivityLoadMore;\n    let domLoadMoreIcon = doms.domActivityLoadMoreIcon;\n    if (fStaking) {\n        domLoadMore = doms.domGuiStakingLoadMore;\n        domLoadMoreIcon = doms.domGuiStakingLoadMoreIcon;\n    }\n\n    // Load rewards from the network, displaying the sync spin icon until finished\n    domLoadMoreIcon.classList.add('fa-spin');\n    const arrTXs = await cNet.syncTxHistoryChunk(fNewOnly);\n    domLoadMoreIcon.classList.remove('fa-spin');\n\n    // If there's no change in history size post-sync, then we can cancel here, there's nothing new to render\n    if (nPrevHistory === cNet.arrTxHistory.length) return;\n\n    // Check if all transactions are loaded\n    if (cNet.isHistorySynced) {\n        // Hide the load more button\n        domLoadMore.style.display = 'none';\n    }\n\n    // For Staking: Filter the list for only Stakes, display total rewards from known history\n    const arrStakes = arrTXs.filter((a) => a.type === HistoricalTxType.STAKE);\n    const nRewards = arrStakes.reduce((a, b) => a + b.amount, 0);\n    doms.domStakingRewardsTitle.innerHTML = `${\n        cNet.isHistorySynced ? '' : ''\n    }${sanitizeHTML(nRewards)} ${cChainParams.current.TICKER}`;\n\n    // Create and render the Dashboard Activity\n    doms.domActivityList.innerHTML = await createActivityListHTML(\n        arrTXs,\n        false\n    );\n    // Create and render the Staking History\n    doms.domStakingRewardsList.innerHTML = await createActivityListHTML(\n        arrStakes,\n        true\n    );\n}\n\n/**\n * Open the Explorer in a new tab for the loaded master public key\n */\nexport async function openExplorer() {\n    if (masterKey.isHD) {\n        const derivationPath = getDerivationPath(masterKey.isHardwareWallet)\n            .split('/')\n            .slice(0, 4)\n            .join('/');\n        const xpub = await masterKey.getxpub(derivationPath);\n        window.open(cExplorer.url + '/xpub/' + xpub, '_blank');\n    } else {\n        const address = await masterKey.getAddress();\n        window.open(cExplorer.url + '/address/' + address, '_blank');\n    }\n}\n\nasync function loadImages() {\n    const images = [\n        ['mpw-main-logo', import('../assets/logo.png')],\n        ['privateKeyImage', import('../assets/key.png')],\n    ];\n\n    const promises = images.map(([id, path]) =>\n        (async () => {\n            document.getElementById(id).src = (await path).default;\n        })()\n    );\n    await Promise.all(promises);\n}\n\nlet audio = null;\nexport async function playMusic() {\n    // On first play: load the audio into memory from the host\n    if (audio === null) {\n        // Dynamically load the file\n        audio = new Audio((await import('../assets/music.mp3')).default);\n    }\n\n    // Play or Pause\n    if (audio.paused || audio.ended) {\n        audio.play();\n        for (const domImg of document.getElementsByTagName('img'))\n            domImg.classList.add('discoFilter');\n    } else {\n        audio.pause();\n        for (const domImg of document.getElementsByTagName('img'))\n            domImg.classList.remove('discoFilter');\n    }\n}\n\nexport function unblurPrivKey() {\n    if (\n        document\n            .getElementById('exportPrivateKeyText')\n            .classList.contains('blurred')\n    ) {\n        document\n            .getElementById('exportPrivateKeyText')\n            .classList.remove('blurred');\n    } else {\n        document\n            .getElementById('exportPrivateKeyText')\n            .classList.add('blurred');\n    }\n}\n\nexport function toggleBottomMenu(dom, ani) {\n    let element = document.getElementById(dom);\n    if (element.classList.contains(ani)) {\n        element.classList.remove(ani);\n        doms.domBlackBack.classList.remove('d-none');\n        setTimeout(() => {\n            doms.domBlackBack.classList.remove('blackBackHide');\n        }, 10);\n    } else {\n        element.classList.add(ani);\n        doms.domBlackBack.classList.add('blackBackHide');\n        setTimeout(() => {\n            doms.domBlackBack.classList.add('d-none');\n        }, 150);\n    }\n}\n\n/**\n * Updates an Amount Input UI pair ('Coin' and 'Value' input boxes) in relation to the input box used\n * @param {HTMLInputElement} domCoin - The DOM input for the Coin amount\n * @param {HTMLInputElement} domValue - The DOM input for the Value amount\n * @param {boolean} fCoinEdited - `true` if Coin, `false` if Value\n */\nexport async function updateAmountInputPair(domCoin, domValue, fCoinEdited) {\n    // Fetch the price in the user's preferred currency\n    const nPrice = await cMarket.getPrice(strCurrency);\n    if (fCoinEdited) {\n        // If the 'Coin' input is edited, then update the 'Value' input with it's converted currency\n        const nValue = Number(domCoin.value) * nPrice;\n        domValue.value = nValue <= 0 ? '' : nValue;\n    } else {\n        // If the 'Value' input is edited, then update the 'Coin' input with the reversed conversion rate\n        const nValue = Number(domValue.value) / nPrice;\n        domCoin.value = nValue <= 0 ? '' : nValue;\n    }\n}\n\nexport function toClipboard(source, caller) {\n    // Fetch the text/value source\n    const domCopy = document.getElementById(source) || source;\n\n    // Use an invisible textbox as the clipboard source\n    const domClipboard = document.getElementById('clipboard');\n    domClipboard.value = domCopy.value || domCopy.innerHTML || domCopy;\n    domClipboard.select();\n    domClipboard.setSelectionRange(0, 99999);\n\n    // Browser-dependent clipboard execution\n    if (!navigator.clipboard) {\n        document.execCommand('copy');\n    } else {\n        navigator.clipboard.writeText(domCopy.innerHTML || domCopy);\n    }\n\n    // Display a temporary checkmark response\n    caller.classList.add('fa-check');\n    caller.classList.remove('fa-clipboard');\n    caller.style.cursor = 'default';\n    setTimeout(() => {\n        caller.classList.add('fa-clipboard');\n        caller.classList.remove('fa-check');\n        caller.style.cursor = 'pointer';\n    }, 1000);\n}\n\n/**\n * Prompt for a payment in the GUI with pre-filled inputs\n * @param {string} strTo - The address receiving the payment\n * @param {number} nAmount - The payment amount in full coins\n * @param {string} strDesc - The payment message or description\n */\nexport function guiPreparePayment(strTo = '', nAmount = 0, strDesc = '') {\n    // Apply values\n    doms.domAddress1s.value = strTo;\n    doms.domSendAmountCoins.value = nAmount;\n    doms.domReqDesc.value = strDesc;\n    doms.domReqDisplay.style.display = strDesc ? 'block' : 'none';\n\n    // Switch to the Dashboard\n    doms.domDashboard.click();\n\n    // Open the Send menu, if not already open (with a small timeout post-load to allow for CSS loading)\n    if (\n        document\n            .getElementById('transferMenu')\n            .classList.contains('transferAnimation')\n    ) {\n        setTimeout(() => {\n            toggleBottomMenu('transferMenu', 'transferAnimation');\n        }, 300);\n    }\n\n    // Update the conversion value\n    updateAmountInputPair(\n        doms.domSendAmountCoins,\n        doms.domSendAmountValue,\n        true\n    );\n\n    // Focus on the coin input box (if no pre-fill was specified)\n    if (nAmount <= 0) {\n        doms.domSendAmountCoins.focus();\n    }\n}\n\nexport function hideAllWalletOptions() {\n    // Hide and Reset the Vanity address input\n    doms.domPrefix.value = '';\n    doms.domPrefix.style.display = 'none';\n\n    // Hide all \"*Wallet\" buttons\n    doms.domGenerateWallet.style.display = 'none';\n    doms.domImportWallet.style.display = 'none';\n    doms.domGenVanityWallet.style.display = 'none';\n    doms.domAccessWallet.style.display = 'none';\n    doms.domGenHardwareWallet.style.display = 'none';\n}\n\nexport async function govVote(hash, voteCode) {\n    if (\n        (await confirmPopup({\n            title: ALERTS.CONFIRM_POPUP_VOTE,\n            html: ALERTS.CONFIRM_POPUP_VOTE_HTML,\n        })) == true\n    ) {\n        const database = await Database.getInstance();\n        const cMasternode = await database.getMasternode();\n        if (cMasternode) {\n            if ((await cMasternode.getStatus()) !== 'ENABLED') {\n                createAlert(\n                    'warning',\n                    'Your masternode is not enabled yet!',\n                    6000\n                );\n                return;\n            }\n            const result = await cMasternode.vote(hash.toString(), voteCode); //1 yes 2 no\n            if (result.includes('Voted successfully')) {\n                //good vote\n                cMasternode.storeVote(hash.toString(), voteCode);\n                await updateGovernanceTab();\n                createAlert('success', 'Vote submitted!', 6000);\n            } else if (result.includes('Error voting :')) {\n                //If you already voted return an alert\n                createAlert(\n                    'warning',\n                    'You already voted for this proposal! Please wait 1 hour',\n                    6000\n                );\n            } else if (result.includes('Failure to verify signature.')) {\n                //wrong masternode private key\n                createAlert(\n                    'warning',\n                    \"Failed to verify signature, please check your masternode's private key\",\n                    6000\n                );\n            } else {\n                //this could be everything\n                console.error(result);\n                createAlert(\n                    'warning',\n                    'Internal error, please try again later',\n                    6000\n                );\n            }\n        } else {\n            createAlert('warning', 'Access a masternode before voting!', 6000);\n        }\n    }\n}\n\n/**\n * Start a Masternode via a signed network broadcast\n * @param {boolean} fRestart - Whether this is a Restart or a first Start\n */\nexport async function startMasternode(fRestart = false) {\n    const database = await Database.getInstance();\n    const cMasternode = await database.getMasternode(masterKey);\n    if (cMasternode) {\n        if (\n            masterKey.isViewOnly &&\n            !(await restoreWallet('Unlock to start your Masternode!'))\n        )\n            return;\n        if (await cMasternode.start()) {\n            createAlert(\n                'success',\n                '<b>Masternode ' + (fRestart ? 're' : '') + 'started!</b>',\n                4000\n            );\n        } else {\n            createAlert(\n                'warning',\n                '<b>Failed to ' +\n                    (fRestart ? 're' : '') +\n                    'start masternode!</b>',\n                4000\n            );\n        }\n    }\n}\n\nexport async function destroyMasternode() {\n    const database = await Database.getInstance();\n\n    if (await database.getMasternode(masterKey)) {\n        database.removeMasternode(masterKey);\n        createAlert(\n            'success',\n            '<b>Masternode destroyed!</b><br>Your coins are now spendable.',\n            5000\n        );\n        updateMasternodeTab();\n    }\n}\n\n/**\n * Takes an ip address and adds the port.\n * If it's a tor address, ip.onion:port will be used (e.g. expyuzz4wqqyqhjn.onion:12345)\n * If it's an IPv4 address, ip:port will be used, (e.g. 127.0.0.1:12345)\n * If it's an IPv6 address, [ip]:port will be used, (e.g. [::1]:12345)\n * @param {String} ip - Ip address with or without port\n * @returns {String}\n */\nfunction parseIpAddress(ip) {\n    // IPv4 or tor without port\n    if (ip.match(/\\d+\\.\\d+\\.\\d+\\.\\d+/) || ip.match(/\\w+\\.onion/)) {\n        return `${ip}:${cChainParams.current.MASTERNODE_PORT}`;\n    }\n\n    // IPv4 or tor with port\n    if (ip.match(/\\d+\\.\\d+\\.\\d+\\.\\d+:\\d+/) || ip.match(/\\w+\\.onion:\\d+/)) {\n        return ip;\n    }\n\n    // IPv6 without port\n    if (Address6.isValid(ip)) {\n        return `[${ip}]:${cChainParams.current.MASTERNODE_PORT}`;\n    }\n\n    const groups = /\\[(.*)\\]:\\d+/.exec(ip);\n    if (groups !== null && groups.length > 1) {\n        // IPv6 with port\n        if (Address6.isValid(groups[1])) {\n            return ip;\n        }\n    }\n\n    // If we haven't returned yet, the address was invalid.\n    return null;\n}\n\nexport async function importMasternode() {\n    const mnPrivKey = doms.domMnPrivateKey.value;\n    const address = parseIpAddress(doms.domMnIP.value);\n    if (!address) {\n        createAlert('warning', 'The ip address is invalid!', 5000);\n        return;\n    }\n\n    let collateralTxId;\n    let outidx;\n    let collateralPrivKeyPath;\n    doms.domMnIP.value = '';\n    doms.domMnPrivateKey.value = '';\n\n    if (!masterKey.isHD) {\n        // Find the first UTXO matching the expected collateral size\n        const cCollaUTXO = mempool\n            .getConfirmed()\n            .find(\n                (cUTXO) => cUTXO.sats === cChainParams.current.collateralInSats\n            );\n\n        // If there's no valid UTXO, exit with a contextual message\n        if (!cCollaUTXO) {\n            if (getBalance(false) < cChainParams.current.collateralInSats) {\n                // Not enough balance to create an MN UTXO\n                createAlert(\n                    'warning',\n                    'You need <b>' +\n                        (cChainParams.current.collateralInSats -\n                            getBalance(false)) /\n                            COIN +\n                        ' more ' +\n                        cChainParams.current.TICKER +\n                        '</b> to create a Masternode!',\n                    10000\n                );\n            } else {\n                // Balance is capable of a masternode, just needs to be created\n                // TODO: this UX flow is weird, is it even possible? perhaps we can re-design this entire function accordingly\n                createAlert(\n                    'warning',\n                    'You have enough balance for a Masternode, but no valid collateral UTXO of ' +\n                        cChainParams.current.collateralInSats / COIN +\n                        ' ' +\n                        cChainParams.current.TICKER,\n                    10000\n                );\n            }\n            return;\n        }\n\n        collateralTxId = cCollaUTXO.id;\n        outidx = cCollaUTXO.vout;\n        collateralPrivKeyPath = 'legacy';\n    } else {\n        const path = doms.domMnTxId.value;\n        const masterUtxo = mempool\n            .getConfirmed()\n            .findLast((u) => u.path === path); // first UTXO for each address in HD\n        // sanity check:\n        if (masterUtxo.sats !== cChainParams.current.collateralInSats) {\n            return createAlert(\n                'warning',\n                'This is not a suitable UTXO for a Masternode',\n                10000\n            );\n        }\n        collateralTxId = masterUtxo.id;\n        outidx = masterUtxo.vout;\n        collateralPrivKeyPath = path;\n    }\n    doms.domMnTxId.value = '';\n\n    const cMasternode = new Masternode({\n        walletPrivateKeyPath: collateralPrivKeyPath,\n        mnPrivateKey: mnPrivKey,\n        collateralTxId: collateralTxId,\n        outidx: outidx,\n        addr: address,\n    });\n    await refreshMasternodeData(cMasternode, true);\n    await updateMasternodeTab();\n}\n\nexport async function accessOrImportWallet() {\n    // Hide and Reset the Vanity address input\n    doms.domPrefix.value = '';\n    doms.domPrefix.style.display = 'none';\n\n    // Show Import button, hide access button\n    doms.domImportWallet.style.display = 'block';\n    setTimeout(() => {\n        doms.domPrivKey.style.opacity = '1';\n    }, 100);\n    doms.domAccessWalletBtn.style.display = 'none';\n\n    // If we have a local wallet, display the decryption prompt\n    // This is no longer being used, as the user will be put in view-only\n    // mode when logging in, however if the user locked the wallet before\n    // #52 there would be no way to recover the public key without getting\n    // The password from the user\n    if (await hasEncryptedWallet()) {\n        doms.domPrivKey.placeholder = 'Enter your wallet password';\n        doms.domImportWalletText.innerText = 'Unlock Wallet';\n        doms.domPrivKey.focus();\n    }\n}\n/**\n * An event function triggered apon private key UI input changes\n *\n * Useful for adjusting the input types or displaying password prompts depending on the import scheme\n */\nexport async function onPrivateKeyChanged() {\n    if (await hasEncryptedWallet()) return;\n    // Check whether the string is Base64 (would likely be an MPW-encrypted import)\n    // and it doesn't have any spaces (would be a mnemonic seed)\n    const fContainsSpaces = doms.domPrivKey.value.includes(' ');\n    doms.domPrivKeyPassword.hidden =\n        (doms.domPrivKey.value.length < 128 ||\n            !isBase64(doms.domPrivKey.value)) &&\n        !fContainsSpaces;\n\n    doms.domPrivKeyPassword.placeholder = fContainsSpaces\n        ? 'Optional Passphrase'\n        : 'Password';\n    // Uncloak the private input IF spaces are detected, to make Seed Phrases easier to input and verify\n    doms.domPrivKey.setAttribute('type', fContainsSpaces ? 'text' : 'password');\n}\n\n/**\n * Imports a wallet using the GUI input, handling decryption via UI\n */\nexport async function guiImportWallet() {\n    // Important: These fields will be wiped by importWallet();\n    const strPrivKey = doms.domPrivKey.value;\n    const strPassword = doms.domPrivKeyPassword.value;\n    const fEncrypted = strPrivKey.length >= 128 && isBase64(strPrivKey);\n\n    // If we are in testnet: prompt an import\n    if (cChainParams.current.isTestnet) return importWallet();\n\n    // If we don't have a DB wallet and the input is plain: prompt an import\n    if (!(await hasEncryptedWallet()) && !fEncrypted) return importWallet();\n\n    // If we don't have a DB wallet and the input is ciphered:\n    if (!(await hasEncryptedWallet()) && fEncrypted) {\n        const strDecWIF = await decrypt(strPrivKey, strPassword);\n        if (!strDecWIF || strDecWIF === 'decryption failed!') {\n            return createAlert('warning', ALERTS.FAILED_TO_IMPORT, [], 6000);\n        } else {\n            await importWallet({\n                newWif: strDecWIF,\n                // Save the public key to disk for future View Only mode post-decryption\n                fSavePublicKey: true,\n            });\n            const database = await Database.getInstance();\n            if (masterKey) {\n                database.addAccount({\n                    publicKey: await masterKey.keyToExport,\n                    encWif: strPrivKey,\n                });\n            }\n            // Destroy residue import data\n            doms.domPrivKey.value = '';\n            doms.domPrivKeyPassword.value = '';\n            return;\n        }\n    }\n    // Prompt for decryption of the existing wallet\n    const fHasWallet = await decryptWallet(doms.domPrivKey.value);\n\n    // If the wallet was successfully loaded, hide all options and load the dash!\n    if (fHasWallet) hideAllWalletOptions();\n}\n\nexport function guiEncryptWallet() {\n    // Disable wallet encryption in testnet mode\n    if (cChainParams.current.isTestnet)\n        return createAlert(\n            'warning',\n            ALERTS.TESTNET_ENCRYPTION_DISABLED,\n            [],\n            2500\n        );\n\n    // Fetch our inputs, ensure they're of decent entropy + match eachother\n    const strPass = doms.domEncryptPasswordFirst.value,\n        strPassRetype = doms.domEncryptPasswordSecond.value;\n    if (strPass.length < MIN_PASS_LENGTH)\n        return createAlert(\n            'warning',\n            ALERTS.PASSWORD_TOO_SMALL,\n            [{ MIN_PASS_LENGTH: MIN_PASS_LENGTH }],\n            4000\n        );\n    if (strPass !== strPassRetype)\n        return createAlert('warning', ALERTS.PASSWORD_DOESNT_MATCH, [], 2250);\n    encryptWallet(strPass);\n    createAlert('success', ALERTS.NEW_PASSWORD_SUCCESS, [], 5500);\n\n    $('#encryptWalletModal').modal('hide');\n    doms.domEncryptPasswordFirst.value = '';\n    doms.domEncryptPasswordSecond.value = '';\n\n    doms.domWipeWallet.hidden = false;\n}\n\nexport async function toggleExportUI() {\n    if (!exportHidden) {\n        if (await hasEncryptedWallet()) {\n            const { encWif } = await (\n                await Database.getInstance()\n            ).getAccount();\n            doms.domExportPrivateKey.innerHTML = encWif;\n            exportHidden = true;\n        } else {\n            if (masterKey.isViewOnly) {\n                exportHidden = false;\n            } else {\n                doms.domExportPrivateKey.innerHTML = masterKey.keyToBackup;\n                exportHidden = true;\n            }\n        }\n    } else {\n        doms.domExportPrivateKey.innerHTML = '';\n        exportHidden = false;\n    }\n}\n\nexport function checkVanity() {\n    var e = event || window.event; // get event object\n    var key = e.keyCode || e.which; // get key cross-browser\n    var char = String.fromCharCode(key).trim(); // convert key to char\n    if (char.length == 0) return;\n\n    // Ensure the input is base58 compatible\n    if (!MAP_B58.toLowerCase().includes(char.toLowerCase())) {\n        if (e.preventDefault) e.preventDefault();\n        e.returnValue = false;\n        return createAlert(\n            'warning',\n            ALERTS.UNSUPPORTED_CHARACTER,\n            [{ char: char }],\n            3500\n        );\n    }\n}\n\nlet isVanityGenerating = false;\nconst arrWorkers = [];\nlet vanUiUpdater;\n\nfunction stopSearch() {\n    isVanityGenerating = false;\n    for (let thread of arrWorkers) {\n        thread.terminate();\n    }\n    while (arrWorkers.length) arrWorkers.pop();\n    doms.domPrefix.disabled = false;\n    doms.domVanityUiButtonTxt.innerText = 'Create A Vanity Wallet';\n    clearInterval(vanUiUpdater);\n}\n\nexport async function generateVanityWallet() {\n    if (isVanityGenerating) return stopSearch();\n    if (typeof Worker === 'undefined')\n        return createAlert('error', ALERTS.UNSUPPORTED_WEBWORKERS, [], 7500);\n    // Generate a vanity address with the given prefix\n    if (\n        doms.domPrefix.value.length === 0 ||\n        doms.domPrefix.style.display === 'none'\n    ) {\n        // No prefix, display the intro!\n        doms.domPrefix.style.display = 'block';\n        setTimeout(() => {\n            doms.domPrefix.style.opacity = '1';\n        }, 100);\n        doms.domPrefix.focus();\n    } else {\n        // Remove spaces from prefix\n        doms.domPrefix.value = doms.domPrefix.value.replace(/ /g, '');\n\n        // Cache a lowercase equivilent for lower-entropy comparisons (a case-insensitive search is ALOT faster!) and strip accidental spaces\n        const nInsensitivePrefix = doms.domPrefix.value.toLowerCase();\n        const nPrefixLen = nInsensitivePrefix.length;\n\n        // Ensure the input is base58 compatible\n        for (const char of doms.domPrefix.value) {\n            if (!MAP_B58.toLowerCase().includes(char.toLowerCase()))\n                return createAlert(\n                    'warning',\n                    ALERTS.UNSUPPORTED_CHARACTER,\n                    [{ char: char }],\n                    3500\n                );\n            // We also don't want users to be mining addresses for years... so cap the letters to four until the generator is more optimized\n            if (doms.domPrefix.value.length > 5)\n                return createAlert(\n                    'warning',\n                    ALERTS.UNSUPPORTED_CHARACTER,\n                    [{ char: char }],\n                    3500\n                );\n        }\n        isVanityGenerating = true;\n        doms.domPrefix.disabled = true;\n        let attempts = 0;\n\n        // Setup workers\n        const nThreads = Math.max(\n            Math.floor(window.navigator.hardwareConcurrency * 0.75),\n            1\n        );\n        console.log('Spawning ' + nThreads + ' vanity search threads!');\n        while (arrWorkers.length < nThreads) {\n            arrWorkers.push(\n                new Worker(new URL('./vanitygen_worker.js', import.meta.url))\n            );\n            const checkResult = (data) => {\n                attempts++;\n                if (\n                    data.pub.substr(1, nPrefixLen).toLowerCase() ==\n                    nInsensitivePrefix\n                ) {\n                    importWallet({\n                        newWif: data.priv,\n                        fRaw: true,\n                    });\n                    stopSearch();\n                    doms.domGuiBalance.innerHTML = '0';\n                    return console.log(\n                        'VANITY: Found an address after ' +\n                            attempts +\n                            ' attempts!'\n                    );\n                }\n            };\n\n            arrWorkers[arrWorkers.length - 1].onmessage = (event) =>\n                checkResult(event.data);\n            arrWorkers[arrWorkers.length - 1].postMessage(\n                cChainParams.current.PUBKEY_ADDRESS\n            );\n        }\n\n        // GUI Updater\n        doms.domVanityUiButtonTxt.innerText =\n            'Stop (Searched ' + attempts.toLocaleString('en-GB') + ' keys)';\n        vanUiUpdater = setInterval(() => {\n            doms.domVanityUiButtonTxt.innerText =\n                'Stop (Searched ' + attempts.toLocaleString('en-GB') + ' keys)';\n        }, 200);\n    }\n}\n\n/**\n * Sweep an address to our own wallet, spending all it's UTXOs without change\n * @param {Array<object>} arrUTXOs - The UTXOs belonging to the address to sweep\n * @param {LegacyMasterKey} sweepingMasterKey - The address to sweep from\n * @param {number} nFixedFee - An optional fixed satoshi fee\n * @returns {Promise<string|false>} - TXID on success, false or error on failure\n */\nexport async function sweepAddress(arrUTXOs, sweepingMasterKey, nFixedFee = 0) {\n    const cTx = new bitjs.transaction();\n\n    // Load all UTXOs as inputs\n    let nTotal = 0;\n    for (const cUTXO of arrUTXOs) {\n        nTotal += cUTXO.sats;\n        cTx.addinput({\n            txid: cUTXO.id,\n            index: cUTXO.vout,\n            script: cUTXO.script,\n            path: cUTXO.path,\n        });\n    }\n\n    // Use a given fixed fee, or use the network fee if unspecified\n    const nFee = nFixedFee || getNetwork().getFee(cTx.serialize().length);\n\n    // Use a new address from our wallet to sweep the UTXOs in to\n    const strAddress = (await getNewAddress(true, false))[0];\n\n    // Sweep the full funds amount, minus the fee, leaving no change from any sweeped UTXOs\n    cTx.addoutput(strAddress, (nTotal - nFee) / COIN);\n\n    // Sign using the given Master Key, then broadcast the sweep, returning the TXID (or a failure)\n    const sign = await signTransaction(cTx, sweepingMasterKey);\n    return await getNetwork().sendTransaction(sign);\n}\n\nexport function toggleDropDown(id) {\n    const domID = document.getElementById(id);\n    domID.style.display = domID.style.display === 'block' ? 'none' : 'block';\n}\n\nexport function isMasternodeUTXO(cUTXO, cMasternode) {\n    if (cMasternode?.collateralTxId) {\n        const { collateralTxId, outidx } = cMasternode;\n        return collateralTxId === cUTXO.id && cUTXO.vout === outidx;\n    } else {\n        return false;\n    }\n}\n\n/**\n * Creates a GUI popup for the user to check or customise their Cold Address\n */\nexport async function guiSetColdStakingAddress() {\n    if (\n        await confirmPopup({\n            title: 'Set your Cold Staking address',\n            html: `<p>Current address:<br><span class=\"mono\">${strColdStakingAddress}</span><br><br><span style=\"opacity: 0.65; margin: 10px;\">A Cold Address stakes coins on your behalf, it cannot spend coins, so it's even safe to use a stranger's Cold Address!</span></p><br><input type=\"text\" id=\"newColdAddress\" placeholder=\"Example: ${strColdStakingAddress.substring(\n                0,\n                6\n            )}...\" style=\"text-align: center;\">`,\n        })\n    ) {\n        // Fetch address from the popup input\n        const strColdAddress = document.getElementById('newColdAddress').value;\n\n        // If it's empty, just return false\n        if (!strColdAddress) return false;\n\n        // Sanity-check, and set!\n        if (\n            strColdAddress[0] === cChainParams.current.STAKING_PREFIX &&\n            strColdAddress.length === 34\n        ) {\n            await setColdStakingAddress(strColdAddress);\n            createAlert(\n                'info',\n                '<b>Cold Address set!</b><br>Future stakes will use this address.',\n                [],\n                5000\n            );\n            return true;\n        } else {\n            createAlert('warning', 'Invalid Cold Staking address!', [], 2500);\n            return false;\n        }\n    } else {\n        return false;\n    }\n}\n\nexport async function wipePrivateData() {\n    const isEncrypted = await hasEncryptedWallet();\n    const title = isEncrypted\n        ? 'Do you want to lock your wallet?'\n        : 'Do you want to wipe your wallet private data?';\n    const html = isEncrypted\n        ? 'You will need to enter your password to access your funds'\n        : \"You will lose access to your funds if you haven't backed up your private key or seed phrase\";\n    if (\n        await confirmPopup({\n            title,\n            html,\n        })\n    ) {\n        masterKey.wipePrivateData();\n        doms.domWipeWallet.hidden = true;\n        if (isEncrypted) {\n            doms.domRestoreWallet.hidden = false;\n        }\n    }\n}\n\n/**\n * Prompt the user in the GUI to unlock their wallet\n * @param {string} strReason - An optional reason for the unlock\n * @returns {Promise<boolean>} - If the unlock was successful or rejected\n */\nexport async function restoreWallet(strReason = '') {\n    // Build up the UI elements based upon conditions for the unlock prompt\n    let strHTML = '';\n\n    // If there's a reason given; display it as a sub-text\n    strHTML += `<p style=\"opacity: 0.75\">${strReason}</p>`;\n\n    // Prompt the user\n    if (\n        await confirmPopup({\n            title: 'Unlock your wallet',\n            html: `${strHTML}<input type=\"password\" id=\"restoreWalletPassword\" placeholder=\"Wallet password\" style=\"text-align: center;\">`,\n        })\n    ) {\n        // Fetch the password from the prompt, and immediately destroy the prompt input\n        const domPassword = document.getElementById('restoreWalletPassword');\n        const strPassword = domPassword.value;\n        domPassword.value = '';\n\n        // Attempt to unlock the wallet with the provided password\n        if (await decryptWallet(strPassword)) {\n            doms.domRestoreWallet.hidden = true;\n            doms.domWipeWallet.hidden = false;\n            // Wallet is unlocked!\n            return true;\n        } else {\n            // Password is invalid\n            return false;\n        }\n    } else {\n        // User rejected the unlock\n        return false;\n    }\n}\n\n/** A lock to prevent rendering the Governance Dashboard multiple times */\nlet fRenderingGovernance = false;\n\n/**\n * Fetch Governance data and re-render the Governance UI\n */\nexport async function updateGovernanceTab() {\n    if (fRenderingGovernance) return;\n    fRenderingGovernance = true;\n\n    // Setup the Superblock countdown (if not already done), no need to block thread with await, either.\n    let cNet = getNetwork();\n\n    // When switching to mainnet from testnet or vise versa, you ned to use an await on getBlockCount() or cNet.cachedBlockCount returns 0\n    if (!isTestnetLastState == cChainParams.current.isTestnet) {\n        // Reset flipdown\n        governanceFlipdown = null;\n        doms.domFlipdown.innerHTML = '';\n\n        // Get new network blockcount\n        await getNetwork().getBlockCount();\n        cNet = getNetwork();\n    }\n\n    // Update governance counter when testnet/mainnet has been switched\n    if (!governanceFlipdown && cNet.cachedBlockCount > 0) {\n        Masternode.getNextSuperblock().then((nSuperblock) => {\n            // The estimated time to the superblock (using the block target and remaining blocks)\n            const nTimestamp =\n                Date.now() / 1000 + (nSuperblock - cNet.cachedBlockCount) * 60;\n            governanceFlipdown = new FlipDown(nTimestamp).start();\n        });\n        isTestnetLastState = cChainParams.current.isTestnet;\n    }\n\n    // Fetch all proposals from the network\n    const arrProposals = await Masternode.getProposals({\n        fAllowFinished: false,\n    });\n\n    /* Sort proposals into two categories\n        - Standard (Proposal is either new with <100 votes, or has a healthy vote count)\n        - Contested (When a proposal may be considered spam, malicious, or simply highly contestable)\n    */\n    const arrStandard = arrProposals.filter(\n        (a) => a.Yeas + a.Nays < 100 || a.Ratio > 0.25\n    );\n    const arrContested = arrProposals.filter(\n        (a) => a.Yeas + a.Nays >= 100 && a.Ratio <= 0.25\n    );\n\n    // Render Proposals\n    await Promise.all([\n        renderProposals(arrStandard, false),\n        renderProposals(arrContested, true),\n    ]);\n\n    // Remove lock\n    fRenderingGovernance = false;\n}\n\n/**\n * @typedef {Object} ProposalCache\n * @property {number} nSubmissionHeight - The submission height of the proposal.\n * @property {string} txid - The transaction ID of the proposal (string).\n * @property {boolean} fFetching - Indicates whether the proposal is currently being fetched or not.\n */\n\n/**\n * An array of Proposal Finalisation caches\n * @type {Array<ProposalCache>}\n */\nconst arrProposalFinalisationCache = [];\n\n/**\n * Asynchronously wait for a Proposal Tx to confirm, then cache the height.\n *\n * Do NOT await unless you want to lock the thread for a long time.\n * @param {ProposalCache} cProposalCache - The proposal cache to wait for\n * @returns {Promise<boolean>} Returns `true` once the block height is cached\n */\nasync function waitForSubmissionBlockHeight(cProposalCache) {\n    let nHeight = null;\n\n    // Wait in a permanent throttled loop until we successfully fetch the block\n    const cNet = getNetwork();\n    while (true) {\n        // If a proposal is already fetching, then consequtive calls will be rejected\n        cProposalCache.fFetching = true;\n\n        // Attempt to fetch the submission Tx (may not exist yet!)\n        let cTx = null;\n        try {\n            cTx = await cNet.getTxInfo(cProposalCache.txid);\n        } catch (_) {}\n\n        if (!cTx || !cTx.blockHeight) {\n            // Didn't get the TX, throttle the thread by sleeping for a bit, then try again.\n            await sleep(30000);\n        } else {\n            nHeight = cTx.blockHeight;\n            break;\n        }\n    }\n\n    // Update the proposal finalisation cache\n    cProposalCache.nSubmissionHeight = nHeight;\n\n    return true;\n}\n\n/**\n * Create a Status String for a proposal's finalisation status\n * @param {ProposalCache} cPropCache - The proposal cache to check\n * @returns {string} The string status, for display purposes\n */\nfunction getProposalFinalisationStatus(cPropCache) {\n    const cNet = getNetwork();\n    const nConfsLeft = cPropCache.nSubmissionHeight + 6 - cNet.cachedBlockCount;\n\n    if (cPropCache.nSubmissionHeight === 0 || cNet.cachedBlockCount === 0) {\n        return 'Confirming...';\n    } else if (nConfsLeft > 0) {\n        return nConfsLeft + ' block' + (nConfsLeft === 1 ? '' : 's') + ' left';\n    } else if (Math.abs(nConfsLeft) >= cChainParams.current.budgetCycleBlocks) {\n        return 'Proposal Expired';\n    } else {\n        return 'Ready to submit';\n    }\n}\n\n/**\n *\n * @param {Object} cProposal - A local proposal to add to the cache tracker\n * @returns {ProposalCache} - The finalisation cache object pointer of the local proposal\n */\nfunction addProposalToFinalisationCache(cProposal) {\n    // If it exists, return the existing cache\n    /** @type ProposalCache */\n    let cPropCache = arrProposalFinalisationCache.find(\n        (a) => a.txid === cProposal.mpw.txid\n    );\n    if (cPropCache) return cPropCache;\n\n    // Create a new cache\n    cPropCache = {\n        nSubmissionHeight: 0,\n        txid: cProposal.mpw.txid,\n        fFetching: false,\n    };\n    arrProposalFinalisationCache.push(cPropCache);\n\n    // Return the object 'pointer' in the array for further updating\n    return cPropCache;\n}\n\n/**\n * Render Governance proposal objects to a given Proposal category\n * @param {Array<object>} arrProposals - The proposals to render\n * @param {boolean} fContested - The proposal category\n */\nasync function renderProposals(arrProposals, fContested) {\n    // Set the total budget\n    doms.domTotalGovernanceBudget.innerText = (\n        cChainParams.current.maxPayment / COIN\n    ).toLocaleString('en-gb');\n\n    // Update total budget in user's currency\n    const nPrice = await cMarket.getPrice(strCurrency);\n    const nCurrencyValue = (cChainParams.current.maxPayment / COIN) * nPrice;\n    const { nValue, cLocale } = optimiseCurrencyLocale(nCurrencyValue);\n    doms.domTotalGovernanceBudgetValue.innerHTML =\n        nValue.toLocaleString('en-gb', cLocale) +\n        ' <span style=\"color:#8b38ff;\">' +\n        strCurrency.toUpperCase() +\n        '</span>';\n\n    // Select the table based on the proposal category\n    const domTable = fContested\n        ? doms.domGovProposalsContestedTableBody\n        : doms.domGovProposalsTableBody;\n\n    // Render the proposals in the relevent table\n    const database = await Database.getInstance();\n    const cMasternode = await database.getMasternode();\n\n    if (!fContested) {\n        const localProposals =\n            (await database.getAccount())?.localProposals?.map((p) => {\n                return {\n                    Name: p.name,\n                    URL: p.url,\n                    MonthlyPayment: p.monthlyPayment / COIN,\n                    RemainingPaymentCount: p.nPayments,\n                    TotalPayment: p.nPayments * (p.monthlyPayment / COIN),\n                    Yeas: 0,\n                    Nays: 0,\n                    local: true,\n                    Ratio: 0,\n                    mpw: p,\n                };\n            }) || [];\n        arrProposals = localProposals.concat(arrProposals);\n    }\n    arrProposals = await Promise.all(\n        arrProposals.map(async (p) => {\n            return {\n                YourVote:\n                    cMasternode && p.Hash\n                        ? await cMasternode.getVote(p.Name, p.Hash)\n                        : null,\n                ...p,\n            };\n        })\n    );\n\n    // Fetch the Masternode count for proposal status calculations\n    const cMasternodes = await Masternode.getMasternodeCount();\n\n    let totalAllocatedAmount = 0;\n\n    // Wipe the current table and start rendering proposals\n    let i = 0;\n    domTable.innerHTML = '';\n    for (const cProposal of arrProposals) {\n        const domRow = domTable.insertRow();\n\n        const domStatus = domRow.insertCell();\n        domStatus.classList.add('governStatusCol');\n        if (domTable.id == 'proposalsTableBody') {\n            domStatus.setAttribute(\n                'onclick',\n                `if(document.getElementById('governMob${i}').classList.contains('d-none')) { document.getElementById('governMob${i}').classList.remove('d-none'); } else { document.getElementById('governMob${i}').classList.add('d-none'); }`\n            );\n        } else if (domTable.id == 'proposalsContestedTableBody') {\n            domStatus.setAttribute(\n                'onclick',\n                `if(document.getElementById('governMobCon${i}').classList.contains('d-none')) { document.getElementById('governMobCon${i}').classList.remove('d-none'); } else { document.getElementById('governMobCon${i}').classList.add('d-none'); }`\n            );\n        }\n\n        // Add border radius to last row\n        if (arrProposals.length - 1 == i) {\n            domStatus.classList.add('bblr-7p');\n        }\n\n        // Net Yes calculation\n        const { Yeas, Nays } = cProposal;\n        const nNetYes = Yeas - Nays;\n        const nNetYesPercent = (nNetYes / cMasternodes.enabled) * 100;\n\n        // Proposal Status calculation\n        const nRequiredVotes = Math.round(cMasternodes.enabled * 0.1);\n        const strStatus = nNetYes >= nRequiredVotes ? 'PASSING' : 'FAILING';\n        let strFundingStatus = 'NOT FUNDED';\n\n        // Funding Status and allocation calculations\n        if (cProposal.local) {\n            // Check the finalisation cache\n            const cPropCache = addProposalToFinalisationCache(cProposal);\n            if (!cPropCache.fFetching) {\n                waitForSubmissionBlockHeight(cPropCache).then(\n                    updateGovernanceTab\n                );\n            }\n            const strStatus = getProposalFinalisationStatus(cPropCache);\n            const finalizeButton = document.createElement('button');\n            finalizeButton.className = 'pivx-button-small';\n            finalizeButton.innerHTML = '<i class=\"fas fa-check\"></i>';\n\n            if (\n                strStatus === 'Ready to submit' ||\n                strStatus === 'Proposal Expired'\n            ) {\n                finalizeButton.addEventListener('click', async () => {\n                    const result = await Masternode.finalizeProposal(\n                        cProposal.mpw\n                    );\n                    const deleteProposal = async () => {\n                        // Remove local Proposal from local storage\n                        const account = await database.getAccount();\n                        const localProposals = account?.localProposals || [];\n                        await database.addAccount({\n                            localProposals: localProposals.filter(\n                                (p) => p.txId !== cProposal.mpw.txId\n                            ),\n                        });\n                    };\n                    if (result.ok) {\n                        createAlert('success', 'Proposal finalized!');\n                        deleteProposal();\n                        updateGovernanceTab();\n                    } else {\n                        if (result.err === 'unconfirmed') {\n                            createAlert(\n                                'warning',\n                                \"The proposal hasn't been confirmed yet.\",\n                                5000\n                            );\n                        } else if (result.err === 'invalid') {\n                            createAlert(\n                                'warning',\n                                'The proposal has expired. Create a new one.',\n                                5000\n                            );\n                            deleteProposal();\n                            updateGovernanceTab();\n                        } else {\n                            createAlert(\n                                'warning',\n                                'Failed to finalize proposal.'\n                            );\n                        }\n                    }\n                });\n            } else {\n                finalizeButton.style.opacity = 0.5;\n                finalizeButton.style.cursor = 'default';\n            }\n\n            domStatus.innerHTML = `\n            <span style=\"font-size:12px; line-height: 15px; display: block; margin-bottom:15px;\">\n                <span style=\"color:#fff; font-weight:700;\">${strStatus}</span><br>\n            </span>\n            <span class=\"governArrow for-mobile ptr\">\n                <i class=\"fa-solid fa-angle-down\"></i>\n            </span>`;\n            domStatus.appendChild(finalizeButton);\n        } else {\n            if (domTable.id == 'proposalsTableBody') {\n                if (\n                    nNetYes >= nRequiredVotes &&\n                    totalAllocatedAmount + cProposal.MonthlyPayment <=\n                        cChainParams.current.maxPayment / COIN\n                ) {\n                    // Not enough budget or Net Yes votes for this proposal :(\n                    strFundingStatus = 'FUNDED';\n                    totalAllocatedAmount += cProposal.MonthlyPayment;\n                }\n            }\n\n            domStatus.innerHTML = `\n            <span style=\"font-size:12px; line-height: 15px; display: block; margin-bottom:15px;\">\n                <span style=\"color:#fff; font-weight:700;\">${strStatus}</span><br>\n                <span style=\"color:hsl(265 100% 67% / 1);\">(${strFundingStatus})</span><br>\n            </span>\n            <span style=\"font-size:12px; line-height: 15px; display: block; color:#d1d1d1;\">\n                <b>${nNetYesPercent.toFixed(1)}%</b><br>\n                Net Yes\n            </span>\n            <span class=\"governArrow for-mobile ptr\">\n                <i class=\"fa-solid fa-angle-down\"></i>\n            </span>`;\n        }\n\n        // Name and URL hyperlink\n        const domNameAndURL = domRow.insertCell();\n\n        // IMPORTANT: Sanitise all of our HTML or a rogue server or malicious proposal could perform a cross-site scripting attack\n        domNameAndURL.innerHTML = `<a class=\"active governLink\" href=\"${sanitizeHTML(\n            cProposal.URL\n        )}\" target=\"_blank\" rel=\"noopener noreferrer\"><b>${sanitizeHTML(\n            cProposal.Name\n        )} <span class=\"governLinkIco\"><i class=\"fa-solid fa-arrow-up-right-from-square\"></i></b></a></span>`;\n\n        // Convert proposal amount to user's currency\n        const nProposalValue = parseInt(cProposal.MonthlyPayment) * nPrice;\n        const { nValue } = optimiseCurrencyLocale(nProposalValue);\n        const strProposalCurrency = nValue.toLocaleString('en-gb', cLocale);\n\n        // Payment Schedule and Amounts\n        const domPayments = domRow.insertCell();\n        domPayments.classList.add('for-desktop');\n        domPayments.innerHTML = `<span class=\"governValues\"><b>${sanitizeHTML(\n            parseInt(cProposal.MonthlyPayment).toLocaleString('en-gb', ',', '.')\n        )}</b> <span class=\"governMarked\">${\n            cChainParams.current.TICKER\n        }</span> <br>\n        <b class=\"governFiatSize\">${strProposalCurrency} <span style=\"color:#8b38ff;\">${strCurrency.toUpperCase()}</span></b></span>\n\n        <span class=\"governInstallments\"> ${sanitizeHTML(\n            cProposal['RemainingPaymentCount']\n        )} installment(s) remaining<br>of <b>${sanitizeHTML(\n            parseInt(cProposal.TotalPayment).toLocaleString('en-gb', ',', '.')\n        )} ${cChainParams.current.TICKER}</b> total</span>`;\n\n        // Vote Counts and Consensus Percentages\n        const domVoteCounters = domRow.insertCell();\n        domVoteCounters.classList.add('for-desktop');\n\n        const nLocalPercent = cProposal.Ratio * 100;\n        domVoteCounters.innerHTML = `<b>${parseFloat(\n            nLocalPercent\n        ).toLocaleString(\n            'en-gb',\n            { minimumFractionDigits: 0, maximumFractionDigits: 1 },\n            ',',\n            '.'\n        )}%</b> <br>\n        <small class=\"votesBg\"> <b><div class=\"votesYes\" style=\"display:inline;\"> ${sanitizeHTML(\n            Yeas\n        )} </div></b> /\n        <b><div class=\"votesNo\" style=\"display:inline;\"> ${sanitizeHTML(\n            Nays\n        )} </div></b></small>\n        `;\n\n        // Voting Buttons for Masternode owners (MNOs)\n        let voteBtn;\n        if (cProposal.local) {\n            const domVoteBtns = domRow.insertCell();\n            domVoteBtns.classList.add('for-desktop');\n            voteBtn = '';\n        } else {\n            let btnYesClass = 'pivx-button-small';\n            let btnNoClass = 'pivx-button-small';\n            if (cProposal.YourVote) {\n                if (cProposal.YourVote === 1) {\n                    btnYesClass += ' pivx-button-big-yes-gov';\n                } else {\n                    btnNoClass += ' pivx-button-big-no-gov';\n                }\n            }\n            const domVoteBtns = domRow.insertCell();\n            const domNoBtn = document.createElement('button');\n            domNoBtn.className = btnNoClass;\n            domNoBtn.innerText = 'No';\n            domNoBtn.onclick = () => govVote(cProposal.Hash, 2);\n\n            const domYesBtn = document.createElement('button');\n            domYesBtn.className = btnYesClass;\n            domYesBtn.innerText = 'Yes';\n            domYesBtn.onclick = () => govVote(cProposal.Hash, 1);\n\n            // Add border radius to last row\n            if (arrProposals.length - 1 == i) {\n                domVoteBtns.classList.add('bbrr-7p');\n            }\n\n            domVoteBtns.classList.add('for-desktop');\n            domVoteBtns.appendChild(domNoBtn);\n            domVoteBtns.appendChild(domYesBtn);\n\n            domNoBtn.setAttribute(\n                'onclick',\n                `MPW.govVote('${cProposal.Hash}', 2)`\n            );\n            domYesBtn.setAttribute(\n                'onclick',\n                `MPW.govVote('${cProposal.Hash}', 1);`\n            );\n            voteBtn = domNoBtn.outerHTML + domYesBtn.outerHTML;\n        }\n\n        // Create extended row for mobile\n        const mobileDomRow = domTable.insertRow();\n        const mobileExtended = mobileDomRow.insertCell();\n        if (domTable.id == 'proposalsTableBody') {\n            mobileExtended.id = `governMob${i}`;\n        } else if (domTable.id == 'proposalsContestedTableBody') {\n            mobileExtended.id = `governMobCon${i}`;\n        }\n        mobileExtended.colSpan = '2';\n        mobileExtended.classList.add('text-left');\n        mobileExtended.classList.add('d-none');\n        mobileExtended.classList.add('for-mobile');\n        mobileExtended.innerHTML = `\n        <div class=\"row pt-2\">\n            <div class=\"col-5 fs-13 fw-600\">\n                <div class=\"governMobDot\"></div> PAYMENT\n            </div>\n            <div class=\"col-7\">\n                <span class=\"governValues\"><b>${sanitizeHTML(\n                    parseInt(cProposal.MonthlyPayment).toLocaleString(\n                        'en-gb',\n                        ',',\n                        '.'\n                    )\n                )}</b> <span class=\"governMarked\">${\n            cChainParams.current.TICKER\n        }</span> <span style=\"margin-left:10px; margin-right: 2px;\" class=\"governMarked governFiatSize\">${strProposalCurrency}</span></b></span>\n        \n                <span class=\"governInstallments\"> ${sanitizeHTML(\n                    cProposal['RemainingPaymentCount']\n                )} installment(s) remaining<br>of <b>${sanitizeHTML(\n            parseInt(cProposal.TotalPayment).toLocaleString('en-gb', ',', '.')\n        )} ${cChainParams.current.TICKER}</b> total</span>\n            </div>\n        </div>\n        <hr class=\"governHr\">\n        <div class=\"row\">\n            <div class=\"col-5 fs-13 fw-600\">\n                <div class=\"governMobDot\"></div> VOTES\n            </div>\n            <div class=\"col-7\">\n                <b>${parseFloat(nLocalPercent).toLocaleString(\n                    'en-gb',\n                    { minimumFractionDigits: 0, maximumFractionDigits: 1 },\n                    ',',\n                    '.'\n                )}%</b>\n                <small class=\"votesBg\"> <b><div class=\"votesYes\" style=\"display:inline;\"> ${sanitizeHTML(\n                    Yeas\n                )} </div></b> /\n                <b><div class=\"votesNo\" style=\"display:inline;\"> ${sanitizeHTML(\n                    Nays\n                )} </div></b></small>\n            </div>\n        </div>\n        <hr class=\"governHr\">\n        <div class=\"row pb-2\">\n            <div class=\"col-5 fs-13 fw-600\">\n                <div class=\"governMobDot\"></div> VOTE\n            </div>\n            <div class=\"col-7\">\n                ${voteBtn}\n            </div>\n        </div>`;\n\n        i++;\n    }\n\n    // Show allocated budget\n    if (domTable.id == 'proposalsTableBody') {\n        const strAlloc = sanitizeHTML(\n            totalAllocatedAmount.toLocaleString('en-gb')\n        );\n        doms.domAllocatedGovernanceBudget.innerHTML = strAlloc;\n        doms.domAllocatedGovernanceBudget2.innerHTML = strAlloc;\n\n        // Update allocated budget in user's currency\n        const nCurrencyValue = totalAllocatedAmount * nPrice;\n        const { nValue } = optimiseCurrencyLocale(nCurrencyValue);\n        const strAllocCurrency =\n            nValue.toLocaleString('en-gb', cLocale) +\n            ' <span style=\"color:#8b38ff;\">' +\n            strCurrency.toUpperCase() +\n            '</span>';\n        doms.domAllocatedGovernanceBudgetValue.innerHTML = strAllocCurrency;\n        doms.domAllocatedGovernanceBudgetValue2.innerHTML = strAllocCurrency;\n    }\n}\n\nexport async function updateMasternodeTab() {\n    //TODO: IN A FUTURE ADD MULTI-MASTERNODE SUPPORT BY SAVING MNs with which you logged in the past.\n    // Ensure a wallet is loaded\n    doms.domMnTextErrors.innerHTML = '';\n    doms.domAccessMasternode.style.display = 'none';\n    doms.domCreateMasternode.style.display = 'none';\n    doms.domMnDashboard.style.display = 'none';\n\n    if (!masterKey) {\n        doms.domMnTextErrors.innerHTML =\n            'Please ' +\n            ((await hasEncryptedWallet()) ? 'unlock' : 'import') +\n            ' your <b>COLLATERAL WALLET</b> first.';\n        return;\n    }\n\n    if (!mempool.getConfirmed().length) {\n        doms.domMnTextErrors.innerHTML =\n            'Your wallet is empty or still loading, re-open the tab in a few seconds!';\n        return;\n    }\n\n    const database = await Database.getInstance();\n\n    let cMasternode = await database.getMasternode();\n    // If the collateral is missing (spent, or switched wallet) then remove the current MN\n    if (cMasternode) {\n        if (\n            !mempool\n                .getConfirmed()\n                .find((utxo) => isMasternodeUTXO(utxo, cMasternode))\n        ) {\n            database.removeMasternode();\n            cMasternode = null;\n        }\n    }\n\n    doms.domControlMasternode.style.display = cMasternode ? 'block' : 'none';\n\n    // first case: the wallet is not HD and it is not hardware, so in case the wallet has collateral the user can check its status and do simple stuff like voting\n    if (!masterKey.isHD) {\n        doms.domMnAccessMasternodeText.innerHTML =\n            doms.masternodeLegacyAccessText;\n        doms.domMnTxId.style.display = 'none';\n        // Find the first UTXO matching the expected collateral size\n        const cCollaUTXO = mempool\n            .getConfirmed()\n            .find(\n                (cUTXO) => cUTXO.sats === cChainParams.current.collateralInSats\n            );\n        const balance = getBalance(false);\n        if (cCollaUTXO) {\n            if (cMasternode) {\n                await refreshMasternodeData(cMasternode);\n                doms.domMnDashboard.style.display = '';\n            } else {\n                doms.domMnTxId.style.display = 'none';\n                doms.domccessMasternode.style.display = 'block';\n            }\n        } else if (balance < cChainParams.current.collateralInSats) {\n            // The user needs more funds\n            doms.domMnTextErrors.innerHTML =\n                'You need <b>' +\n                (cChainParams.current.collateralInSats - balance) / COIN +\n                ' more ' +\n                cChainParams.current.TICKER +\n                '</b> to create a Masternode!';\n        } else {\n            // The user has the funds, but not an exact collateral, prompt for them to create one\n            doms.domCreateMasternode.style.display = 'block';\n            doms.domMnTxId.style.display = 'none';\n            doms.domMnTxId.innerHTML = '';\n        }\n    } else {\n        doms.domMnTxId.style.display = 'none';\n        doms.domMnTxId.innerHTML = '';\n        doms.domMnAccessMasternodeText.innerHTML = doms.masternodeHDAccessText;\n\n        // First UTXO for each address in HD\n        const mapCollateralAddresses = new Map();\n\n        // Aggregate all valid Masternode collaterals into a map of Address <--> Collateral\n        for (const cUTXO of mempool.getConfirmed()) {\n            if (cUTXO.sats !== cChainParams.current.collateralInSats) continue;\n            mapCollateralAddresses.set(cUTXO.path, cUTXO);\n        }\n        const fHasCollateral = mapCollateralAddresses.size > 0;\n\n        // If there's no loaded MN, but valid collaterals, display the configuration screen\n        if (!cMasternode && fHasCollateral) {\n            doms.domMnTxId.style.display = 'block';\n            doms.domAccessMasternode.style.display = 'block';\n\n            for (const [key] of mapCollateralAddresses) {\n                const option = document.createElement('option');\n                option.value = key;\n                option.innerText = await masterKey.getAddress(key);\n                doms.domMnTxId.appendChild(option);\n            }\n        }\n\n        // If there's no collateral found, display the creation UI\n        if (!fHasCollateral) doms.domCreateMasternode.style.display = 'block';\n\n        // If we have a collateral and a loaded Masternode, display the Dashboard\n        if (fHasCollateral && cMasternode) {\n            // Refresh the display\n            refreshMasternodeData(cMasternode);\n            doms.domMnDashboard.style.display = '';\n        }\n    }\n}\n\nasync function refreshMasternodeData(cMasternode, fAlert = false) {\n    const cMasternodeData = await cMasternode.getFullData();\n    if (debug) console.log(cMasternodeData);\n\n    // If we have MN data available, update the dashboard\n    if (cMasternodeData && cMasternodeData.status !== 'MISSING') {\n        doms.domMnTextErrors.innerHTML = '';\n        doms.domMnProtocol.innerText = `(${sanitizeHTML(\n            cMasternodeData.version\n        )})`;\n        doms.domMnStatus.innerText = sanitizeHTML(cMasternodeData.status);\n        doms.domMnNetType.innerText = sanitizeHTML(\n            cMasternodeData.network.toUpperCase()\n        );\n        doms.domMnNetIP.innerText = cMasternode.addr;\n        doms.domMnLastSeen.innerText = new Date(\n            cMasternodeData.lastseen * 1000\n        ).toLocaleTimeString();\n    }\n\n    if (cMasternodeData.status === 'MISSING') {\n        doms.domMnTextErrors.innerHTML =\n            'Masternode is currently <b>OFFLINE</b>';\n        if (!masterKey.isViewOnly) {\n            createAlert(\n                'warning',\n                'Your masternode is offline, we will try to start it',\n                6000\n            );\n            // try to start the masternode\n            const started = await cMasternode.start();\n            if (started) {\n                doms.domMnTextErrors.innerHTML =\n                    'Masternode successfully started!';\n                createAlert(\n                    'success',\n                    'Masternode successfully started!, it will be soon online',\n                    6000\n                );\n                const database = await Database.getInstance();\n                await database.addMasternode(cMasternode);\n            } else {\n                doms.domMnTextErrors.innerHTML =\n                    \"We couldn't start your masternode\";\n                createAlert(\n                    'warning',\n                    'We could not start your masternode',\n                    6000\n                );\n            }\n        }\n    } else if (\n        cMasternodeData.status === 'ENABLED' ||\n        cMasternodeData.status === 'PRE_ENABLED'\n    ) {\n        if (fAlert)\n            createAlert(\n                'success',\n                `Your masternode status is <b> ${sanitizeHTML(\n                    cMasternodeData.status\n                )} </b>`,\n                6000\n            );\n        const database = await Database.getInstance();\n        await database.addMasternode(cMasternode);\n    } else if (cMasternodeData.status === 'REMOVED') {\n        doms.domMnTextErrors.innerHTML =\n            'Masternode is currently <b>REMOVED</b>';\n        if (fAlert)\n            createAlert(\n                'warning',\n                'Your masternode is in <b>REMOVED</b> state',\n                6000\n            );\n    } else {\n        // connection problem\n        doms.domMnTextErrors.innerHTML = 'Unable to connect!';\n        if (fAlert) createAlert('warning', 'Unable to connect!', 6000);\n    }\n\n    // Return the data in case the caller needs additional context\n    return cMasternodeData;\n}\n\nexport async function createProposal() {\n    if (!masterKey) {\n        return createAlert(\n            'warning',\n            'Create or import your wallet to continue'\n        );\n    }\n    if (\n        masterKey.isViewOnly &&\n        !(await restoreWallet('Unlock to create a proposal!'))\n    ) {\n        return;\n    }\n    if (getBalance() * COIN < cChainParams.current.proposalFee) {\n        return createAlert('warning', 'Not enough funds to create a proposal.');\n    }\n\n    const fConfirmed = await confirmPopup({\n        title: `Create Proposal (cost ${\n            cChainParams.current.proposalFee / COIN\n        } ${cChainParams.current.TICKER})`,\n        html: `<input id=\"proposalTitle\" maxlength=\"20\" placeholder=\"Title\" style=\"text-align: center;\"><br>\n               <input id=\"proposalUrl\" maxlength=\"64\" placeholder=\"URL\" style=\"text-align: center;\"><br>\n               <input type=\"number\" id=\"proposalCycles\" placeholder=\"Duration in cycles\" style=\"text-align: center;\"><br>\n               <input type=\"number\" id=\"proposalPayment\" placeholder=\"${cChainParams.current.TICKER} per cycle\" style=\"text-align: center;\"><br>`,\n    });\n\n    // If the user cancelled, then we return\n    if (!fConfirmed) return;\n\n    const strTitle = document.getElementById('proposalTitle').value;\n    const strUrl = document.getElementById('proposalUrl').value;\n    const numCycles = parseInt(document.getElementById('proposalCycles').value);\n    const numPayment = parseInt(\n        document.getElementById('proposalPayment').value\n    );\n    const nextSuperblock = await Masternode.getNextSuperblock();\n    const proposal = {\n        name: strTitle,\n        url: strUrl,\n        nPayments: numCycles,\n        start: nextSuperblock,\n        address: (await getNewAddress())[0],\n        monthlyPayment: numPayment * COIN,\n    };\n\n    const isValid = Masternode.isValidProposal(proposal);\n    if (!isValid.ok) {\n        createAlert(\n            'warning',\n            `Proposal is invalid. Error: ${isValid.err}`,\n            5000\n        );\n        return;\n    }\n\n    const hash = Masternode.createProposalHash(proposal);\n    const { ok, txid } = await createAndSendTransaction({\n        address: hash,\n        amount: cChainParams.current.proposalFee,\n        isProposal: true,\n    });\n    if (ok) {\n        proposal.txid = txid;\n        const database = await Database.getInstance();\n        const account = await database.getAccount();\n        const localProposals = account?.localProposals || [];\n        localProposals.push(proposal);\n        await database.addAccount({ localProposals });\n        createAlert('success', 'Proposal created! Please finalize it.');\n        updateGovernanceTab();\n    }\n}\n\nexport function refreshChainData() {\n    const cNet = getNetwork();\n    // If in offline mode: don't sync ANY data or connect to the internet\n    if (!cNet.enabled)\n        return console.warn(\n            'Offline mode active: For your security, the wallet will avoid ALL internet requests.'\n        );\n    if (!masterKey) return;\n\n    // Fetch block count + UTXOs, update the UI for new transactions\n    cNet.getBlockCount().then((_) => {\n        // Fetch latest Activity\n        updateActivityGUI(false, true);\n\n        // If it's open: update the Governance Dashboard\n        if (doms.domGovTab.classList.contains('active')) {\n            updateGovernanceTab();\n        }\n    });\n    getBalance(true);\n}\n\n// A safety mechanism enabled if the user attempts to leave without encrypting/saving their keys\nexport const beforeUnloadListener = (evt) => {\n    evt.preventDefault();\n    // Disable Save your wallet warning on unload\n    if (!cChainParams.current.isTestnet)\n        createAlert('warning', ALERTS.SAVE_WALLET_PLEASE, [], 10000);\n    // Most browsers ignore this nowadays, but still, keep it 'just incase'\n    return (evt.returnValue = translation.BACKUP_OR_ENCRYPT_WALLET);\n};\n\n/**\n * @typedef {Object} SettingsDOM - An object that contains the DOM elements for settings pages.\n * @property {HTMLElement} btn - The button to switch to this setting type.\n * @property {HTMLElement} section - The container for this setting type.\n */\n\n/**\n * Returns a list of all pages and their DOM elements.\n *\n * This must be a function, since, the DOM elements are `undefined` until\n * after the startup sequence.\n *\n * Types are inferred.\n */\nfunction getSettingsPages() {\n    return {\n        /** @type {SettingsDOM} */\n        wallet: {\n            btn: doms.domWalletSettingsBtn,\n            section: doms.domWalletSettings,\n        },\n        /** @type {SettingsDOM} */\n        display: {\n            btn: doms.domDisplaySettingsBtn,\n            section: doms.domDisplaySettings,\n        },\n    };\n}\n\n/**\n * Switch between screens in the settings menu\n * @param {string} page - The name of the setting page to switch to\n */\nexport function switchSettings(page) {\n    const SETTINGS = getSettingsPages();\n    const { btn, section } = SETTINGS[page];\n\n    Object.values(SETTINGS).forEach(({ section, btn }) => {\n        // Hide all settings sections\n        section.classList.add('d-none');\n        // Make all buttons inactive\n        btn.classList.remove('active');\n    });\n\n    // Show selected section and make its button active\n    section.classList.remove('d-none');\n    btn.classList.add('active');\n}\n\nfunction errorHandler(e) {\n    const message = `Unhandled exception. <br> ${sanitizeHTML(\n        e.message || e.reason\n    )}`;\n    try {\n        createAlert('warning', message);\n    } catch (_) {\n        // Something as gone wrong, so we fall back to the default alert\n        // This can happen on early errors for example\n        alert(message);\n    }\n}\n\n// This code is ran in the vanity gen worker as well!\n// In which case, window would be not defined.\n// `if (window)` wouldn't work either because\n// window is not defined as opposed to undefined\ntry {\n    window.addEventListener('error', errorHandler);\n    window.addEventListener('unhandledrejection', errorHandler);\n} catch (_) {}\n","import { getDerivationPath } from './wallet.js';\nimport { cChainParams, COIN } from './chain_params.js';\nimport { createAlert } from './misc.js';\nimport { Mempool, UTXO } from './mempool.js';\nimport { getEventEmitter } from './event_bus.js';\nimport {\n    STATS,\n    cStatKeys,\n    cAnalyticsLevel,\n    setExplorer,\n    fAutoSwitch,\n} from './settings.js';\n\n/**\n * A historical transaction type.\n * @enum {number}\n */\nexport const HistoricalTxType = {\n    UNKNOWN: 0,\n    STAKE: 1,\n    DELEGATION: 2,\n    UNDELEGATION: 3,\n    RECEIVED: 4,\n    SENT: 5,\n};\n\n/**\n * A historical transaction\n */\nexport class HistoricalTx {\n    /**\n     * @param {HistoricalTxType} type - The type of transaction.\n     * @param {string} id - The transaction ID.\n     * @param {Array<string>} senders - The list of 'input addresses'.\n     * @param {Array<string>} receivers - The list of 'output addresses'.\n     * @param {boolean} shieldedOutputs - If this transaction contains Shield outputs.\n     * @param {number} time - The block time of the transaction.\n     * @param {number} blockHeight - The block height of the transaction.\n     * @param {number} amount - The amount transacted, in coins.\n     */\n    constructor(\n        type,\n        id,\n        senders,\n        receivers,\n        shieldedOutputs,\n        time,\n        blockHeight,\n        amount\n    ) {\n        this.type = type;\n        this.id = id;\n        this.senders = senders;\n        this.receivers = receivers;\n        this.shieldedOutputs = shieldedOutputs;\n        this.time = time;\n        this.blockHeight = blockHeight;\n        this.amount = amount;\n    }\n}\n\n/**\n * Virtual class rapresenting any network backend\n */\nexport class Network {\n    constructor(masterKey) {\n        if (this.constructor === Network) {\n            throw new Error('Initializing virtual class');\n        }\n        this._enabled = true;\n\n        this.masterKey = masterKey;\n\n        this.lastWallet = 0;\n        this.isHistorySynced = false;\n    }\n\n    /**\n     * @param {boolean} value\n     */\n    set enabled(value) {\n        if (value !== this._enabled) {\n            getEventEmitter().emit('network-toggle', value);\n            this._enabled = value;\n        }\n    }\n\n    get enabled() {\n        return this._enabled;\n    }\n\n    enable() {\n        this.enabled = true;\n    }\n\n    disable() {\n        this.enabled = false;\n    }\n\n    toggle() {\n        this.enabled = !this.enabled;\n    }\n\n    getFee(bytes) {\n        // TEMPORARY: Hardcoded fee per-byte\n        return bytes * 50; // 50 sat/byte\n    }\n\n    get cachedBlockCount() {\n        throw new Error('cachedBlockCount must be implemented');\n    }\n\n    error() {\n        throw new Error('Error must be implemented');\n    }\n\n    getBlockCount() {\n        throw new Error('getBlockCount must be implemented');\n    }\n\n    sentTransaction() {\n        throw new Error('sendTransaction must be implemented');\n    }\n\n    submitAnalytics(_strType, _cData = {}) {\n        throw new Error('submitAnalytics must be implemented');\n    }\n\n    setMasterKey(masterKey) {\n        this.masterKey = masterKey;\n    }\n\n    async getTxInfo(_txHash) {\n        throw new Error('getTxInfo must be implemented');\n    }\n}\n\n/**\n *\n */\nexport class ExplorerNetwork extends Network {\n    /**\n     * @param {string} strUrl - Url pointing to the blockbook explorer\n     */\n    constructor(strUrl, masterKey) {\n        super(masterKey);\n        /**\n         * @type{string}\n         * @public\n         */\n        this.strUrl = strUrl;\n\n        /**\n         * @type{Number}\n         * @private\n         */\n        this.blocks = 0;\n\n        /**\n         * @type {Array<HistoricalTx>}\n         */\n        this.arrTxHistory = [];\n\n        this.historySyncing = false;\n    }\n\n    error() {\n        if (this.enabled) {\n            this.disable();\n            createAlert(\n                'warning',\n                '<b>Failed to synchronize!</b> Please try again later.' +\n                    '<br>You can attempt re-connect via the Settings.',\n                []\n            );\n        }\n    }\n\n    get cachedBlockCount() {\n        return this.blocks;\n    }\n\n    async getBlockCount() {\n        try {\n            getEventEmitter().emit('sync-status', 'start');\n            const { backend } = await (\n                await retryWrapper(fetchBlockbook, `/api/v2/api`)\n            ).json();\n            if (backend.blocks > this.blocks) {\n                console.log(\n                    'New block detected! ' +\n                        this.blocks +\n                        ' --> ' +\n                        backend.blocks\n                );\n                this.blocks = backend.blocks;\n\n                await this.getUTXOs();\n            }\n        } catch (e) {\n            this.error();\n            throw e;\n        } finally {\n            getEventEmitter().emit('sync-status', 'stop');\n        }\n    }\n\n    /**\n     * @typedef {object} BlockbookUTXO\n     * @property {string} txid - The TX hash of the output\n     * @property {number} vout - The Index Position of the output\n     * @property {string} value - The string-based satoshi value of the output\n     * @property {number} height - The block height the TX was confirmed in\n     * @property {number} confirmations - The depth of the TX in the blockchain\n     */\n\n    /**\n     * Fetch UTXOs from the current primary explorer\n     * @param {string} strAddress - Optional address, gets UTXOs without changing MPW's state\n     * @returns {Promise<Array<BlockbookUTXO>>} Resolves when it has finished fetching UTXOs\n     */\n    async getUTXOs(strAddress = '') {\n        // Don't fetch UTXOs if we're already scanning for them!\n        if (!strAddress) {\n            if (!this.masterKey) return;\n            if (this.isSyncing) return;\n            this.isSyncing = true;\n        }\n        try {\n            let publicKey;\n            // Derive our XPub, or fetch a single pubkey\n            if (this.masterKey.isHD && !strAddress) {\n                const derivationPath = getDerivationPath(\n                    this.masterKey.isHardwareWallet\n                )\n                    .split('/')\n                    .slice(0, 4)\n                    .join('/');\n                publicKey = await this.masterKey.getxpub(derivationPath);\n            } else {\n                // Use the param address if specified, or the Master Key by default\n                publicKey = strAddress || (await this.masterKey.getAddress());\n            }\n\n            // Fetch UTXOs for the key\n            const arrUTXOs = await (\n                await retryWrapper(fetchBlockbook, `/api/v2/utxo/${publicKey}`)\n            ).json();\n\n            // If using MPW's wallet, then sync the UTXOs in MPW's state\n            if (!strAddress) getEventEmitter().emit('utxo', arrUTXOs);\n\n            // Return the UTXOs for additional utility use\n            return arrUTXOs;\n        } catch (e) {\n            console.error(e);\n            this.error();\n        } finally {\n            this.isSyncing = false;\n        }\n    }\n    /**\n     * Fetches UTXOs full info\n     * @param {Object} cUTXO - object-formatted UTXO\n     * @returns {Promise<UTXO>} Promise that resolves with the full info of the UTXO\n     */\n    async getUTXOFullInfo(cUTXO) {\n        const cTx = await (\n            await retryWrapper(\n                fetchBlockbook,\n                `/api/v2/tx-specific/${cUTXO.txid}`\n            )\n        ).json();\n        const cVout = cTx.vout[cUTXO.vout];\n\n        let path;\n        if (cUTXO.path) {\n            path = cUTXO.path.split('/');\n            path[2] =\n                (this.masterKey.isHardwareWallet\n                    ? cChainParams.current.BIP44_TYPE_LEDGER\n                    : cChainParams.current.BIP44_TYPE) + \"'\";\n            this.lastWallet = Math.max(parseInt(path[5]), this.lastWallet);\n            path = path.join('/');\n        }\n\n        const isColdStake = cVout.scriptPubKey.type === 'coldstake';\n        const isStandard = cVout.scriptPubKey.type === 'pubkeyhash';\n        const isReward = cTx.vout[0].scriptPubKey.hex === '';\n        // We don't know what this is\n        if (!isColdStake && !isStandard) {\n            return null;\n        }\n\n        return new UTXO({\n            id: cUTXO.txid,\n            path,\n            sats: Math.round(cVout.value * COIN),\n            script: cVout.scriptPubKey.hex,\n            vout: cVout.n,\n            height: this.cachedBlockCount - (cTx.confirmations - 1),\n            status: cTx.confirmations < 1 ? Mempool.PENDING : Mempool.CONFIRMED,\n            isDelegate: isColdStake,\n            isReward,\n        });\n    }\n\n    async sendTransaction(hex) {\n        try {\n            const data = await (\n                await retryWrapper(fetchBlockbook, '/api/v2/sendtx/', {\n                    method: 'post',\n                    body: hex,\n                })\n            ).json();\n\n            // Throw and catch if the data is not a TXID\n            if (!data.result || data.result.length !== 64) throw data;\n\n            console.log('Transaction sent! ' + data.result);\n            getEventEmitter().emit('transaction-sent', true, data.result);\n            return data.result;\n        } catch (e) {\n            getEventEmitter().emit('transaction-sent', false, e);\n            return false;\n        }\n    }\n\n    /**\n     * Synchronise a partial chunk of our TX history\n     * @param {boolean} [fNewOnly] - Whether to sync ONLY new transactions\n     */\n    async syncTxHistoryChunk(fNewOnly = false) {\n        // Do not allow multiple calls at once\n        if (this.historySyncing) {\n            return false;\n        }\n        try {\n            if (!this.enabled || !this.masterKey) return this.arrTxHistory;\n            this.historySyncing = true;\n            const nHeight = this.arrTxHistory.length\n                ? this.arrTxHistory[this.arrTxHistory.length - 1].blockHeight\n                : 0;\n            const mapPaths = new Map();\n\n            // Form the API call using our wallet information\n            const fHD = this.masterKey.isHD;\n            const strDerivPath = getDerivationPath(\n                this.masterKey.isHardwareWallet\n            )\n                .split('/')\n                .slice(0, 4)\n                .join('/');\n            const strKey = fHD\n                ? await this.masterKey.getxpub(strDerivPath)\n                : await this.masterKey.getAddress();\n            const strRoot = `/api/v2/${fHD ? 'xpub/' : 'address/'}${strKey}`;\n            const strCoreParams = `?details=txs&tokens=derived&pageSize=200`;\n            const strAPI = strRoot + strCoreParams;\n\n            // If we have a known block height, check for incoming transactions within the last 60 blocks\n            const cRecentTXs =\n                this.blocks > 0\n                    ? await (\n                          await retryWrapper(\n                              fetchBlockbook,\n                              `${strAPI}&from=${this.blocks - 60}`\n                          )\n                      ).json()\n                    : {};\n\n            // If we do not have full history, then load more historical TXs in a slice\n            const cData =\n                !fNewOnly && !this.isHistorySynced\n                    ? await (\n                          await retryWrapper(\n                              fetchBlockbook,\n                              `${strAPI}&to=${nHeight ? nHeight - 1 : 0}`\n                          )\n                      ).json()\n                    : {};\n            if (fHD && (cData.tokens || cRecentTXs.tokens)) {\n                // Map all address <--> derivation paths\n                // - From historical transactions\n                if (cData.tokens) {\n                    cData.tokens.forEach((cAddrPath) =>\n                        mapPaths.set(cAddrPath.name, cAddrPath.path)\n                    );\n                }\n                // - From new transactions\n                if (cRecentTXs.tokens) {\n                    cRecentTXs.tokens.forEach((cAddrPath) =>\n                        mapPaths.set(cAddrPath.name, cAddrPath.path)\n                    );\n                }\n            } else {\n                mapPaths.set(strKey, ':)');\n            }\n\n            // Process our aggregated history data\n            if (\n                (cData && cData.transactions) ||\n                (cRecentTXs && cRecentTXs.transactions)\n            ) {\n                // Process Older (historical) TXs\n                const arrOlderTXs = this.toHistoricalTXs(\n                    cData.transactions || [],\n                    mapPaths\n                );\n\n                // Process Recent TXs, then add them manually on the basis that they are NOT already known in history\n                const arrRecentTXs = this.toHistoricalTXs(\n                    cRecentTXs.transactions || [],\n                    mapPaths\n                );\n                for (const cTx of arrRecentTXs) {\n                    if (\n                        !this.arrTxHistory.find((a) => a.id === cTx.id) &&\n                        !arrOlderTXs.find((a) => a.id === cTx.id)\n                    ) {\n                        // No identical Tx, so prepend it!\n                        this.arrTxHistory.unshift(cTx);\n                    }\n                }\n                this.arrTxHistory = this.arrTxHistory.concat(arrOlderTXs);\n\n                // If the results don't match the full 'max/requested results', then we know the history is complete\n                if (\n                    cData.transactions &&\n                    cData.transactions.length !== cData.itemsOnPage\n                ) {\n                    this.isHistorySynced = true;\n                }\n            }\n            return this.arrTxHistory;\n        } catch (e) {\n            console.error(e);\n        } finally {\n            this.historySyncing = false;\n        }\n    }\n\n    /**\n     * Convert a list of Blockbook transactions to HistoricalTxs\n     * @param {Array<object>} arrTXs - An array of the Blockbook TXs\n     * @param {Map<String, String>} mapPaths - A map of the derivation paths for involved addresses\n     * @returns {Array<HistoricalTx>} - A new array of `HistoricalTx`-formatted transactions\n     */\n    toHistoricalTXs(arrTXs, mapPaths) {\n        /**\n         * A function to sum a list of inputs (vin) or outputs (vout)\n         * @type {(v: Array<{addresses: String[], value: Number}>) => Number}\n         */\n        const txSum = (v) =>\n            v.reduce(\n                (t, s) =>\n                    t +\n                    (s.addresses &&\n                    s.addresses.some((strAddr) => mapPaths.has(strAddr))\n                        ? parseInt(s.value)\n                        : 0),\n                0\n            );\n\n        return arrTXs\n            .map((tx) => {\n                // The total 'delta' or change in balance, from the Tx's sums\n                let nAmount = (txSum(tx.vout) - txSum(tx.vin)) / COIN;\n\n                // If this Tx creates any Shield outputs\n                // Note: shielOuts typo intended, this is a Blockbook error\n                const fShieldOuts = Number.isFinite(tx.shielOuts);\n\n                // (Un)Delegated coins in this transaction, if any\n                let nDelegated = 0;\n\n                // The address(es) delegated to, if any\n                let strDelegatedAddr = '';\n\n                // The sender addresses, if any\n                const arrSenders =\n                    tx.vin?.flatMap((vin) => vin.addresses) || [];\n\n                // The receiver addresses, if any\n                let arrReceivers =\n                    tx.vout?.flatMap((vout) => vout.addresses) || [];\n                // Pretty-fy script addresses\n                arrReceivers = arrReceivers.map((addr) =>\n                    addr.startsWith('OP_') ? 'Contract' : addr\n                );\n\n                // Figure out the type, based on the Tx's properties\n                let type = HistoricalTxType.UNKNOWN;\n                if (\n                    !fShieldOuts &&\n                    tx?.vout[0]?.addresses[0]?.startsWith('CoinStake')\n                ) {\n                    type = HistoricalTxType.STAKE;\n                } else if (nAmount > 0 || (nAmount > 0 && fShieldOuts)) {\n                    type = HistoricalTxType.RECEIVED;\n                    // If this contains Shield outputs, then we received them\n                    if (fShieldOuts)\n                        nAmount = parseInt(tx.valueBalanceSat) / COIN;\n                } else if (nAmount < 0 || (nAmount < 0 && fShieldOuts)) {\n                    // Check vins for undelegations\n                    for (const vin of tx.vin) {\n                        const fDelegation = vin.addresses?.some((addr) =>\n                            addr.startsWith(cChainParams.current.STAKING_PREFIX)\n                        );\n                        if (fDelegation) {\n                            nDelegated -= parseInt(vin.value);\n                        }\n                    }\n\n                    // Check vouts for delegations\n                    for (const out of tx.vout) {\n                        strDelegatedAddr =\n                            out.addresses?.find((addr) =>\n                                addr.startsWith(\n                                    cChainParams.current.STAKING_PREFIX\n                                )\n                            ) || strDelegatedAddr;\n\n                        const fDelegation = !!strDelegatedAddr;\n                        if (fDelegation) {\n                            nDelegated += parseInt(out.value);\n                        }\n                    }\n\n                    // If a delegation was made, then display the value delegated\n                    if (nDelegated > 0) {\n                        type = HistoricalTxType.DELEGATION;\n                        nAmount = nDelegated / COIN;\n                    } else if (nDelegated < 0) {\n                        type = HistoricalTxType.UNDELEGATION;\n                        nAmount = nDelegated / COIN;\n                    } else {\n                        type = HistoricalTxType.SENT;\n                        // If this contains Shield outputs, then we sent them\n                        if (fShieldOuts)\n                            nAmount = parseInt(tx.valueBalanceSat) / COIN;\n                    }\n                }\n\n                return new HistoricalTx(\n                    type,\n                    tx.txid,\n                    arrSenders,\n                    nDelegated !== 0 ? [strDelegatedAddr] : arrReceivers,\n                    fShieldOuts,\n                    tx.blockTime,\n                    tx.blockHeight,\n                    Math.abs(nAmount)\n                );\n            })\n            .filter((tx) => tx.amount != 0);\n    }\n\n    async setMasterKey(masterKey) {\n        // If the public Master Key (xpub, address...) is different, then wipe TX history\n        if (\n            (await this.masterKey?.keyToExport) !==\n            (await masterKey.keyToExport)\n        ) {\n            this.arrTxHistory = [];\n        }\n\n        // Set the key\n        this.masterKey = masterKey;\n    }\n\n    async getTxInfo(txHash) {\n        const req = await retryWrapper(fetchBlockbook, `/api/v2/tx/${txHash}`);\n        return await req.json();\n    }\n\n    // PIVX Labs Analytics: if you are a user, you can disable this FULLY via the Settings.\n    // ... if you're a developer, we ask you to keep these stats to enhance upstream development,\n    // ... but you are free to completely strip MPW of any analytics, if you wish, no hard feelings.\n    submitAnalytics(strType, cData = {}) {\n        if (!this.enabled) return;\n\n        // Limit analytics here to prevent 'leakage' even if stats are implemented incorrectly or forced\n        let i = 0,\n            arrAllowedKeys = [];\n        for (i; i < cAnalyticsLevel.stats.length; i++) {\n            const cStat = cAnalyticsLevel.stats[i];\n            arrAllowedKeys.push(cStatKeys.find((a) => STATS[a] === cStat));\n        }\n\n        // Check if this 'stat type' was granted permissions\n        if (!arrAllowedKeys.includes(strType)) return false;\n\n        // Format\n        const cStats = { type: strType, ...cData };\n\n        // Send to Labs Analytics\n        const request = new XMLHttpRequest();\n        request.open('POST', 'https://scpscan.net/mpw/statistic', true);\n        request.setRequestHeader('Content-Type', 'application/json');\n        request.send(JSON.stringify(cStats));\n        return true;\n    }\n}\n\nlet _network = null;\n\n/**\n * Sets the network in use by MPW.\n * @param {ExplorerNetwork} network - network to use\n */\nexport function setNetwork(network) {\n    _network = network;\n}\n\n/**\n * Sets the network in use by MPW.\n * @returns {ExplorerNetwork?} Returns the network in use, may be null if MPW hasn't properly loaded yet.\n */\nexport function getNetwork() {\n    return _network;\n}\n\n/**\n * A Fetch wrapper which uses the current Blockbook Network's base URL\n * @param {string} api - The specific Blockbook api to call\n * @param {RequestInit} options - The Fetch options\n * @returns {Promise<Response>} - The unresolved Fetch promise\n */\nexport function fetchBlockbook(api, options) {\n    return fetch(_network.strUrl + api, options);\n}\n\n/**\n * A wrapper for Blockbook calls which can, in the event of an unresponsive explorer,\n * seamlessly attempt the same call on multiple other explorers until success.\n * @param {Function} func - The function to re-attempt with\n * @param  {...any} args - The arguments to pass to the function\n */\nasync function retryWrapper(func, ...args) {\n    // Track internal errors from the wrapper\n    let err;\n\n    // If allowed by the user, Max Tries is ALL MPW-supported explorers, otherwise, restrict to only the current one.\n    let nMaxTries = cChainParams.current.Explorers.length;\n    let retries = 0;\n\n    // The explorer index we started at\n    let nIndex = cChainParams.current.Explorers.findIndex(\n        (a) => a.url === getNetwork().strUrl\n    );\n\n    // Run the call until successful, or all attempts exhausted\n    while (retries < nMaxTries) {\n        try {\n            // Call the passed function with the arguments\n            const res = await func(...args);\n\n            // If the endpoint is non-OK, assume it's an error\n            if (!res.ok) throw res;\n\n            // Return the result if successful\n            return res;\n        } catch (error) {\n            err = error;\n\n            // If allowed, switch explorers\n            if (!fAutoSwitch) throw err;\n            nIndex = (nIndex + 1) % cChainParams.current.Explorers.length;\n            const cNewExplorer = cChainParams.current.Explorers[nIndex];\n\n            // Set the explorer at Network-class level, then as a hacky workaround for the current callback; we\n            // ... adjust the internal URL to the new explorer.\n            getNetwork().strUrl = cNewExplorer.url;\n            setExplorer(cNewExplorer, true);\n\n            // Bump the attempts, and re-try next loop\n            retries++;\n        }\n    }\n\n    // Throw an error so the calling code knows the operation failed\n    throw err;\n}\n","const buff_to_base64 = (buff) => btoa(String.fromCharCode.apply(null, buff));\n\nconst base64_to_buf = (b64) =>\n    Uint8Array.from(atob(b64), (c) => c.charCodeAt(null));\n\nconst enc = new TextEncoder();\nconst dec = new TextDecoder();\n\nexport async function encrypt(data, strPassword = '') {\n    const strPass =\n        strPassword ||\n        window.prompt('Please enter your wallet encryption password');\n    if (!strPass) return false;\n    return await encryptData(data, strPass);\n}\n\nexport async function decrypt(data, strPassword) {\n    const strPass =\n        strPassword ||\n        window.prompt('Please enter your wallet unlock password');\n    if (!strPass) return false;\n    return (await decryptData(data, strPass)) || 'decryption failed!';\n}\n\nconst getPasswordKey = (password) =>\n    window.crypto.subtle.importKey(\n        'raw',\n        enc.encode(password),\n        'PBKDF2',\n        false,\n        ['deriveKey']\n    );\n\nconst deriveKey = (passwordKey, salt, keyUsage) =>\n    window.crypto.subtle.deriveKey(\n        {\n            name: 'PBKDF2',\n            salt,\n            iterations: 250000,\n            hash: 'SHA-256',\n        },\n        passwordKey,\n        { name: 'AES-GCM', length: 256 },\n        false,\n        keyUsage\n    );\n\nasync function encryptData(secretData, password) {\n    try {\n        const salt = window.crypto.getRandomValues(new Uint8Array(16));\n        const iv = window.crypto.getRandomValues(new Uint8Array(12));\n        const passwordKey = await getPasswordKey(password);\n        const aesKey = await deriveKey(passwordKey, salt, ['encrypt']);\n        const encryptedContent = await window.crypto.subtle.encrypt(\n            {\n                name: 'AES-GCM',\n                iv: iv,\n            },\n            aesKey,\n            enc.encode(secretData)\n        );\n\n        const encryptedContentArr = new Uint8Array(encryptedContent);\n        let buff = new Uint8Array(\n            salt.byteLength + iv.byteLength + encryptedContentArr.byteLength\n        );\n        buff.set(salt, 0);\n        buff.set(iv, salt.byteLength);\n        buff.set(encryptedContentArr, salt.byteLength + iv.byteLength);\n        return buff_to_base64(buff);\n    } catch (e) {\n        console.log(`Error - ${e}`);\n        return '';\n    }\n}\n\nasync function decryptData(encryptedData, password) {\n    try {\n        const encryptedDataBuff = base64_to_buf(encryptedData);\n        const salt = encryptedDataBuff.slice(0, 16);\n        const iv = encryptedDataBuff.slice(16, 16 + 12);\n        const data = encryptedDataBuff.slice(16 + 12);\n        const passwordKey = await getPasswordKey(password);\n        const aesKey = await deriveKey(passwordKey, salt, ['decrypt']);\n        const decryptedContent = await window.crypto.subtle.decrypt(\n            {\n                name: 'AES-GCM',\n                iv: iv,\n            },\n            aesKey,\n            data\n        );\n        return dec.decode(decryptedContent);\n    } catch (e) {\n        console.log(`Error - ${e}`);\n        return '';\n    }\n}\n","import { hexToBytes, bytesToHex, dSHA256 } from './utils.js';\nimport * as nobleSecp256k1 from '@noble/secp256k1';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { generateMnemonic, mnemonicToSeed, validateMnemonic } from 'bip39';\nimport { doms, beforeUnloadListener } from './global.js';\nimport HDKey from 'hdkey';\nimport { getNetwork } from './network.js';\nimport {\n    pubKeyHashNetworkLen,\n    confirmPopup,\n    writeToUint8,\n    pubPrebaseLen,\n    createQR,\n    createAlert,\n    sleep,\n    getSafeRand,\n} from './misc.js';\nimport {\n    refreshChainData,\n    hideAllWalletOptions,\n    getBalance,\n    getStakingBalance,\n} from './global.js';\nimport {\n    cChainParams,\n    MAX_ACCOUNT_GAP,\n    PRIVKEY_BYTE_LENGTH,\n} from './chain_params.js';\nimport { ALERTS } from './i18n.js';\nimport { encrypt, decrypt } from './aes-gcm.js';\nimport bs58 from 'bs58';\nimport AppBtc from '@ledgerhq/hw-app-btc';\nimport TransportWebUSB from '@ledgerhq/hw-transport-webusb';\nimport createXpub from 'create-xpub';\nimport * as jdenticon from 'jdenticon';\nimport { Database } from './database.js';\n\nexport let fWalletLoaded = false;\n\n/**\n * Abstract class masterkey\n * @abstract\n */\nclass MasterKey {\n    #addressIndex = 0;\n    /**\n     * Map our own address -> Path\n     * @type {Map<String, String?>}\n     */\n    #ownAddresses = new Map();\n\n    constructor() {\n        if (this.constructor === MasterKey) {\n            throw new Error('initializing virtual class');\n        }\n    }\n\n    /**\n     * @param {String} [path] - BIP32 path pointing to the private key.\n     * @return {Promise<Array<Number>>} Array of bytes containing private key\n     * @abstract\n     */\n    async getPrivateKeyBytes(_path) {\n        throw new Error('Not implemented');\n    }\n\n    /**\n     * @param {String} [path] - BIP32 path pointing to the private key.\n     * @return {String} encoded private key\n     * @abstract\n     */\n    async getPrivateKey(path) {\n        return generateOrEncodePrivkey(await this.getPrivateKeyBytes(path))\n            .strWIF;\n    }\n\n    /**\n     * @param {String} [path] - BIP32 path pointing to the address\n     * @return {String} Address\n     * @abstract\n     */\n    async getAddress(path) {\n        return deriveAddress({ pkBytes: await this.getPrivateKeyBytes(path) });\n    }\n\n    /**\n     * @param {String} path - BIP32 path pointing to the xpub\n     * @return {Promise<String>} xpub\n     * @abstract\n     */\n    async getxpub(_path) {\n        throw new Error('Not implemented');\n    }\n\n    /**\n     * Wipe all private data from key.\n     * @return {void}\n     * @abstract\n     */\n    wipePrivateData() {\n        throw new Error('Not implemented');\n    }\n\n    /**\n     * @return {String} private key suitable for backup.\n     * @abstract\n     */\n    get keyToBackup() {\n        throw new Error('Not implemented');\n    }\n\n    /**\n     * @return {Promise<String>} public key to export. Only suitable for monitoring balance.\n     * @abstract\n     */\n    get keyToExport() {\n        throw new Error('Not implemented');\n    }\n\n    /**\n     * @return {Boolean} Whether or not this is a Hierarchical Deterministic wallet\n     */\n    get isHD() {\n        return this._isHD;\n    }\n\n    /**\n     * @return {Boolean} Whether or not this is a hardware wallet\n     */\n    get isHardwareWallet() {\n        return this._isHardwareWallet;\n    }\n\n    /**\n     * @return {Boolean} Whether or not this key is view only or not\n     */\n    get isViewOnly() {\n        return this._isViewOnly;\n    }\n\n    /**\n     * @param {string} address - address to check\n     * @return {Promise<String?>} BIP32 path or null if it's not your address\n     */\n    async isOwnAddress(address) {\n        if (this.#ownAddresses.has(address)) {\n            return this.#ownAddresses.get(address);\n        }\n        const last = getNetwork().lastWallet;\n        this.#addressIndex =\n            this.#addressIndex > last ? this.#addressIndex : last;\n        if (this.isHD) {\n            for (let i = 0; i < this.#addressIndex; i++) {\n                const path = getDerivationPath(this.isHardwareWallet, 0, 0, i);\n                const testAddress = await masterKey.getAddress(path);\n                if (address === testAddress) {\n                    this.#ownAddresses.set(address, path);\n                    return path;\n                }\n            }\n        } else {\n            const value = address === (await this.keyToExport) ? ':)' : null;\n            this.#ownAddresses.set(address, value);\n            return value;\n        }\n\n        this.#ownAddresses.set(address, null);\n        return null;\n    }\n\n    /**\n     * @return Promise<[string, string]> Address and its BIP32 derivation path\n     */\n    async getNewAddress() {\n        const last = getNetwork().lastWallet;\n        this.#addressIndex =\n            (this.#addressIndex > last ? this.#addressIndex : last) + 1;\n        if (this.#addressIndex - last > MAX_ACCOUNT_GAP) {\n            // If the user creates more than ${MAX_ACCOUNT_GAP} empty wallets we will not be able to sync them!\n            this.#addressIndex = last;\n        }\n        const path = getDerivationPath(\n            this.isHardwareWallet,\n            0,\n            0,\n            this.#addressIndex\n        );\n        const address = await this.getAddress(path);\n        return [address, path];\n    }\n}\n\nexport class HdMasterKey extends MasterKey {\n    constructor({ seed, xpriv, xpub }) {\n        super();\n        // Generate the HDKey\n        if (seed) this._hdKey = HDKey.fromMasterSeed(seed);\n        if (xpriv) this._hdKey = HDKey.fromExtendedKey(xpriv);\n        if (xpub) this._hdKey = HDKey.fromExtendedKey(xpub);\n        this._isViewOnly = !!xpub;\n        if (!this._hdKey)\n            throw new Error('All of seed, xpriv and xpub are undefined');\n        this._isHD = true;\n        this._isHardwareWallet = false;\n    }\n\n    async getPrivateKeyBytes(path) {\n        if (this.isViewOnly) {\n            throw new Error(\n                'Trying to get private key bytes from a view only key'\n            );\n        }\n        return this._hdKey.derive(path).privateKey;\n    }\n\n    get keyToBackup() {\n        if (this.isViewOnly) {\n            throw new Error('Trying to get private key from a view only key');\n        }\n        return this._hdKey.privateExtendedKey;\n    }\n\n    async getxpub(path) {\n        if (this.isViewOnly) return this._hdKey.publicExtendedKey;\n        return this._hdKey.derive(path).publicExtendedKey;\n    }\n\n    getAddress(path) {\n        let child;\n        if (this.isViewOnly) {\n            // If we're view only we can't derive hardened keys, so we'll assume\n            // That the xpub has already been derived\n            child = this._hdKey.derive(\n                path\n                    .split('/')\n                    .filter((n) => !n.includes(\"'\"))\n                    .join('/')\n            );\n        } else {\n            child = this._hdKey.derive(path);\n        }\n        return deriveAddress({ publicKey: bytesToHex(child.publicKey) });\n    }\n\n    wipePrivateData() {\n        if (this._isViewOnly) return;\n\n        this._hdKey = HDKey.fromExtendedKey(this.keyToExport);\n        this._isViewOnly = true;\n    }\n\n    get keyToExport() {\n        if (this._isViewOnly) return this._hdKey.publicExtendedKey;\n        // We need the xpub to point at the account level\n        return this._hdKey.derive(\n            getDerivationPath(false).split('/').slice(0, 4).join('/')\n        ).publicExtendedKey;\n    }\n}\n\nexport class HardwareWalletMasterKey extends MasterKey {\n    constructor() {\n        super();\n        this._isHD = true;\n        this._isHardwareWallet = true;\n    }\n    async getPrivateKeyBytes(_path) {\n        throw new Error('Hardware wallets cannot export private keys');\n    }\n\n    async getAddress(path, { verify } = {}) {\n        return deriveAddress({\n            publicKey: await this.getPublicKey(path, { verify }),\n        });\n    }\n\n    async getPublicKey(path, { verify } = {}) {\n        return deriveAddress({\n            publicKey: await getHardwareWalletKeys(path, false, verify),\n            output: 'COMPRESSED_HEX',\n        });\n    }\n\n    get keyToBackup() {\n        throw new Error(\"Hardware wallets don't have keys to backup\");\n    }\n\n    async getxpub(path) {\n        if (!this.xpub) {\n            this.xpub = await getHardwareWalletKeys(path, true);\n        }\n        return this.xpub;\n    }\n\n    // Hardware Wallets don't have exposed private data\n    wipePrivateData() {}\n\n    get isViewOnly() {\n        return false;\n    }\n    get keyToExport() {\n        return this.getxpub(\n            getDerivationPath(true)\n                .split('/')\n                .filter((v) => !v.includes(\"'\"))\n                .join('/')\n        );\n    }\n}\n\nexport class LegacyMasterKey extends MasterKey {\n    constructor({ pkBytes, address }) {\n        super();\n        this._isHD = false;\n        this._isHardwareWallet = false;\n        this._pkBytes = pkBytes;\n        this._address = address || super.getAddress();\n        this._isViewOnly = !!address;\n    }\n\n    getAddress() {\n        return this._address;\n    }\n\n    get keyToExport() {\n        return this._address;\n    }\n\n    async getPrivateKeyBytes(_path) {\n        if (this.isViewOnly) {\n            throw new Error(\n                'Trying to get private key bytes from a view only key'\n            );\n        }\n        return this._pkBytes;\n    }\n\n    get keyToBackup() {\n        return generateOrEncodePrivkey(this._pkBytes).strWIF;\n    }\n\n    async getxpub(_path) {\n        throw new Error(\n            'Trying to get an extended public key from a legacy address'\n        );\n    }\n\n    wipePrivateData() {\n        this._pkBytes = null;\n        this._isViewOnly = true;\n    }\n}\n\n// Ledger Hardware wallet constants\nexport const LEDGER_ERRS = new Map([\n    // Ledger error code <--> User-friendly string\n    [25870, 'Open the PIVX app on your device'],\n    [25873, 'Open the PIVX app on your device'],\n    [57408, 'Navigate to the PIVX app on your device'],\n    [27157, 'Wrong app! Open the PIVX app on your device'],\n    [27266, 'Wrong app! Open the PIVX app on your device'],\n    [27904, 'Wrong app! Open the PIVX app on your device'],\n    [27010, 'Unlock your Ledger, then try again!'],\n    [27404, 'Unlock your Ledger, then try again!'],\n]);\n\n/**\n * @type{MasterKey}\n */\nexport let masterKey;\n\n// Construct a full BIP44 pubkey derivation path from it's parts\nexport function getDerivationPath(\n    fLedger = false,\n    nAccount = 0,\n    nReceiving = 0,\n    nIndex = 0\n) {\n    // Coin-Type is different on Ledger, as such, we modify it if we're using a Ledger to derive a key\n    const strCoinType = fLedger\n        ? cChainParams.current.BIP44_TYPE_LEDGER\n        : cChainParams.current.BIP44_TYPE;\n    if (masterKey && !masterKey.isHD && !fLedger) {\n        return `:)//${strCoinType}'`;\n    }\n    return `m/44'/${strCoinType}'/${nAccount}'/${nReceiving}/${nIndex}`;\n}\n\n// Verify the integrity of a WIF private key, optionally parsing and returning the key payload\nexport function verifyWIF(\n    strWIF = '',\n    fParseBytes = false,\n    skipVerification = false\n) {\n    // Convert from Base58\n    const bWIF = bs58.decode(strWIF);\n\n    if (!skipVerification) {\n        // Verify the byte length\n        if (bWIF.byteLength !== PRIVKEY_BYTE_LENGTH) {\n            throw Error(\n                'Private key length (' +\n                    bWIF.byteLength +\n                    ') is invalid, should be ' +\n                    PRIVKEY_BYTE_LENGTH +\n                    '!'\n            );\n        }\n\n        // Verify the network byte\n        if (bWIF[0] !== cChainParams.current.SECRET_KEY) {\n            // Find the network it's trying to use, if any\n            const cNetwork = Object.keys(cChainParams)\n                .filter((strNet) => strNet !== 'current')\n                .map((strNet) => cChainParams[strNet])\n                .find((cNet) => cNet.SECRET_KEY === bWIF[0]);\n            // Give a specific alert based on the byte properties\n            throw Error(\n                cNetwork\n                    ? 'This private key is for ' +\n                          (cNetwork.isTestnet ? 'Testnet' : 'Mainnet') +\n                          ', wrong network!'\n                    : 'This private key belongs to another coin, or is corrupted.'\n            );\n        }\n\n        // Perform SHA256d hash of the WIF bytes\n        const shaHash = dSHA256(bWIF.slice(0, 34));\n\n        // Verify checksum (comparison by String since JS hates comparing object-like primitives)\n        const bChecksumWIF = bWIF.slice(bWIF.byteLength - 4);\n        const bChecksum = shaHash.slice(0, 4);\n        if (bChecksumWIF.join('') !== bChecksum.join('')) {\n            throw Error(\n                'Private key checksum is invalid, key may be modified, mis-typed, or corrupt.'\n            );\n        }\n    }\n\n    return fParseBytes ? Uint8Array.from(bWIF.slice(1, 33)) : true;\n}\n\n// A convenient alias to verifyWIF that returns the raw byte payload\nexport function parseWIF(strWIF, skipVerification = false) {\n    return verifyWIF(strWIF, true, skipVerification);\n}\n\n/**\n * Private key in Bytes and WIF formats\n * @typedef {Object} PrivateKey\n * @property {Uint8Array} pkBytes - The unprocessed Private Key bytes.\n * @property {string} strWIF - The WIF encoded private key string.\n */\n\n/**\n * Network encode 32 bytes for a private key\n * @param {Uint8Array} pkBytes - 32 Bytes\n * @returns {Uint8Array} - The network-encoded Private Key bytes\n */\nexport function encodePrivkeyBytes(pkBytes) {\n    const pkNetBytes = new Uint8Array(pkBytes.length + 2);\n    pkNetBytes[0] = cChainParams.current.SECRET_KEY; // Private key prefix (1 byte)\n    writeToUint8(pkNetBytes, pkBytes, 1); // Private key bytes             (32 bytes)\n    pkNetBytes[pkNetBytes.length - 1] = 1; // Leading digit                (1 byte)\n    return pkNetBytes;\n}\n\n/**\n * Generate a new private key OR encode an existing private key from raw bytes\n * @param {Uint8Array} pkBytesToEncode - Bytes to encode as a coin private key\n * @returns {PrivateKey} - The private key\n */\nexport function generateOrEncodePrivkey(pkBytesToEncode) {\n    // Private Key Generation\n    const pkBytes = pkBytesToEncode || getSafeRand();\n\n    // Network Encoding\n    const pkNetBytes = encodePrivkeyBytes(pkBytes);\n\n    // Double SHA-256 hash\n    const shaObj = dSHA256(pkNetBytes);\n\n    // WIF Checksum\n    const checksum = shaObj.slice(0, 4);\n    const keyWithChecksum = new Uint8Array(34 + checksum.length);\n    writeToUint8(keyWithChecksum, pkNetBytes, 0);\n    writeToUint8(keyWithChecksum, checksum, 34);\n\n    // Return both the raw bytes and the WIF format\n    return { pkBytes, strWIF: bs58.encode(keyWithChecksum) };\n}\n\n/**\n * Compress an uncompressed Public Key in byte form\n * @param {Array<Number> | Uint8Array} pubKeyBytes - The uncompressed public key bytes\n * @returns {Array<Number>} The compressed public key bytes\n */\nfunction compressPublicKey(pubKeyBytes) {\n    if (pubKeyBytes.length != 65)\n        throw new Error('Attempting to compress an invalid uncompressed key');\n    const x = pubKeyBytes.slice(1, 33);\n    const y = pubKeyBytes.slice(33);\n\n    // Compressed key is [key_parity + 2, x]\n    return [y[31] % 2 === 0 ? 2 : 3, ...x];\n}\n\n/**\n * Derive a Secp256k1 network-encoded public key (coin address) from raw private or public key bytes\n * @param {Object} options - The object to deconstruct\n * @param {String} [options.publicKey] - The hex encoded public key. Can be both compressed or uncompressed\n * @param {Array<Number> | Uint8Array} [options.pkBytes] - An array of bytes containing the private key\n * @param {\"ENCODED\" | \"UNCOMPRESSED_HEX\" | \"COMPRESSED_HEX\"} options.output - Output\n * @return {String} the public key with the specified encoding\n */\nexport function deriveAddress({ pkBytes, publicKey, output = 'ENCODED' }) {\n    if (!pkBytes && !publicKey) return null;\n    const compress = output !== 'UNCOMPRESSED_HEX';\n    // Public Key Derivation\n    let pubKeyBytes = publicKey\n        ? hexToBytes(publicKey)\n        : nobleSecp256k1.getPublicKey(pkBytes, compress);\n\n    if (output === 'UNCOMPRESSED_HEX') {\n        if (pubKeyBytes.length !== 65) {\n            // It's actually possible, but it's probably not something that we'll need\n            throw new Error(\"Can't uncompress an already compressed key\");\n        }\n        return bytesToHex(pubKeyBytes);\n    }\n\n    if (pubKeyBytes.length === 65) {\n        pubKeyBytes = compressPublicKey(pubKeyBytes);\n    }\n\n    if (pubKeyBytes.length != 33) {\n        throw new Error('Invalid public key');\n    }\n\n    if (output === 'COMPRESSED_HEX') {\n        return bytesToHex(pubKeyBytes);\n    }\n\n    // First pubkey SHA-256 hash\n    const pubKeyHashing = sha256(new Uint8Array(pubKeyBytes));\n\n    // RIPEMD160 hash\n    const pubKeyHashRipemd160 = ripemd160(pubKeyHashing);\n\n    // Network Encoding\n    const pubKeyHashNetwork = new Uint8Array(pubKeyHashNetworkLen);\n    pubKeyHashNetwork[0] = cChainParams.current.PUBKEY_ADDRESS;\n    writeToUint8(pubKeyHashNetwork, pubKeyHashRipemd160, 1);\n\n    // Double SHA-256 hash\n    const pubKeyHashingSF = dSHA256(pubKeyHashNetwork);\n\n    // Checksum\n    const checksumPubKey = pubKeyHashingSF.slice(0, 4);\n\n    // Public key pre-base58\n    const pubKeyPreBase = new Uint8Array(pubPrebaseLen);\n    writeToUint8(pubKeyPreBase, pubKeyHashNetwork, 0);\n    writeToUint8(pubKeyPreBase, checksumPubKey, pubKeyHashNetworkLen);\n\n    // Encode as Base58 human-readable network address\n    return bs58.encode(pubKeyPreBase);\n}\n\n/**\n * Import a wallet (with it's private, public or encrypted data)\n * @param {object} options\n * @param {string | Array<number>} options.newWif - The import data (if omitted, the UI input is accessed)\n * @param {boolean} options.fRaw - Whether the import data is raw bytes or encoded (WIF, xpriv, seed)\n * @param {boolean} options.isHardwareWallet - Whether the import is from a Hardware wallet or not\n * @param {boolean} options.skipConfirmation - Whether to skip the import UI confirmation or not\n * @param {boolean} options.fSavePublicKey - Whether to save the derived public key to disk (for View Only mode)\n * @param {boolean} options.fStartup - Whether the import is at Startup or at Runtime\n * @returns {Promise<void>}\n */\nexport async function importWallet({\n    newWif = false,\n    fRaw = false,\n    isHardwareWallet = false,\n    skipConfirmation = false,\n    fSavePublicKey = false,\n    fStartup = false,\n} = {}) {\n    const strImportConfirm =\n        \"Do you really want to import a new address? If you haven't saved the last private key, the wallet will be LOST forever.\";\n    const walletConfirm =\n        fWalletLoaded && !skipConfirmation\n            ? await confirmPopup({ html: strImportConfirm })\n            : true;\n\n    if (walletConfirm) {\n        if (isHardwareWallet) {\n            // Firefox does NOT support WebUSB, thus cannot work with Hardware wallets out-of-the-box\n            if (navigator.userAgent.includes('Firefox')) {\n                return createAlert(\n                    'warning',\n                    ALERTS.WALLET_FIREFOX_UNSUPPORTED,\n                    [],\n                    7500\n                );\n            }\n            const publicKey = await getHardwareWalletKeys(\n                getDerivationPath(true)\n            );\n            // Errors are handled within the above function, so there's no need for an 'else' here, just silent ignore.\n            if (!publicKey) return;\n\n            // Derive our hardware address and import!\n            await setMasterKey(new HardwareWalletMasterKey());\n\n            // Hide the 'export wallet' button, it's not relevant to hardware wallets\n            doms.domExportWallet.hidden = true;\n\n            createAlert(\n                'info',\n                ALERTS.WALLET_HARDWARE_WALLET,\n                [{ hardwareWallet: strHardwareName }],\n                12500\n            );\n        } else {\n            // If raw bytes: purely encode the given bytes rather than generating our own bytes\n            if (fRaw) {\n                newWif = generateOrEncodePrivkey(newWif).strWIF;\n\n                // A raw import likely means non-user owned key (i.e: created via VanityGen), thus, we assume safety first and add an exit blocking listener\n                addEventListener('beforeunload', beforeUnloadListener, {\n                    capture: true,\n                });\n            }\n\n            // Select WIF from internal source OR user input (could be: WIF, Mnemonic or xpriv)\n            const privateImportValue = newWif || doms.domPrivKey.value;\n            const passphrase = doms.domPrivKeyPassword.value;\n            doms.domPrivKey.value = '';\n            doms.domPrivKeyPassword.value = '';\n\n            if (await verifyMnemonic(privateImportValue)) {\n                // Generate our masterkey via Mnemonic Phrase\n                const seed = await mnemonicToSeed(\n                    privateImportValue,\n                    passphrase\n                );\n                await setMasterKey(new HdMasterKey({ seed }));\n            } else {\n                // Public Key Derivation\n                try {\n                    if (privateImportValue.startsWith('xpub')) {\n                        await setMasterKey(\n                            new HdMasterKey({\n                                xpub: privateImportValue,\n                            })\n                        );\n                    } else if (privateImportValue.startsWith('xprv')) {\n                        await setMasterKey(\n                            new HdMasterKey({\n                                xpriv: privateImportValue,\n                            })\n                        );\n                    } else if (\n                        privateImportValue.length === 34 &&\n                        cChainParams.current.PUBKEY_PREFIX.includes(\n                            privateImportValue[0]\n                        )\n                    ) {\n                        await setMasterKey(\n                            new LegacyMasterKey({\n                                address: privateImportValue,\n                            })\n                        );\n                    } else {\n                        // Lastly, attempt to parse as a WIF private key\n                        const pkBytes = parseWIF(privateImportValue);\n\n                        // Import the raw private key\n                        await setMasterKey(new LegacyMasterKey({ pkBytes }));\n                    }\n                } catch (e) {\n                    return createAlert(\n                        'warning',\n                        ALERTS.FAILED_TO_IMPORT + e.message,\n                        [],\n                        6000\n                    );\n                }\n            }\n        }\n\n        // Reaching here: the deserialisation was a full cryptographic success, so a wallet is now imported!\n        fWalletLoaded = true;\n\n        // Hide wipe wallet button if there is no private key\n        if (masterKey.isViewOnly || masterKey.isHardwareWallet) {\n            doms.domWipeWallet.hidden = true;\n            if (await hasEncryptedWallet()) {\n                doms.domRestoreWallet.hidden = false;\n            }\n        }\n\n        // For non-HD wallets: hide the 'new address' button, since these are essentially single-address MPW wallets\n        if (!masterKey.isHD) doms.domNewAddress.style.display = 'none';\n\n        // Update the loaded address in the Dashboard\n        getNewAddress({ updateGUI: true });\n\n        // Display Text\n        doms.domGuiWallet.style.display = 'block';\n        doms.domDashboard.click();\n\n        // Update identicon\n        doms.domIdenticon.dataset.jdenticonValue = masterKey.getAddress(\n            getDerivationPath()\n        );\n        jdenticon.update('#identicon');\n\n        // Hide the encryption prompt if the user is in Testnet mode\n        // ... or is using a hardware wallet, or is view-only mode.\n        if (\n            !(\n                cChainParams.current.isTestnet ||\n                isHardwareWallet ||\n                masterKey.isViewOnly\n            )\n        ) {\n            if (\n                // If the wallet was internally imported (not UI pasted), like via vanity, display the encryption prompt\n                (((fRaw && newWif.length) || newWif) &&\n                    !(await hasEncryptedWallet())) ||\n                // If the wallet was pasted and is an unencrypted key, then display the encryption prompt\n                !(await hasEncryptedWallet())\n            ) {\n                doms.domGenKeyWarning.style.display = 'block';\n            } else if (await hasEncryptedWallet()) {\n                // If the wallet was pasted and is an encrypted import, display the lock wallet UI\n                doms.domWipeWallet.hidden = false;\n            }\n        }\n\n        // Fetch state from explorer, if this import was post-startup\n        if (getNetwork().enabled && !fStartup) {\n            refreshChainData();\n            getNetwork().getUTXOs();\n        }\n\n        // Hide all wallet starter options\n        hideAllWalletOptions();\n    }\n}\n\n/**\n * Set or replace the active Master Key with a new Master Key\n * @param {MasterKey} mk - The new Master Key to set active\n */\nasync function setMasterKey(mk) {\n    masterKey = mk;\n    // Update the network master key\n    await getNetwork().setMasterKey(masterKey);\n}\n\n// Wallet Generation\nexport async function generateWallet(noUI = false) {\n    const strImportConfirm =\n        \"Do you really want to import a new address? If you haven't saved the last private key, the wallet will be LOST forever.\";\n    const walletConfirm =\n        fWalletLoaded && !noUI\n            ? await confirmPopup({ html: strImportConfirm })\n            : true;\n    if (walletConfirm) {\n        const mnemonic = generateMnemonic();\n\n        const passphrase = !noUI\n            ? await informUserOfMnemonic(mnemonic)\n            : undefined;\n        const seed = await mnemonicToSeed(mnemonic, passphrase);\n\n        // Prompt the user to encrypt the seed\n        await setMasterKey(new HdMasterKey({ seed }));\n        fWalletLoaded = true;\n\n        if (!cChainParams.current.isTestnet)\n            doms.domGenKeyWarning.style.display = 'block';\n        // Add a listener to block page unloads until we are sure the user has saved their keys, safety first!\n        addEventListener('beforeunload', beforeUnloadListener, {\n            capture: true,\n        });\n\n        // Display the dashboard\n        doms.domGuiWallet.style.display = 'block';\n        hideAllWalletOptions();\n\n        // Update identicon\n        doms.domIdenticon.dataset.jdenticonValue = masterKey.getAddress(\n            getDerivationPath()\n        );\n        jdenticon.update('#identicon');\n\n        getNewAddress({ updateGUI: true });\n\n        // Refresh the balance UI (why? because it'll also display any 'get some funds!' alerts)\n        getBalance(true);\n        getStakingBalance(true);\n    }\n\n    return masterKey;\n}\n\nexport async function verifyMnemonic(strMnemonic = '', fPopupConfirm = true) {\n    const nWordCount = strMnemonic.trim().split(/\\s+/g).length;\n\n    // Sanity check: Convert to lowercase\n    strMnemonic = strMnemonic.toLowerCase();\n\n    // Ensure it's a word count that makes sense\n    if (nWordCount >= 12 && nWordCount <= 24) {\n        if (!validateMnemonic(strMnemonic)) {\n            // The reason we want to ask the user for confirmation is that the mnemonic\n            // Could have been generated with another app that has a different dictionary\n            return (\n                fPopupConfirm &&\n                (await confirmPopup({\n                    title: 'Unexpected Seed Phrase',\n                    html: 'The seed phrase is either invalid, or was not generated by MPW.<br>Do you still want to proceed?',\n                }))\n            );\n        } else {\n            // Valid count and mnemonic\n            return true;\n        }\n    } else {\n        // Invalid count\n        return false;\n    }\n}\n\nfunction informUserOfMnemonic(mnemonic) {\n    return new Promise((res, _) => {\n        $('#mnemonicModal').modal({ keyboard: false });\n        doms.domMnemonicModalContent.innerText = mnemonic;\n        doms.domMnemonicModalButton.onclick = () => {\n            res(doms.domMnemonicModalPassphrase.value);\n            $('#mnemonicModal').modal('hide');\n\n            // Wipe the mnemonic displays of sensitive data\n            doms.domMnemonicModalContent.innerText = '';\n            doms.domMnemonicModalPassphrase.value = '';\n        };\n        $('#mnemonicModal').modal('show');\n    });\n}\n\nexport async function encryptWallet(strPassword = '') {\n    // Encrypt the wallet WIF with AES-GCM and a user-chosen password - suitable for browser storage\n    let strEncWIF = await encrypt(masterKey.keyToBackup, strPassword);\n    if (!strEncWIF) return false;\n\n    // Hide the encryption warning\n    doms.domGenKeyWarning.style.display = 'none';\n\n    const database = await Database.getInstance();\n    database.addAccount({\n        publicKey: await masterKey.keyToExport,\n        encWif: strEncWIF,\n    });\n    // Remove the exit blocker, we can annoy the user less knowing the key is safe in their database!\n    removeEventListener('beforeunload', beforeUnloadListener, {\n        capture: true,\n    });\n}\n\nexport async function decryptWallet(strPassword = '') {\n    // Check if there's any encrypted WIF available\n    const database = await Database.getInstance();\n    const { encWif: strEncWIF } = await database.getAccount();\n    if (!strEncWIF || strEncWIF.length < 1) return false;\n\n    // Prompt to decrypt it via password\n    const strDecWIF = await decrypt(strEncWIF, strPassword);\n    if (!strDecWIF || strDecWIF === 'decryption failed!') {\n        if (strDecWIF)\n            return createAlert('warning', 'Incorrect password!', 6000);\n    } else {\n        await importWallet({\n            newWif: strDecWIF,\n            skipConfirmation: true,\n            // Save the public key to disk for View Only mode\n            fSavePublicKey: true,\n        });\n        return true;\n    }\n}\n\n/**\n * @returns {Promise<bool>} If the wallet is unlocked\n */\nexport async function hasEncryptedWallet() {\n    const database = await Database.getInstance();\n    const account = await database.getAccount();\n    return !!account?.encWif;\n}\n\n// If the privateKey is null then the user connected a hardware wallet\nexport function hasHardwareWallet() {\n    if (!masterKey) return false;\n    return masterKey.isHardwareWallet == true;\n}\n\nexport async function hasWalletUnlocked(fIncludeNetwork = false) {\n    if (fIncludeNetwork && !getNetwork().enabled)\n        return createAlert(\n            'warning',\n            ALERTS.WALLET_OFFLINE_AUTOMATIC,\n            [],\n            5500\n        );\n    if (!masterKey) {\n        return createAlert(\n            'warning',\n            ALERTS.WALLET_UNLOCK_IMPORT,\n            [\n                {\n                    unlock: (await hasEncryptedWallet())\n                        ? 'unlock '\n                        : 'import/create',\n                },\n            ],\n            3500\n        );\n    } else {\n        return true;\n    }\n}\n\nfunction createAddressConfirmation(address) {\n    return `Please confirm this is the address you see on your ${strHardwareName}.\n              <div class=\"seed-phrase\">${address}</div>`;\n}\n\nexport async function getNewAddress({\n    updateGUI = false,\n    verify = false,\n} = {}) {\n    const [address, path] = await masterKey.getNewAddress();\n    if (verify && masterKey.isHardwareWallet) {\n        // Generate address to present to the user without asking to verify\n        const confAddress = await confirmPopup({\n            title: ALERTS.CONFIRM_POPUP_VERIFY_ADDR,\n            html: createAddressConfirmation(address),\n            resolvePromise: masterKey.getAddress(path, { verify }),\n        });\n        if (address !== confAddress) {\n            throw new Error('User did not verify address');\n        }\n    }\n\n    if (updateGUI) {\n        createQR('pivx:' + address, doms.domModalQR);\n        doms.domModalQrLabel.innerHTML =\n            'pivx:' +\n            address +\n            `<i onclick=\"MPW.toClipboard('${address}', this)\" id=\"guiAddressCopy\" class=\"fas fa-clipboard\" style=\"cursor: pointer; width: 20px;\"></i>`;\n        doms.domModalQR.firstChild.style.width = '100%';\n        doms.domModalQR.firstChild.style.height = 'auto';\n        doms.domModalQR.firstChild.classList.add('no-antialias');\n        document.getElementById('clipboard').value = address;\n    }\n\n    return [address, path];\n}\n\nexport let cHardwareWallet = null;\nexport let strHardwareName = '';\nlet transport;\nasync function getHardwareWalletKeys(\n    path,\n    xpub = false,\n    verify = false,\n    _attempts = 0\n) {\n    try {\n        // Check if we haven't setup a connection yet OR the previous connection disconnected\n        if (!cHardwareWallet || transport._disconnectEmitted) {\n            transport = await TransportWebUSB.create();\n            cHardwareWallet = new AppBtc({ transport, currency: 'PIVX' });\n        }\n\n        // Update device info and fetch the pubkey\n        strHardwareName =\n            transport.device.manufacturerName +\n            ' ' +\n            transport.device.productName;\n\n        // Prompt the user in both UIs\n        if (verify) createAlert('info', ALERTS.WALLET_CONFIRM_L, [], 3500);\n        const cPubKey = await cHardwareWallet.getWalletPublicKey(path, {\n            verify,\n            format: 'legacy',\n        });\n\n        if (xpub) {\n            return createXpub({\n                depth: 3,\n                childNumber: 2147483648,\n                chainCode: cPubKey.chainCode,\n                publicKey: cPubKey.publicKey,\n            });\n        } else {\n            return cPubKey.publicKey;\n        }\n    } catch (e) {\n        if (e.message.includes('denied by the user')) {\n            // User denied an operation\n            return false;\n        }\n\n        // If there's no device, nudge the user to plug it in.\n        if (e.message.toLowerCase().includes('no device selected')) {\n            createAlert('info', ALERTS.WALLET_NO_HARDWARE, [], 10000);\n            return false;\n        }\n\n        // If the device is unplugged, or connection lost through other means (such as spontanious device explosion)\n        if (e.message.includes(\"Failed to execute 'transferIn'\")) {\n            createAlert(\n                'info',\n                ALERTS.WALLET_HARDWARE_CONNECTION_LOST,\n                [\n                    {\n                        hardwareWallet: strHardwareName,\n                    },\n                ],\n                10000\n            );\n            return false;\n        }\n        if (_attempts < 10) {\n            // This is an ugly hack :(\n            // in the event where multiple parts of the code decide to ask for an address, just\n            // Retry at most 10 times waiting 200ms each time\n            await sleep(200);\n            return await getHardwareWalletKeys(\n                path,\n                xpub,\n                verify,\n                _attempts + 1\n            );\n        }\n\n        // If the ledger is busy, just nudge the user.\n        if (e.message.includes('is busy')) {\n            createAlert(\n                'info',\n                ALERTS.WALLET_HARDWARE_BUSY,\n                [\n                    {\n                        hardwareWallet: strHardwareName,\n                    },\n                ],\n                7500\n            );\n            return false;\n        }\n\n        // Check if this is an expected error\n        if (!e.statusCode || !LEDGER_ERRS.has(e.statusCode)) {\n            console.error(\n                'MISSING LEDGER ERROR-CODE TRANSLATION! - Please report this below error on our GitHub so we can handle it more nicely!'\n            );\n            console.error(e);\n        }\n\n        // Translate the error to a user-friendly string (if possible)\n        createAlert(\n            'warning',\n            ALERTS.WALLET_HARDWARE_ERROR,\n            [\n                {\n                    hardwareWallet: strHardwareName,\n                },\n                {\n                    error: LEDGER_ERRS.get(e.statusCode),\n                },\n            ],\n            5500\n        );\n\n        return false;\n    }\n}\n","import { deriveAddress } from './wallet.js';\nimport { getSafeRand } from './misc.js';\n\nonmessage = function (_evt) {\n    while (true) {\n        const cKeypair = {};\n        cKeypair.priv = getSafeRand();\n\n        cKeypair.pub = deriveAddress({ pkBytes: cKeypair.priv });\n        postMessage(cKeypair);\n    }\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [621,369], () => (__webpack_require__(79530)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"./\" + chunkId + \".mpw.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = self.location + \"\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t617: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkMPW\"] = self[\"webpackChunkMPW\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["deferred","leafPrototypes","getProto","next","bytes","Buffer","toString","current","main","name","collateralInSats","isTestnet","TICKER","PUBKEY_PREFIX","STAKING_PREFIX","PUBKEY_ADDRESS","SECRET_KEY","BIP44_TYPE","BIP44_TYPE_LEDGER","PROTOCOL_VERSION","MASTERNODE_PORT","Explorers","url","Nodes","Consensus","UPGRADE_V6_0","undefined","budgetCycleBlocks","proposalFee","maxPaymentCycles","maxPayment","testnet","MarketSource","cData","strName","strEndpoint","async","this","Object","keys","length","fetch","json","constructor","super","strCurrency","ensureCacheExists","market_data","current_price","hit","time_to_sync","transaction","freeze","FALSE","PUSHDATA1","PUSHDATA2","PUSHDATA4","RESERVED","TRUE","NOP","VER","IF","NOTIF","VERIF","VERNOTIF","ELSE","ENDIF","VERIFY","RETURN","TOALTSTACK","FROMALTSTACK","IFDUP","DEPTH","DROP","DUP","NIP","OVER","PICK","ROLL","ROT","SWAP","TUCK","CAT","SUBSTR","LEFT","RIGHT","SIZE","INVERT","AND","OR","XOR","EQUAL","EQUALVERIFY","RESERVED1","RESERVED2","NEGATE","ABS","NOT","ADD","SUB","MUL","DIV","MOD","LSHIFT","RSHIFT","BOOLAND","BOOLOR","NUMEQUAL","NUMEQUALVERIFY","NUMNOTEQUAL","LESSTHAN","GREATERTHAN","LESSTHANOREQUAL","GREATERTHANOREQUAL","MIN","MAX","WITHIN","RIPEMD160","SHA1","SHA256","HASH160","HASH256","CODESEPARATOR","CHECKSIG","CHECKSIGVERIFY","CHECKMULTISIG","CHECKMULTISIGVERIFY","NOP1","NOP2","CHECKLOCKTIMEVERIFY","NOP3","NOP4","NOP5","NOP6","NOP7","NOP8","NOP9","NOP10","ZEROCOINMINT","ZEROCOINSPEND","ZEROCOINPUBLICSPEND","CHECKCOLDSTAKEVERIFY_LOF","CHECKCOLDSTAKEVERIFY","INVALIDOPCODE","static","db","close","masternode","_masterKey","store","objectStore","put","delete","promo","code","publicKey","encWif","localProposals","oldAccount","getAccount","newAccount","get","Masternode","getAll","map","PromoWallet","Settings","settings","oldSettings","getSettings","localStorage","analytics","explorer","node","translation","displayCurrency","setSettings","JSON","parse","addMasternode","e","error","createAlert","encwif","addAccount","confirmPopup","title","html","sanitizeHTML","database","openDB","upgrade","oldVersion","log","createObjectStore","blocking","alert","window","location","reload","Map","cChainParams","instance","set","create","nSize","crypto","getRandomValues","Uint8Array","arr","pos","arrLen","strERR","Error","i","type","message","alertVariables","timeout","domAlert","document","createElement","classList","add","setTimeout","style","opacity","zIndex","translatedMessage","variables","forEach","element","replaceAll","values","translateAlerts","typeIcon","innerHTML","destroy","clearTimeout","timer","remove","addEventListener","eventEmitter","EventEmitter","id","path","sats","script","vout","height","status","isDelegate","isReward","equalsUTXO","cUTXO","UTXOs","subscribeToNetwork","nBlocks","ms","Promise","res","_","removeUTXO","isAlreadyStored","some","getUTXOsByState","nState","filter","removeFromState","cNewUTXO","arrPendingUTXOs","addUTXO","newUTXO","updateUTXO","push","find","utxo","PENDING","CONFIRMED","autoRemoveUTXO","REMOVED","removeWithDelay","autoRemoveUTXOs","arrUTXOs","getConfirmed","getStandardUTXOs","getDelegatedUTXOs","getBalance","cMasternode","collateralTxId","outidx","reduce","a","b","cachedBlockCount","getDelegatedBalance","on","utxos","txid","getUTXOFullInfo","TextEncoder","TextDecoder","updateTicker","domGuiBalanceValueCurrency","innerText","domSendAmountValueCurrency","domSendAmountCoinsTicker","domStakeAmountValueCurrency","domStakeAmountCoinsTicker","domUnstakeAmountCoinsTicker","updatePriceDisplay","domValue","fCold","then","nPrice","nCurrencyValue","nValue","cLocale","nAmount","Intl","supportedValuesOf","includes","currency","currencyDisplay","maximumFractionDigits","minimumFractionDigits","optimiseCurrencyLocale","toLocaleString","updateGUI","nBalance","nCoins","nLen","toFixed","domGuiBalance","domAvailToDelegate","domGuiBalanceValue","domGuiBalanceStaking","Math","floor","domAvailToUndelegate","domGuiStakingValue","errorHandler","text","reason","pkBytes","output","compress","pubKeyBytes","str","x","slice","compressPublicKey","pubKeyHashing","pubKeyHashRipemd160","ripemd160","pubKeyHashNetwork","buff","checksumPubKey","pubKeyPreBase","pubKeyHashNetworkLen","onmessage","_evt","cKeypair","priv","pub","postMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","loaded","__webpack_modules__","call","m","__webpack_exports__","O","result","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","every","key","splice","r","n","getter","__esModule","d","getPrototypeOf","obj","t","value","mode","ns","def","indexOf","getOwnPropertyNames","definition","o","defineProperty","enumerable","f","chunkId","all","promises","u","miniCssF","g","globalThis","Function","prop","prototype","hasOwnProperty","Symbol","toStringTag","nmd","paths","children","scriptUrl","importScripts","currentScript","src","scripts","getElementsByTagName","replace","p","self","installedChunks","chunkLoadingGlobal","parentChunkLoadingFunction","bind","data","moreModules","runtime","pop"],"sourceRoot":""}