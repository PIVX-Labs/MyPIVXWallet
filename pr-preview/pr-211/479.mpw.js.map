{"version":3,"file":"./479.mpw.js","mappings":"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","sources":["webpack://MPW/webpack/runtime/chunk loaded","webpack://MPW/webpack/runtime/create fake namespace object","webpack://MPW/webpack/runtime/startup chunk dependencies","webpack://MPW/./scripts/utils.js","webpack://MPW/./scripts/chain_params.js","webpack://MPW/./scripts/event_bus.js","webpack://MPW/./scripts/mempool.js","webpack://MPW/./scripts/misc.js","webpack://MPW/./scripts/global.js","webpack://MPW/./scripts/network.js","webpack://MPW/./scripts/ledger.js","webpack://MPW/./scripts/aes-gcm.js","webpack://MPW/./scripts/accounts.js","webpack://MPW/./scripts/contacts-book.js","webpack://MPW/./scripts/wallet.js","webpack://MPW/./scripts/i18n.js","webpack://MPW/./scripts/script.js","webpack://MPW/./scripts/prices.js","webpack://MPW/./scripts/Activity.vue?e00a","webpack://MPW/./scripts/Activity.vue","webpack://MPW/./scripts/settings.js","webpack://MPW/./scripts/masternode.js","webpack://MPW/./scripts/promos.js","webpack://MPW/./scripts/database.js","webpack://MPW/./scripts/encoding.js","webpack://MPW/./scripts/vanitygen_worker.js","webpack://MPW/webpack/bootstrap","webpack://MPW/webpack/runtime/compat get default export","webpack://MPW/webpack/runtime/define property getters","webpack://MPW/webpack/runtime/ensure chunk","webpack://MPW/webpack/runtime/get javascript chunk filename","webpack://MPW/webpack/runtime/get mini-css chunk filename","webpack://MPW/webpack/runtime/global","webpack://MPW/webpack/runtime/hasOwnProperty shorthand","webpack://MPW/webpack/runtime/make namespace object","webpack://MPW/webpack/runtime/node module decorator","webpack://MPW/webpack/runtime/publicPath","webpack://MPW/webpack/runtime/importScripts chunk loading","webpack://MPW/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));\n\t}\n\tdef['default'] = () => (value);\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn Promise.all([\n\t\t__webpack_require__.e(621),\n\t\t__webpack_require__.e(421)\n\t]).then(next);\n};","import { Buffer } from 'buffer';\nimport { sha256 } from '@noble/hashes/sha256';\n\nexport function hexToBytes(str) {\n    return Buffer.from(str, 'hex');\n}\n\nexport function bytesToHex(bytes) {\n    return Buffer.from(bytes).toString('hex');\n}\n\n/**\n * Double SHA256 hash a byte array\n * @param {Array<number>} buff - Bytes to hash\n * @returns {Uint8Array} Hash buffer\n */\nexport function dSHA256(buff) {\n    return sha256(sha256(new Uint8Array(buff)));\n}\n","// In most BTC-derived coins, the below parameters can be found in the 'src/chainparams.cpp' Mainnet configuration.\n// These below params share the same names as the CPP params, so finding and editing these is easy-peasy!\n// <[network_byte] [32_byte_payload] [0x01] [4_byte_checksum]>\nexport const PRIVKEY_BYTE_LENGTH = 38;\n\nexport const COIN_DECIMALS = 8;\nexport const COIN = 10 ** 8;\n\n/** The maximum gap (absence of transactions within a range of derived addresses) before an account search ends */\nexport const MAX_ACCOUNT_GAP = 20;\n\n/* Internal tweaking parameters */\n// A new encryption password must be 'at least' this long.\nexport const MIN_PASS_LENGTH = 6;\n\n/** BIP21 coin prefix */\nexport const BIP21_PREFIX = 'pivx';\n\n/* chainparams */\nexport const cChainParams = {\n    current: null,\n    main: {\n        name: 'mainnet',\n        collateralInSats: 10000 * COIN,\n        isTestnet: false,\n        TICKER: 'PIV',\n        PUBKEY_PREFIX: ['D'],\n        STAKING_PREFIX: 'S',\n        PUBKEY_ADDRESS: 30,\n        SECRET_KEY: 212,\n        BIP44_TYPE: 119,\n        BIP44_TYPE_LEDGER: 77,\n        PROTOCOL_VERSION: 70926,\n        MASTERNODE_PORT: 51472,\n        // A list of Labs-trusted explorers\n        Explorers: [\n            // Display name      Blockbook-compatible API base\n            { name: 'rockdev', url: 'https://explorer.rockdev.org' },\n            { name: 'zkBitcoin', url: 'https://zkbitcoin.com' },\n            { name: 'Duddino', url: 'https://explorer.duddino.com' },\n        ],\n        Nodes: [{ name: 'Duddino', url: 'https://rpc.duddino.com/mainnet' }],\n        Consensus: {\n            // Network upgrades\n            UPGRADE_V6_0: undefined,\n        },\n        budgetCycleBlocks: 43200,\n        proposalFee: 50 * COIN,\n        proposalFeeConfirmRequirement: 6,\n        maxPaymentCycles: 6,\n        maxPayment: 10 * 43200 * COIN, // 43200 blocks of 10 PIV\n    },\n    testnet: {\n        name: 'testnet',\n        collateralInSats: 10000 * COIN,\n        isTestnet: true,\n        TICKER: 'tPIV',\n        PUBKEY_PREFIX: ['x', 'y'],\n        STAKING_PREFIX: 'W',\n        PUBKEY_ADDRESS: 139,\n        SECRET_KEY: 239,\n        BIP44_TYPE: 1,\n        BIP44_TYPE_LEDGER: 1,\n        PROTOCOL_VERSION: 70926,\n        MASTERNODE_PORT: 51474,\n        // A list of Labs-trusted explorers\n        Explorers: [\n            // Display name      Blockbook-compatible API base\n            { name: 'rockdev', url: 'https://testnet.rockdev.org' },\n        ],\n        Nodes: [{ name: 'Duddino', url: 'https://rpc.duddino.com/testnet' }],\n        Consensus: {\n            // Network upgrades\n            UPGRADE_V6_0: undefined,\n        },\n        budgetCycleBlocks: 144,\n        proposalFee: 50 * COIN,\n        proposalFeeConfirmRequirement: 3,\n        maxPaymentCycles: 20,\n        maxPayment: 10 * 144 * COIN, // 144 blocks of 10 tPIV\n    },\n};\n// Set default chain\ncChainParams.current = cChainParams.main;\n","import { EventEmitter } from 'events';\n\nconst eventEmitter = new EventEmitter();\n\n/**\n * Get the application wide event emitter.\n * @returns {EventEmitter}\n */\nexport function getEventEmitter() {\n    return eventEmitter;\n}\n","import { getNetwork } from './network.js';\nimport { getBalance, isMasternodeUTXO, getStakingBalance } from './global.js';\nimport { sleep } from './misc.js';\nimport { debug } from './settings.js';\nimport { getEventEmitter } from './event_bus.js';\n\n/**\n * @typedef {Object} cIn - An input of a Tx\n * @property {string} txid - The transaction ID\n * @property {number} vout - The output index\n */\n\n/** An Unspent Transaction Output, used as Inputs of future transactions */\nexport class UTXO {\n    /**\n     * @param {Object} UTXO\n     * @param {String} UTXO.id - Transaction ID\n     * @param {String} UTXO.path - If applicable, the HD Path of the owning address\n     * @param {Number} UTXO.sats - Satoshi value in this UTXO\n     * @param {String} UTXO.script - HEX encoded spending script\n     * @param {Array<cIn>?} UTXO.vin - The inputs of the transaction, if any\n     * @param {Number} UTXO.vout - Output position of this transaction\n     * @param {Number} UTXO.height - Block height of the UTXO\n     * @param {Number} UTXO.status - UTXO status enum state\n     * @param {boolean} UTXO.isDelegate - Whether the UTXO is a cold stake delegation\n     * @param {boolean} UTXO.isReward - Whether the UTXO is a reward\n     */\n    constructor({\n        id,\n        path,\n        sats,\n        script,\n        vin = [],\n        vout,\n        height,\n        status,\n        isDelegate = false,\n        isReward = false,\n    } = {}) {\n        /** Transaction ID\n         * @type {String} */\n        this.id = id;\n\n        /** HD Path of the owning address\n         *  @type {String} */\n        this.path = path;\n\n        /** Satoshi value in this UTXO\n         *  @type {Number} */\n        this.sats = sats;\n\n        /** HEX encoded spending script\n         *  @type {String} */\n        this.script = script;\n\n        /** The inputs of the transaction, if any\n         *  @type {Array<cIn>} */\n        this.vin = vin;\n\n        /** Output position of this transaction\n         *  @type {Number} */\n        this.vout = vout;\n\n        /** Block height of the UTXO\n         *  @type {Number} */\n        this.height = height;\n\n        /** UTXO status enum state\n         *  @type {Number} */\n        this.status = status;\n\n        /** Whether it's a delegation UTXO\n         * @type {boolean} */\n        this.isDelegate = isDelegate;\n\n        /** Whether it's a reward UTXO\n         * @type {boolean} */\n        this.isReward = isReward;\n    }\n\n    /**\n     * Check for equality between this UTXO and another UTXO\n     * @param {UTXO} cUTXO - UTXO to compare against\n     * @returns {Boolean} `true` if equal, `false` if unequal\n     */\n    equalsUTXO(cUTXO) {\n        return (\n            this.id === cUTXO.id &&\n            this.vout === cUTXO.vout &&\n            this.status === cUTXO.status\n        );\n    }\n}\n\n/** A Mempool instance, stores and handles UTXO data for the wallet */\nexport class Mempool {\n    constructor() {\n        /**\n         * An array of all known UTXOs\n         * @type {Array<UTXO>}\n         */\n        this.UTXOs = [];\n        this.subscribeToNetwork();\n    }\n\n    /** The CONFIRMED state (UTXO is spendable) */\n    static CONFIRMED = 0;\n\n    /** The REMOVED state (UTXO was spent and will be removed soon) */\n    static REMOVED = 1;\n\n    /** The PENDING state (standard UTXO is in mempool, pending confirmation) */\n    static PENDING = 2;\n\n    /**\n     * Fetch a UTXO by ID and Index\n     * @param {string} id - Transaction ID of the UTXO\n     * @param {number} out - Output position of the UTXO\n     */\n    getUTXO(id, out) {\n        return this.UTXOs.find(\n            (cUTXO) => cUTXO.id === id && cUTXO.vout === out\n        );\n    }\n\n    /**\n     * Remove a UTXO after a set amount of time\n     * @param {Number} nBlocks - Estimated blocks to wait\n     * @param {UTXO} cUTXO - UTXO to remove\n     */\n    async removeWithDelay(nBlocks, cUTXO) {\n        await sleep(nBlocks * 60 * 1000);\n        this.removeUTXO(cUTXO);\n    }\n\n    /**\n     * Check if an exact UTXO match can be found in our wallet\n     * @param {Object} UTXO\n     * @param {String} UTXO.id - Transaction ID\n     * @param {Number} UTXO.vout - Output position of this transaction\n     * @param {Number} [UTXO.status] - UTXO status enum state. If it's undefined, it will ignore it.\n     * @returns {Boolean} `true` or `false`\n     */\n    isAlreadyStored({ id, vout, status }) {\n        return this.UTXOs.some(\n            (cUTXO) =>\n                cUTXO.id === id &&\n                cUTXO.vout === vout &&\n                (!status || cUTXO.status === status)\n        );\n    }\n\n    /**\n     * Fetches an array of UTXOs filtered by their state\n     * @param {Number} nState - Specific UTXO state\n     * @returns {Array<UTXO>} `array` - An array of UTXOs\n     */\n    getUTXOsByState(nState) {\n        return this.UTXOs.filter((cUTXO) => cUTXO.status === nState);\n    }\n\n    /**\n     * Removes a UTXO from a specific state\n     * @param {UTXO} cNewUTXO - Pending UTXO to remove\n     * @param {Number} nState - Specific state of this UTXO to search for\n     */\n    removeFromState(cNewUTXO, nState) {\n        const arrPendingUTXOs = this.getUTXOsByState(nState);\n        // Loop each pending UTXO\n        for (const cUTXO of arrPendingUTXOs) {\n            // Search for matching ID + output number\n            if (cUTXO.id === cNewUTXO.id && cUTXO.vout === cNewUTXO.vout) {\n                // Nuke it from orbit\n                this.removeUTXO(cUTXO);\n                break;\n            }\n        }\n    }\n\n    /**\n     * Add a new UTXO to the wallet\n     * @param {UTXO} UTXO\n     */\n    addUTXO({\n        id,\n        path,\n        sats,\n        script,\n        vin,\n        vout,\n        height,\n        status,\n        isDelegate,\n        isReward,\n    }) {\n        const newUTXO = new UTXO({\n            id,\n            path,\n            sats,\n            script,\n            vin,\n            vout,\n            height,\n            status,\n            isDelegate,\n            isReward,\n        });\n\n        if (this.isAlreadyStored({ id, vout })) {\n            this.updateUTXO({ id, vout });\n        } else {\n            // If this new UTXO is a reward with one vin (i.e: a Stake), we'll backtrace the input\n            if (isReward && vin?.length === 1) {\n                const cStakeInput = this.getUTXO(vin[0].txid, vin[0].vout);\n\n                // And if the input is in our wallet, remove it\n                if (cStakeInput) {\n                    this.removeUTXO(cStakeInput);\n                }\n            }\n            this.UTXOs.push(newUTXO);\n        }\n\n        // Re-render the Balance UIs\n        getBalance(true);\n        getStakingBalance(true);\n    }\n\n    /**\n     * Update an existing UTXO, by confirming its pending status\n     * The UTXO must be in\n     * @param {Object} UTXO - Object to be deconstructed\n     * @param {String} UTXO.id - Transaction id\n     * @param {Number} UTXO.vout - vout\n     */\n    updateUTXO({ id, vout }) {\n        if (debug) {\n            console.assert(\n                this.isAlreadyStored({ id, vout }),\n                'Debug Mode: updateUTXO must be called with an existing UTXO'\n            );\n        }\n        const cUTXO = this.UTXOs.find(\n            (utxo) => utxo.id === id && utxo.vout == vout\n        );\n        switch (cUTXO.status) {\n            case Mempool.PENDING:\n                cUTXO.status = Mempool.CONFIRMED;\n                break;\n        }\n        getBalance(true);\n        getStakingBalance(true);\n    }\n\n    /**\n     * Remove a UTXO completely from our wallet\n     * @param {UTXO} cUTXO - UTXO to remove\n     */\n    removeUTXO(cUTXO) {\n        this.UTXOs = this.UTXOs.filter((utxo) => !utxo.equalsUTXO(cUTXO));\n    }\n\n    /**\n     * Remove a UTXO completely from our wallet, with a 12 minute delay given his id, path and vout\n     * @param {Object} UTXO\n     * @param {String} UTXO.id - Transaction ID\n     * @param {Number} UTXO.vout - Output position of this transaction\n     */\n    autoRemoveUTXO({ id, vout }) {\n        for (const cUTXO of this.UTXOs) {\n            // Loop given + internal UTXOs to find a match, then start the delayed removal\n            if (cUTXO.id === id && cUTXO.vout === vout) {\n                cUTXO.status = Mempool.REMOVED;\n                this.removeWithDelay(12, cUTXO);\n                return;\n            }\n        }\n        console.error(\n            'Mempool: Failed to find UTXO ' +\n                id +\n                ' (' +\n                vout +\n                ') for auto-removal!'\n        );\n    }\n\n    /**\n     * Remove many UTXOs completely from our wallet, with a 12 minute delay\n     * @param {Array<UTXO>} arrUTXOs - UTXOs to remove\n     */\n    autoRemoveUTXOs(arrUTXOs) {\n        for (const cNewUTXO of arrUTXOs) {\n            for (const cUTXO of this.UTXOs) {\n                // Loop given + internal UTXOs to find a match, then start the delayed removal\n                if (cUTXO.equalsUTXO(cNewUTXO)) {\n                    cUTXO.status = Mempool.REMOVED;\n                    this.removeWithDelay(12, cUTXO);\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * Fetches an array of confirmed UTXOs, an easier alias to {@link getUTXOsByState}\n     * @returns {Array<UTXO>} `array` - An array of UTXOs\n     */\n    getConfirmed() {\n        return this.getUTXOsByState(Mempool.CONFIRMED);\n    }\n\n    /**\n     * Get standard, non delegated, UTXOs\n     * @returns {Array<UTXO>} Non delegated utxos\n     */\n    getStandardUTXOs() {\n        return this.UTXOs.filter(\n            (cUTXO) => cUTXO.status !== Mempool.REMOVED && !cUTXO.isDelegate\n        );\n    }\n\n    /**\n     * Get delegated UTXOs\n     * @returns {Array<UTXO>} Delegated UTXOs\n     */\n    getDelegatedUTXOs() {\n        return this.UTXOs.filter(\n            (cUTXO) => cUTXO.status !== Mempool.REMOVED && cUTXO.isDelegate\n        );\n    }\n\n    /**\n     * Returns the real-time balance of the wallet (all addresses)\n     * @returns {Number} Balance in satoshis\n     */\n    getBalance() {\n        // Fetch 'standard' balances: the sum of all Confirmed or Unconfirmed transactions (excluding Masternode collaterals)\n        return this.getStandardUTXOs()\n            .filter((cUTXO) => !isMasternodeUTXO(cUTXO)) // TODO: add masternode\n            .reduce((a, b) => a + b.sats, 0);\n    }\n\n    /**\n     * Returns if a UTXO is valid\n     * @param {UTXO} cUTXO - UTXO\n     * @returns {Boolean} `true` if the reward UTXO is spendable, `false` if not\n     */\n    static isValidUTXO(cUTXO) {\n        if (cUTXO.isReward) {\n            return getNetwork().cachedBlockCount - cUTXO.height > 100;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Returns the real-time delegated balance of the wallet (all addresses)\n     * @returns {Number} Delegated balance in satoshis\n     */\n    getDelegatedBalance() {\n        return this.getDelegatedUTXOs().reduce((a, b) => a + b.sats, 0);\n    }\n\n    /**\n     * Subscribes to network events\n     * @param {Network} network\n     */\n    subscribeToNetwork() {\n        getEventEmitter().on('utxo', async (utxos) => {\n            for (const utxo of utxos) {\n                // If we have the UTXO, we update it's confirmation status\n                if (this.isAlreadyStored({ id: utxo.txid, vout: utxo.vout })) {\n                    this.updateUTXO({ id: utxo.txid, vout: utxo.vout });\n                    continue;\n                }\n                // If the UTXO is new, we'll process it and add it internally\n                this.addUTXO(await getNetwork().getUTXOFullInfo(utxo));\n            }\n        });\n    }\n}\n","import { translation } from './i18n.js';\nimport { doms } from './global.js';\nimport qrcode from 'qrcode-generator';\nimport bs58 from 'bs58';\nimport { bech32 } from 'bech32';\nimport { BIP21_PREFIX, cChainParams } from './chain_params';\nimport { dSHA256 } from './utils.js';\n\n/* MPW constants */\nexport const pubKeyHashNetworkLen = 21;\nexport const pubChksum = 4;\nexport const pubPrebaseLen = pubKeyHashNetworkLen + pubChksum;\n\n// Base58 Encoding Map\nexport const MAP_B58 =\n    '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nexport const LEN_B58 = MAP_B58.length;\n\n/* --- UTILS --- */\n// Cryptographic Random-Gen\nexport function getSafeRand(nSize = 32) {\n    return crypto.getRandomValues(new Uint8Array(nSize));\n}\n\nexport const MAP_ALPHANUMERIC =\n    'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n\n/**\n * Generate a random Alpha-Numeric sequence\n * @param {number} nSize - The amount of characters to generate\n * @returns {string} - A random alphanumeric string of nSize length\n */\nexport function getAlphaNumericRand(nSize = 32) {\n    let result = '';\n    const randValues = getSafeRand(nSize);\n    for (const byte of randValues) {\n        const index = byte % MAP_ALPHANUMERIC.length;\n        result += MAP_ALPHANUMERIC.charAt(index);\n    }\n    return result;\n}\n\n// Writes a sequence of Array-like bytes into a location within a Uint8Array\nexport function writeToUint8(arr, bytes, pos) {\n    const arrLen = arr.length;\n    // Sanity: ensure an overflow cannot occur, if one is detected, somewhere in MPW's state could be corrupted.\n    if (arrLen - pos - bytes.length < 0) {\n        const strERR =\n            'CRITICAL: Overflow detected (' +\n            (arrLen - pos - bytes.length) +\n            '), possible state corruption, backup and refresh advised.';\n        createAlert('warning', strERR, 5000);\n        throw Error(strERR);\n    }\n    let i = 0;\n    while (pos < arrLen) arr[pos++] = bytes[i++];\n}\n\n/** Convert a 2D array into a CSV string */\nexport function arrayToCSV(data) {\n    return data\n        .map(\n            (row) =>\n                row\n                    .map(String) // convert every value to String\n                    .map((v) => v.replaceAll('\"', '\"\"')) // escape double colons\n                    .map((v) => `\"${v}\"`) // quote it\n                    .join(',') // comma-separated\n        )\n        .join('\\r\\n'); // rows starting on new lines\n}\n\n/** Download contents as a file */\nexport function downloadBlob(content, filename, contentType) {\n    // Create a blob\n    const blob = new Blob([content], { type: contentType });\n\n    // Create a link to download it\n    const pom = document.createElement('a');\n    pom.href = URL.createObjectURL(blob);\n    pom.setAttribute('download', filename);\n    pom.click();\n}\n\n/**\n * Create a custom GUI Alert popup\n *\n * ### Do NOT display arbitrary / external errors:\n * - The use of `.innerHTML` allows for input styling at this cost.\n * @param {'success'|'info'|'warning'} type - The styling type of the alert\n * @param {string} message - The message to relay to the user\n * @param {number?} timeout - The time in `ms` until the alert expires (Defaults to never expiring)\n */\nexport function createAlert(type, message, timeout = 0) {\n    const domAlert = document.createElement('div');\n    domAlert.classList.add('notifyWrapper');\n    domAlert.classList.add(type);\n    setTimeout(() => {\n        domAlert.style.opacity = '1';\n        domAlert.style.zIndex = '999999';\n        domAlert.classList.add('bounce-ani');\n        domAlert.classList.add('bounce');\n    }, 100);\n\n    // Colors for types\n    let typeIcon;\n    switch (type) {\n        case 'warning':\n            typeIcon = 'fa-exclamation';\n            break;\n        case 'info':\n            typeIcon = 'fa-info';\n            break;\n        default:\n            // If no valid type is set, default to success\n            type == 'success';\n            typeIcon = 'fa-check';\n            break;\n    }\n\n    // Message\n    domAlert.innerHTML = `\n    <div class=\"notifyIcon notify-${type}\">\n        <i class=\"fas ${typeIcon} fa-xl\"></i>\n    </div>\n    <div class=\"notifyText\">\n        ${message}\n    </div>`;\n    domAlert.destroy = () => {\n        // Fully destroy timers + DOM elements, no memory leaks!\n        clearTimeout(domAlert.timer);\n        domAlert.style.opacity = '0';\n        setTimeout(() => {\n            domAlert.remove();\n        }, 600);\n    };\n    // On Click: Delete alert from DOM after close animation.\n    domAlert.addEventListener('click', domAlert.destroy);\n    // On Timeout: Delete alert from DOM after a period of inactive time.\n    if (timeout > 0) domAlert.timer = setTimeout(domAlert.destroy, timeout);\n    doms.domAlertPos.appendChild(domAlert);\n}\n\n/**\n * Shows a Confirm popup with custom HTML.\n *\n * If `resolvePromise` has a value, the popup won't have\n * Confirm/Cancel buttons and will wait for the promise to resolve.\n *\n * Returns the awaited value of `resolvePromise` or `true/false` if the\n * user used a Cancel/Confirm button.\n * @param {object} options\n * @param {string?} options.title - The optional title of the popup\n * @param {string} options.html - The HTML of the popup contents\n * @param {Promise<any>} options.resolvePromise - A promise to resolve before closing the modal\n * @param {boolean?} options.hideConfirm - Whether to hide the Confirm button or not\n * @param {boolean?} options.purpleModal - Toggle a Purple modal, or leave as false for White\n * @param {boolean?} options.textLeft - Toggle to align modal text to the left, or leave as false for center\n * @param {boolean?} options.noPadding - Toggle zero padding, or leave as false for default padding\n * @param {number?} options.maxHeight - An optional modal Max Height, omit for default modal max\n * @returns {Promise<boolean|any>}\n */\nexport async function confirmPopup({\n    title,\n    html,\n    resolvePromise,\n    hideConfirm,\n    purpleModal,\n    textLeft,\n    noPadding,\n    maxHeight,\n}) {\n    // If there's a title provided: display the header and text\n    doms.domConfirmModalHeader.style.display = title ? 'block' : 'none';\n    doms.domConfirmModalTitle.innerHTML = title || '';\n\n    // If there's a promise to resolve, don't display buttons; the modal visibility will be controlled by the promise (f.e: a 'pls wait' screen)\n    doms.domConfirmModalButtons.style.setProperty(\n        'display',\n        resolvePromise ? 'none' : 'block',\n        resolvePromise ? 'important' : undefined\n    );\n    $('#confirmModal').modal(resolvePromise ? 'show' : { keyboard: false });\n\n    // Show or hide the confirm button, and replace 'Cancel' with 'Close'\n    doms.domConfirmModalConfirmButton.style.display = hideConfirm ? 'none' : '';\n    doms.domConfirmModalCancelButton.innerText = hideConfirm\n        ? translation.popupClose\n        : translation.popupCancel;\n\n    // Set content display\n    doms.domConfirmModalContent.innerHTML = html;\n\n    // Set text align to left\n    if (textLeft) {\n        doms.domConfirmModalContent.classList.remove('center-text');\n    } else {\n        doms.domConfirmModalContent.classList.add('center-text');\n    }\n\n    // Use the purple modal\n    if (purpleModal) {\n        doms.domConfirmModalMain.classList.add('exportKeysModalColor');\n    } else {\n        doms.domConfirmModalMain.classList.remove('exportKeysModalColor');\n    }\n\n    // Remove padding\n    if (noPadding) {\n        doms.domConfirmModalContent.classList.add('px-0');\n        doms.domConfirmModalContent.classList.add('pb-0');\n    } else {\n        doms.domConfirmModalContent.classList.remove('px-0');\n        doms.domConfirmModalContent.classList.remove('pb-0');\n    }\n\n    // Set max-height (removed at `.finally` context)\n    if (maxHeight)\n        doms.domConfirmModalDialog.classList.add(`max-w-${maxHeight}`);\n\n    // If there's an input in the prompt, focus the cursor upon it\n    for (const domElement of doms.domConfirmModalContent.children) {\n        if (domElement.type === 'text' || domElement.type === 'password') {\n            domElement.focus();\n            break;\n        }\n    }\n\n    // Wait for the promise to resolve OR create a new one which resolves upon a modal button click\n    resolvePromise =\n        resolvePromise ||\n        new Promise((res, _) => {\n            doms.domConfirmModalConfirmButton.onclick = () => {\n                res(true);\n            };\n            doms.domConfirmModalCancelButton.onclick = () => {\n                res(false);\n            };\n        });\n    try {\n        return await resolvePromise;\n    } finally {\n        // We want to hide the modal even if an exception occurs\n        $('#confirmModal').modal('hide');\n\n        // Reset any modal settings\n        doms.domConfirmModalDialog.classList.remove(`max-w-${maxHeight}`);\n    }\n}\n\n// Generates and sets a QRCode image from a string and dom element\nexport function createQR(strData = '', domImg, size = 4) {\n    // QRCode class consists of 'typeNumber' & 'errorCorrectionLevel'\n    const cQR = qrcode(size, 'L');\n    cQR.addData(strData);\n    cQR.make();\n    domImg.innerHTML = cQR.createImgTag(2, 2);\n    domImg.firstChild.style.borderRadius = '8px';\n}\n\n/**\n * Prompt image selection, and return base64 of an image file.\n * @returns {Promise<string>} The base64 string of the selected image file.\n */\nexport async function getImageFile() {\n    return new Promise((resolve) => {\n        let input = document.createElement('input');\n        input.type = 'file';\n        input.accept = 'image/*';\n        input.onchange = (e) => {\n            let file = e.target.files[0];\n            let reader = new FileReader();\n            reader.onloadend = () => resolve(reader.result);\n            reader.readAsDataURL(file);\n        };\n        input.click();\n    });\n}\n\n/**\n * A quick check to see if an address is a Standard (P2PKH) address\n * @param {string} strAddress - The address to check\n * @returns {boolean} - `true` if a Standard address, `false` if not\n */\nexport function isStandardAddress(strAddress) {\n    return (\n        strAddress.length === 34 &&\n        cChainParams.current.PUBKEY_PREFIX.includes(strAddress[0])\n    );\n}\n\n/**\n * A quick check to see if a string is an XPub key\n * @param {string} strXPub - The XPub to check\n * @returns {boolean} - `true` if a valid formatted XPub, `false` if not\n */\nexport function isXPub(strXPub) {\n    if (!strXPub.startsWith('xpub')) return false;\n\n    // Attempt to Base58 decode the XPub\n    try {\n        // Slice away the `xpub` prefix and decode\n        const decoded = bs58.decode(strXPub.slice(4));\n\n        // Then verify the final length too\n        return decoded.length === 78;\n    } catch (e) {\n        return false;\n    }\n}\n\n/**\n * Attempt to safely parse a BIP21 Payment Request\n * @param {string} strReq - BIP21 Payment Request string\n * @returns {object | false}\n */\nexport function parseBIP21Request(strReq) {\n    // Format should match: pivx:addr[?amount=x&label=x]\n    if (!strReq.includes(BIP21_PREFIX + ':')) return false;\n\n    const [addressPart, optionsPart] = strReq.includes('?')\n        ? strReq.split('?')\n        : [strReq, false];\n    const strAddress = addressPart.substring(BIP21_PREFIX.length + 1); // remove 'pivx:' prefix\n    let cOptions = {};\n\n    // Ensure the address is valid\n    if (\n        // Standard address\n        !isStandardAddress(strAddress) &&\n        // Shield address\n        !isValidBech32(strAddress).valid\n    ) {\n        return false;\n    }\n\n    if (optionsPart) {\n        cOptions = Object.fromEntries(\n            optionsPart\n                .split('&')\n                .map((opt) => opt.split('=').map(decodeURIComponent))\n        );\n    }\n\n    return { address: strAddress, options: cOptions };\n}\n\n/**\n * @typedef {object} Bech32Check\n * @property {boolean} valid - If the string is a valid bech32 address\n * @property {object} res - The results of the bech32 decoding\n */\n\n/**\n * A safe bech32 wrapper for quickly checking if an address is valid\n * @param {string} str - Bech32 Address\n * @returns {Bech32Check} - Both the validity and decoding results\n */\nexport function isValidBech32(str) {\n    try {\n        return { valid: true, res: bech32.decode(str) };\n    } catch (e) {\n        return { valid: false, res: e };\n    }\n}\n\n/**\n * Generate an encoded private key for masternodes\n */\nexport function generateMasternodePrivkey() {\n    // Prefix the network byte with the private key (32 random bytes)\n    const data = [cChainParams.current.SECRET_KEY, ...getSafeRand(32)];\n\n    // Compute and concatenate the checksum, then encode the private key as Base58\n    return bs58.encode([...data, ...dSHA256(data).slice(0, 4)]);\n}\n\nexport function sanitizeHTML(text) {\n    const element = document.createElement('div');\n    element.innerText = text;\n    return element.innerHTML;\n}\n\n/**\n * \"Beautifies\" a number with HTML, by displaying decimals in a lower opacity\n * @param {string} strNumber - The number in String form to beautify\n * @param {string?} strDecFontSize - The optional font size to display decimals in\n * @returns {string} - A HTML string with beautified number handling\n */\nexport function beautifyNumber(strNumber, strDecFontSize = '') {\n    if (typeof strNumber === 'number') strNumber = strNumber.toString();\n\n    // Only run this for numbers with decimals\n    if (!strNumber.includes('.')) return strNumber;\n\n    // Split the number in to Full and Decimal parts\n    const arrNumParts = strNumber.split('.');\n\n    // Return a HTML that renders the decimal in a lower opacity\n    const strFontSize = strDecFontSize ? 'font-size: ' + strDecFontSize : '';\n    return `${arrNumParts[0]}<span style=\"opacity: 0.55; ${strFontSize}\">.${arrNumParts[1]}</span>`;\n}\n\n/**\n * Check if a string is valid Base64 encoding\n * @param {string} str - String to check\n * @returns {boolean}\n */\nexport function isBase64(str) {\n    const base64Regex = /^[A-Za-z0-9+/=]+$/;\n\n    // Check if the string contains only Base64 characters:\n    if (!base64Regex.test(str)) {\n        return false;\n    }\n\n    // Check if the length is a multiple of 4 (required for Base64):\n    if (str.length % 4 !== 0) {\n        return false;\n    }\n\n    // Try decoding the Base64 string to check for errors:\n    try {\n        atob(str);\n    } catch (e) {\n        return false;\n    }\n\n    // The string is likely Base64-encoded:\n    return true;\n}\n\n/**\n * Checks if two values are of the same type.\n *\n * @param {any} a - The first value.\n * @param {any} b - The second value.\n * @returns {boolean} - `true` if the values are of the same type, `false` if not or if there was an error comparing.\n */\nexport function isSameType(a, b) {\n    try {\n        if (a === null || b === null) return a === b;\n        if (typeof a !== typeof b) return false;\n        if (typeof a === 'object')\n            return Object.getPrototypeOf(a) === Object.getPrototypeOf(b);\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\n\n/**\n * Checks if a value is 'empty'.\n *\n * @param {any} val - The value to check.\n * @returns {boolean} - `true` if the value is 'empty', `false` otherwise.\n * ---\n * Values **considered 'empty'**: `null`, `undefined`, empty strings, empty arrays, empty objects.\n *\n * Values **NOT considered 'empty'**: Any non-nullish primitive value: numbers (including `0` and `NaN`), `true`, `false`, `Symbol()`, `BigInt()`.\n */\nexport function isEmpty(val) {\n    return (\n        val == null ||\n        val === '' ||\n        (Array.isArray(val) && val.length === 0) ||\n        (typeof val === 'object' && Object.keys(val).length === 0)\n    );\n}\n\n/**\n * An artificial sleep function to pause code execution\n *\n * @param {Number} ms - The milliseconds to sleep\n *\n * @example\n * // Pause an asynchronous script for 1 second\n * await sleep(1000);\n */\nexport function sleep(ms) {\n    return new Promise((res, _) => setTimeout(res, ms));\n}\n","import { Mempool } from './mempool.js';\nimport Masternode from './masternode.js';\nimport { ALERTS, tr, start as i18nStart, translation } from './i18n.js';\nimport * as jdenticon from 'jdenticon';\nimport {\n    wallet,\n    hasEncryptedWallet,\n    importWallet,\n    decryptWallet,\n    getNewAddress,\n} from './wallet.js';\nimport { LegacyMasterKey } from './masterkey.js';\nimport { getNetwork, HistoricalTxType } from './network.js';\nimport {\n    start as settingsStart,\n    cExplorer,\n    debug,\n    cMarket,\n    strCurrency,\n    setColdStakingAddress,\n    strColdStakingAddress,\n    nDisplayDecimals,\n    fAdvancedMode,\n} from './settings.js';\nimport { createAndSendTransaction, signTransaction } from './transactions.js';\nimport {\n    createAlert,\n    confirmPopup,\n    sanitizeHTML,\n    MAP_B58,\n    parseBIP21Request,\n    isValidBech32,\n    isBase64,\n    sleep,\n    beautifyNumber,\n    isStandardAddress,\n} from './misc.js';\nimport { cChainParams, COIN, MIN_PASS_LENGTH } from './chain_params.js';\nimport { decrypt } from './aes-gcm.js';\n\nimport { registerWorker } from './native.js';\nimport { refreshPriceDisplay } from './prices.js';\nimport { Address6 } from 'ip-address';\nimport { getEventEmitter } from './event_bus.js';\nimport { scanQRCode } from './scanner.js';\nimport { Database } from './database.js';\nimport bitjs from './bitTrx.js';\nimport { checkForUpgrades } from './changelog.js';\nimport { FlipDown } from './flipdown.js';\nimport { createApp } from 'vue';\nimport Activity from './Activity.vue';\nimport {\n    cReceiveType,\n    guiAddContactPrompt,\n    guiCheckRecipientInput,\n    guiToggleReceiveType,\n} from './contacts-book.js';\nimport { Buffer } from 'buffer';\nimport { Account } from './accounts.js';\n\n/** A flag showing if base MPW is fully loaded or not */\nexport let fIsLoaded = false;\n\n/** A getter for the flag showing if base MPW is fully loaded or not */\nexport function isLoaded() {\n    return fIsLoaded;\n}\n\nexport let doms = {};\n\n// For now we'll import the component as a vue app by itself. Later, when the\n// dashboard is rewritten in vue, we can simply add <Activity /> to the dashboard component template.\nexport const activityDashboard = createApp(Activity, {\n    title: 'Activity',\n    rewards: false,\n}).mount('#activityDashboard');\n\nexport const stakingDashboard = createApp(Activity, {\n    title: 'Reward History',\n    rewards: true,\n}).mount('#stakeActivity');\n\nexport async function start() {\n    doms = {\n        domNavbarToggler: document.getElementById('navbarToggler'),\n        domDashboard: document.getElementById('dashboard'),\n        domGuiWallet: document.getElementById('guiWallet'),\n        domGettingStartedBtn: document.getElementById('gettingStartedBtn'),\n        domGuiBalance: document.getElementById('guiBalance'),\n        domGuiBalanceTicker: document.getElementById('guiBalanceTicker'),\n        domGuiBalanceValue: document.getElementById('guiBalanceValue'),\n        domGuiBalanceValueCurrency: document.getElementById(\n            'guiBalanceValueCurrency'\n        ),\n        domGuiStakingValue: document.getElementById('guiStakingValue'),\n        domGuiStakingValueCurrency: document.getElementById(\n            'guiStakingValueCurrency'\n        ),\n        domBalanceReload: document.getElementById('balanceReload'),\n        domBalanceReloadStaking: document.getElementById(\n            'balanceReloadStaking'\n        ),\n        domGuiBalanceStaking: document.getElementById('guiBalanceStaking'),\n        domGuiBalanceStakingTicker: document.getElementById(\n            'guiBalanceStakingTicker'\n        ),\n        domStakeAmount: document.getElementById('delegateAmount'),\n        domUnstakeAmount: document.getElementById('undelegateAmount'),\n        domStakeTab: document.getElementById('stakeTab'),\n        domAddress1s: document.getElementById('address1s'),\n        domSendAmountCoins: document.getElementById('sendAmountCoins'),\n        domSendAmountCoinsTicker: document.getElementById(\n            'sendAmountCoinsTicker'\n        ),\n        domSendAmountValue: document.getElementById('sendAmountValue'),\n        domSendAmountValueCurrency: document.getElementById(\n            'sendAmountValueCurrency'\n        ),\n        domStakeAmountCoinsTicker: document.getElementById(\n            'stakeAmountCoinsTicker'\n        ),\n        domStakeAmountValueCurrency: document.getElementById(\n            'stakeAmountValueCurrency'\n        ),\n        domStakeAmountValue: document.getElementById('stakeAmountValue'),\n        domUnstakeAmountCoinsTicker: document.getElementById(\n            'unstakeAmountCoinsTicker'\n        ),\n        domUnstakeAmountValueCurrency: document.getElementById(\n            'unstakeAmountValueCurrency'\n        ),\n\n        domUnstakeAmountValue: document.getElementById('unstakeAmountValue'),\n        domModalQR: document.getElementById('ModalQR'),\n        domModalQrLabel: document.getElementById('ModalQRLabel'),\n        domModalQrReceiveTypeBtn: document.getElementById(\n            'ModalQRReceiveTypeBtn'\n        ),\n        domModalQRReader: document.getElementById('qrReaderModal'),\n        domQrReaderStream: document.getElementById('qrReaderStream'),\n        domCloseQrReaderBtn: document.getElementById('closeQrReader'),\n        domModalWalletBreakdown: document.getElementById(\n            'walletBreakdownModal'\n        ),\n        domWalletBreakdownCanvas: document.getElementById(\n            'walletBreakdownCanvas'\n        ),\n        domPrefix: document.getElementById('prefix'),\n        domPrefixNetwork: document.getElementById('prefixNetwork'),\n        domWalletToggle: document.getElementById('wToggle'),\n        domGenerateWallet: document.getElementById('generateWallet'),\n        domGenVanityWallet: document.getElementById('generateVanityWallet'),\n        domGenHardwareWallet: document.getElementById('generateHardwareWallet'),\n        //GOVERNANCE ELEMENTS\n        domGovTab: document.getElementById('governanceTab'),\n        domGovProposalsTable: document.getElementById('proposalsTable'),\n        domGovProposalsTableBody: document.getElementById('proposalsTableBody'),\n        domTotalGovernanceBudget: document.getElementById(\n            'totalGovernanceBudget'\n        ),\n        domTotalGovernanceBudgetValue: document.getElementById(\n            'totalGovernanceBudgetValue'\n        ),\n        domAllocatedGovernanceBudget: document.getElementById(\n            'allocatedGovernanceBudget'\n        ),\n        domAllocatedGovernanceBudgetValue: document.getElementById(\n            'allocatedGovernanceBudgetValue'\n        ),\n        domAllocatedGovernanceBudget2: document.getElementById(\n            'allocatedGovernanceBudget2'\n        ),\n        domAllocatedGovernanceBudgetValue2: document.getElementById(\n            'allocatedGovernanceBudgetValue2'\n        ),\n        domGovProposalsContestedTable: document.getElementById(\n            'proposalsContestedTable'\n        ),\n        domGovProposalsContestedTableBody: document.getElementById(\n            'proposalsContestedTableBody'\n        ),\n        //MASTERNODE ELEMENTS\n        domCreateMasternode: document.getElementById('createMasternode'),\n        domControlMasternode: document.getElementById('controlMasternode'),\n        domAccessMasternode: document.getElementById('accessMasternode'),\n        domMnAccessMasternodeText: document.getElementById(\n            'accessMasternodeText'\n        ),\n        domMnCreateType: document.getElementById('mnCreateType'),\n        domMnTextErrors: document.getElementById('mnTextErrors'),\n        domMnIP: document.getElementById('mnIP'),\n        domMnTxId: document.getElementById('mnTxId'),\n        domMnPrivateKey: document.getElementById('mnPrivateKey'),\n        domMnDashboard: document.getElementById('mnDashboard'),\n        domMnProtocol: document.getElementById('mnProtocol'),\n        domMnStatus: document.getElementById('mnStatus'),\n        domMnNetType: document.getElementById('mnNetType'),\n        domMnNetIP: document.getElementById('mnNetIP'),\n        domMnLastSeen: document.getElementById('mnLastSeen'),\n\n        domAccessWallet: document.getElementById('accessWallet'),\n        domImportWallet: document.getElementById('importWallet'),\n        domImportWalletText: document.getElementById('importWalletText'),\n        domAccessWalletBtn: document.getElementById('accessWalletBtn'),\n        domVanityUiButtonTxt: document.getElementById('vanButtonText'),\n        domGenKeyWarning: document.getElementById('genKeyWarning'),\n        domEncryptWalletLabel: document.getElementById('encryptWalletLabel'),\n        domEncryptPasswordCurrent: document.getElementById(\n            'changePassword-current'\n        ),\n        domEncryptPasswordBox: document.getElementById('encryptPassword'),\n        domEncryptPasswordFirst: document.getElementById('newPassword'),\n        domEncryptPasswordSecond: document.getElementById('newPasswordRetype'),\n        domGenIt: document.getElementById('genIt'),\n        domReqDesc: document.getElementById('reqDesc'),\n        domReqDisplay: document.getElementById('reqDescDisplay'),\n        domIdenticon: document.getElementById('identicon'),\n        domPrivKey: document.getElementById('privateKey'),\n        domPrivKeyPassword: document.getElementById('privateKeyPassword'),\n        domAvailToDelegate: document.getElementById('availToDelegate'),\n        domAvailToUndelegate: document.getElementById('availToUndelegate'),\n        domAnalyticsDescriptor: document.getElementById('analyticsDescriptor'),\n        domMnemonicModalContent: document.getElementById(\n            'ModalMnemonicContent'\n        ),\n        domMnemonicModalButton: document.getElementById(\n            'modalMnemonicConfirmButton'\n        ),\n        domMnemonicModalPassphrase: document.getElementById(\n            'ModalMnemonicPassphrase'\n        ),\n        domExportPrivateKey: document.getElementById('exportPrivateKeyText'),\n        domExportWallet: document.getElementById('guiExportWalletItem'),\n        domWipeWallet: document.getElementById('guiWipeWallet'),\n        domRestoreWallet: document.getElementById('guiRestoreWallet'),\n        domNewAddress: document.getElementById('guiNewAddress'),\n        domRedeemTitle: document.getElementById('redeemCodeModalTitle'),\n        domRedeemCodeUse: document.getElementById('redeemCodeUse'),\n        domRedeemCodeCreate: document.getElementById('redeemCodeCreate'),\n        domRedeemCodeGiftIconBox: document.getElementById(\n            'redeemCodeGiftIconBox'\n        ),\n        domRedeemCodeGiftIcon: document.getElementById('redeemCodeGiftIcon'),\n        domRedeemCodeETA: document.getElementById('redeemCodeETA'),\n        domRedeemCodeProgress: document.getElementById('redeemCodeProgress'),\n        domRedeemCodeInputBox: document.getElementById('redeemCodeInputBox'),\n        domRedeemCodeInput: document.getElementById('redeemCodeInput'),\n        domRedeemCodeConfirmBtn: document.getElementById(\n            'redeemCodeModalConfirmButton'\n        ),\n        domRedeemCodeModeRedeemBtn: document.getElementById(\n            'redeemCodeModeRedeem'\n        ),\n        domRedeemCodeModeCreateBtn: document.getElementById(\n            'redeemCodeModeCreate'\n        ),\n        domRedeemCodeCreateInput: document.getElementById(\n            'redeemCodeCreateInput'\n        ),\n        domRedeemCodeCreateAmountInput: document.getElementById(\n            'redeemCodeCreateAmountInput'\n        ),\n        domRedeemCodeCreatePendingList: document.getElementById(\n            'redeemCodeCreatePendingList'\n        ),\n        domPromoTable: document.getElementById('promo-table'),\n        domContactsTable: document.getElementById('contactsList'),\n        domActivityList: document.getElementById('activity-list-content'),\n        domActivityLoadMore: document.getElementById('activityLoadMore'),\n        domActivityLoadMoreIcon: document.getElementById(\n            'activityLoadMoreIcon'\n        ),\n        domConfirmModalDialog: document.getElementById('confirmModalDialog'),\n        domConfirmModalMain: document.getElementById('confirmModalMain'),\n        domConfirmModalHeader: document.getElementById('confirmModalHeader'),\n        domConfirmModalTitle: document.getElementById('confirmModalTitle'),\n        domConfirmModalContent: document.getElementById('confirmModalContent'),\n        domConfirmModalButtons: document.getElementById('confirmModalButtons'),\n        domConfirmModalConfirmButton: document.getElementById(\n            'confirmModalConfirmButton'\n        ),\n        domConfirmModalCancelButton: document.getElementById(\n            'confirmModalCancelButton'\n        ),\n\n        masternodeLegacyAccessText:\n            'Access the masternode linked to this address<br> Note: the masternode MUST have been already created (however it can be online or offline)<br>  If you want to create a new masternode access with a HD wallet',\n        masternodeHDAccessText:\n            \"Access your masternodes if you have any! If you don't you can create one\",\n        // Aggregate menu screens and links for faster switching\n        arrDomScreens: document.getElementsByClassName('tabcontent'),\n        arrDomScreenLinks: document.getElementsByClassName('tablinks'),\n        // Alert DOM element\n        domAlertPos: document.getElementsByClassName('alertPositioning')[0],\n        domNetwork: document.getElementById('Network'),\n        domChangePasswordContainer: document.getElementById(\n            'changePassword-container'\n        ),\n        domDebug: document.getElementById('Debug'),\n        domTestnet: document.getElementById('Testnet'),\n        domCurrencySelect: document.getElementById('currency'),\n        domExplorerSelect: document.getElementById('explorer'),\n        domNodeSelect: document.getElementById('node'),\n        domAutoSwitchToggle: document.getElementById('autoSwitchToggler'),\n        domTranslationSelect: document.getElementById('translation'),\n        domDisplayDecimalsSlider: document.getElementById('displayDecimals'),\n        domDisplayDecimalsSliderDisplay:\n            document.getElementById('sliderDisplay'),\n        domBlackBack: document.getElementById('blackBack'),\n        domWalletSettings: document.getElementById('settingsWallet'),\n        domDisplaySettings: document.getElementById('settingsDisplay'),\n        domWalletSettingsBtn: document.getElementById('settingsWalletBtn'),\n        domDisplaySettingsBtn: document.getElementById('settingsDisplayBtn'),\n        domVersion: document.getElementById('version'),\n        domFlipdown: document.getElementById('flipdown'),\n        domTestnetToggler: document.getElementById('testnetToggler'),\n        domAdvancedModeToggler: document.getElementById('advancedModeToggler'),\n    };\n\n    await i18nStart();\n    await loadImages();\n\n    // Enable all Bootstrap Tooltips\n    $(function () {\n        $('#displayDecimals').tooltip({\n            template:\n                '<div class=\"tooltip sliderStyle\" role=\"tooltip\"><div class=\"arrow\"></div><div class=\"tooltip-inner\"></div></div>',\n        });\n        $('[data-toggle=\"tooltip\"]').tooltip();\n    });\n\n    // Set decimal slider event\n    const sliderElement = document.getElementById('displayDecimals');\n    function handleDecimalSlider() {\n        setTimeout(() => {\n            try {\n                if (window.innerWidth > 991) {\n                    const sliderHalf = Math.round(\n                        document\n                            .getElementById('displayDecimals')\n                            .getBoundingClientRect().width / 2\n                    );\n                    const sliderBegin = -sliderHalf + 28;\n                    const stepVal = (sliderHalf * 2) / 8 - 6.45;\n                    const sliderValue = parseInt(sliderElement.value) + 1;\n\n                    document.querySelector('.sliderStyle').style.left = `${\n                        sliderBegin - stepVal + stepVal * sliderValue\n                    }px`;\n                    document.querySelector('.tooltip-inner').innerHTML =\n                        sliderValue - 1;\n                }\n            } catch (e) {}\n        }, 10);\n    }\n    sliderElement.addEventListener('input', handleDecimalSlider);\n    sliderElement.addEventListener('mouseover', handleDecimalSlider);\n\n    // Register Input Pair events\n    doms.domSendAmountCoins.oninput = () => {\n        updateAmountInputPair(\n            doms.domSendAmountCoins,\n            doms.domSendAmountValue,\n            true\n        );\n    };\n    doms.domSendAmountValue.oninput = () => {\n        updateAmountInputPair(\n            doms.domSendAmountCoins,\n            doms.domSendAmountValue,\n            false\n        );\n    };\n\n    /** Staking (Stake) */\n    doms.domStakeAmount.oninput = () => {\n        updateAmountInputPair(\n            doms.domStakeAmount,\n            doms.domStakeAmountValue,\n            true\n        );\n    };\n    doms.domStakeAmountValue.oninput = () => {\n        updateAmountInputPair(\n            doms.domStakeAmount,\n            doms.domStakeAmountValue,\n            false\n        );\n    };\n\n    /** Staking (Unstake) */\n    doms.domUnstakeAmount.oninput = () => {\n        updateAmountInputPair(\n            doms.domUnstakeAmount,\n            doms.domUnstakeAmountValue,\n            true\n        );\n    };\n    doms.domUnstakeAmountValue.oninput = () => {\n        updateAmountInputPair(\n            doms.domUnstakeAmount,\n            doms.domUnstakeAmountValue,\n            false\n        );\n    };\n\n    // Register native app service\n    registerWorker();\n\n    // Configure Identicon\n    jdenticon.configure();\n\n    // URL-Query request processing\n    const urlParams = new URLSearchParams(window.location.search);\n\n    // Check for a payment request address\n    const reqTo = urlParams.has('pay') ? urlParams.get('pay') : '';\n\n    // Check for a payment request amount\n    const reqAmount = urlParams.has('amount')\n        ? parseFloat(urlParams.get('amount'))\n        : 0;\n    await settingsStart();\n\n    // Customise the UI if a saved wallet exists\n    if (await hasEncryptedWallet()) {\n        // Hide the 'Generate wallet' buttons\n        doms.domGenerateWallet.style.display = 'none';\n        doms.domGenVanityWallet.style.display = 'none';\n        const database = await Database.getInstance();\n        const { publicKey } = await database.getAccount();\n\n        // Import the wallet, and toggle the startup flag, which delegates the chain data refresh to settingsStart();\n        if (publicKey) {\n            await importWallet({ newWif: publicKey, fStartup: true });\n\n            // Update the \"Receive\" UI to apply Translation and Contacts updates\n            await guiToggleReceiveType(cReceiveType);\n\n            // Check for Add Contact calls\n            if (urlParams.has('addcontact')) {\n                // Quick sanity check\n                const strURI = urlParams.get('addcontact');\n                if (strURI.includes(':')) {\n                    // Split to 'name' and 'pubkey'\n                    const arrParts = strURI.split(':');\n\n                    // Convert Name from HEX to UTF-8\n                    const strName = Buffer.from(arrParts[0], 'hex').toString(\n                        'utf8'\n                    );\n                    const strPubkey = arrParts[1];\n\n                    // Prompt the user to add the Contact\n                    guiAddContactPrompt(sanitizeHTML(strName), strPubkey);\n                }\n            } else if (reqTo.length || reqAmount > 0) {\n                // Payment processor popup\n                guiPreparePayment(\n                    reqTo,\n                    reqAmount,\n                    urlParams.has('desc') ? urlParams.get('desc') : ''\n                );\n            }\n        } else {\n            // Display the password unlock upfront\n            await accessOrImportWallet();\n        }\n    } else {\n        // Just load the block count, for use in non-wallet areas\n        getNetwork().getBlockCount();\n    }\n\n    subscribeToNetworkEvents();\n\n    doms.domPrefix.value = '';\n    doms.domPrefixNetwork.innerText =\n        cChainParams.current.PUBKEY_PREFIX.join(' or ');\n    // If allowed by settings: submit a simple 'hit' (app load) to Labs Analytics\n    getNetwork().submitAnalytics('hit');\n    setInterval(() => {\n        // Refresh blockchain data\n        refreshChainData();\n\n        // Fetch the PIVX prices\n        refreshPriceDisplay();\n    }, 15000);\n\n    // After reaching here; we know MPW's base is fully loaded!\n    fIsLoaded = true;\n\n    // Check for recent upgrades, display the changelog\n    checkForUpgrades();\n\n    // If we haven't already (due to having no wallet, etc), display the Dashboard\n    doms.domDashboard.click();\n\n    // Update the Encryption UI (If the user has a wallet, then it changes to \"Change Password\" rather than \"Encrypt Wallet\")\n    await updateEncryptionGUI();\n}\n\nfunction subscribeToNetworkEvents() {\n    getEventEmitter().on('network-toggle', (value) => {\n        doms.domNetwork.innerHTML =\n            '<i class=\"fa-solid fa-' + (value ? 'wifi' : 'ban') + '\"></i>';\n    });\n\n    getEventEmitter().on('sync-status', (value) => {\n        switch (value) {\n            case 'start':\n                // Play reload anim\n                doms.domBalanceReload.classList.add('playAnim');\n                doms.domBalanceReloadStaking.classList.add('playAnim');\n                break;\n            case 'stop':\n                doms.domBalanceReload.classList.remove('playAnim');\n                doms.domBalanceReloadStaking.classList.remove('playAnim');\n                break;\n        }\n    });\n\n    getEventEmitter().on('transaction-sent', (success, result) => {\n        if (success) {\n            doms.domAddress1s.value = '';\n            doms.domSendAmountCoins.innerHTML = '';\n            createAlert(\n                'success',\n                `${ALERTS.TX_SENT}<br>${sanitizeHTML(result)}`,\n                result ? 1250 + result.length * 50 : 3000\n            );\n            // If allowed by settings: submit a simple 'tx' ping to Labs Analytics\n            getNetwork().submitAnalytics('transaction');\n        } else {\n            console.error('Error sending transaction:');\n            console.error(result);\n            createAlert('warning', ALERTS.TX_FAILED, 2500);\n        }\n    });\n}\n\n// WALLET STATE DATA\nexport const mempool = new Mempool();\nlet exportHidden = false;\nlet isTestnetLastState = cChainParams.current.isTestnet;\n\n/**\n * @type {FlipDown | null}\n */\nlet governanceFlipdown = null;\n\n/**\n * Open a UI 'tab' menu, and close all other tabs, intended for frontend use\n * @param {Event} evt - The click event target\n * @param {string} tabName - The name of the tab to load\n */\nexport function openTab(evt, tabName) {\n    // Only allow switching tabs if MPw is loaded\n    if (!isLoaded()) return;\n\n    // Hide all screens and deactivate link highlights\n    for (const domScreen of doms.arrDomScreens)\n        domScreen.style.display = 'none';\n    for (const domLink of doms.arrDomScreenLinks)\n        domLink.classList.remove('active');\n\n    // Show and activate the given screen\n    document.getElementById(tabName).style.display = 'block';\n    evt.currentTarget.classList.add('active');\n\n    // Close the navbar if it's not already closed\n    if (!doms.domNavbarToggler.className.includes('collapsed'))\n        doms.domNavbarToggler.click();\n\n    if (tabName === 'Governance') {\n        updateGovernanceTab();\n    } else if (tabName === 'Masternode') {\n        updateMasternodeTab();\n    } else if (\n        tabName === 'StakingTab' &&\n        stakingDashboard.getTxCount() === 0\n    ) {\n        // Refresh the TX list\n        stakingDashboard.update(false);\n    } else if (\n        tabName === 'keypair' &&\n        getNetwork().arrTxHistory.length === 0\n    ) {\n        // Refresh the TX list\n        activityDashboard.update(false);\n    }\n}\n\n/**\n * Updates the GUI ticker among all elements; useful for Network Switching\n */\nexport function updateTicker() {\n    // Update the Dashboard currency\n    doms.domGuiBalanceValueCurrency.innerText = strCurrency.toUpperCase();\n\n    // Update the Stake Dashboard currency\n    doms.domGuiStakingValueCurrency.innerText = strCurrency.toUpperCase();\n\n    // Update the Send menu ticker and currency\n    doms.domSendAmountValueCurrency.innerText = strCurrency.toUpperCase();\n    doms.domSendAmountCoinsTicker.innerText = cChainParams.current.TICKER;\n\n    // Update the Stake/Unstake menu ticker and currency\n    // Stake\n    doms.domStakeAmountValueCurrency.innerText = strCurrency.toUpperCase();\n    doms.domStakeAmountCoinsTicker.innerText = cChainParams.current.TICKER;\n\n    // Unstake\n    doms.domUnstakeAmountValueCurrency.innerText = strCurrency.toUpperCase();\n    doms.domUnstakeAmountCoinsTicker.innerText = cChainParams.current.TICKER;\n}\n\n/**\n * Return locale settings best for displaying the user-selected currency\n * @param {Number} nAmount - The amount in Currency\n */\nexport function optimiseCurrencyLocale(nAmount) {\n    // Allow manipulating the value, if necessary\n    let nValue = nAmount;\n\n    // Find the best fitting native-locale\n    const cLocale = Intl.supportedValuesOf('currency').includes(\n        strCurrency.toUpperCase()\n    )\n        ? {\n              style: 'currency',\n              currency: strCurrency,\n              currencyDisplay: 'narrowSymbol',\n          }\n        : { maximumFractionDigits: 8, minimumFractionDigits: 8 };\n\n    // Catch display edge-cases; like Satoshis having decimals.\n    switch (strCurrency) {\n        case 'sats':\n            nValue = Math.round(nValue);\n            cLocale.maximumFractionDigits = 0;\n            cLocale.minimumFractionDigits = 0;\n    }\n\n    // Return display-optimised Value and Locale pair.\n    return { nValue, cLocale };\n}\n\n/**\n * Update a 'price value' DOM display for the given balance type\n * @param {HTMLElement} domValue\n * @param {boolean} fCold\n */\nexport async function updatePriceDisplay(domValue, fCold = false) {\n    // Update currency values\n    const nPrice = await cMarket.getPrice(strCurrency);\n\n    if (nPrice) {\n        // Calculate the value\n        const nCurrencyValue =\n            ((fCold ? getStakingBalance() : getBalance()) / COIN) * nPrice;\n\n        const { nValue, cLocale } = optimiseCurrencyLocale(nCurrencyValue);\n\n        // Update the DOM\n        domValue.innerText = nValue.toLocaleString('en-gb', cLocale);\n    }\n}\n\nexport function getBalance(updateGUI = false) {\n    const nBalance = mempool.getBalance();\n    const nCoins = nBalance / COIN;\n\n    // Update the GUI too, if chosen\n    if (updateGUI) {\n        // Set the balance, and adjust font-size for large balance strings\n        const strBal = nCoins.toFixed(nDisplayDecimals);\n        const nLen = strBal.length;\n        doms.domGuiBalance.innerHTML = beautifyNumber(\n            strBal,\n            nLen >= 10 ? '17px' : '25px'\n        );\n        doms.domAvailToDelegate.innerHTML =\n            beautifyNumber(strBal) + ' ' + cChainParams.current.TICKER;\n\n        // Update tickers\n        updateTicker();\n\n        // Update price displays\n        updatePriceDisplay(doms.domGuiBalanceValue);\n    }\n\n    return nBalance;\n}\n\nexport function getStakingBalance(updateGUI = false) {\n    const nBalance = mempool.getDelegatedBalance();\n    const nCoins = nBalance / COIN;\n\n    if (updateGUI) {\n        // Set the balance, and adjust font-size for large balance strings\n        const strBal = nCoins.toFixed(nDisplayDecimals);\n        const nLen = strBal.length;\n        doms.domGuiBalanceStaking.innerHTML = beautifyNumber(\n            strBal,\n            nLen >= 10 ? '17px' : '25px'\n        );\n        doms.domAvailToUndelegate.innerHTML =\n            beautifyNumber(strBal) + ' ' + cChainParams.current.TICKER;\n\n        // Update tickers\n        updateTicker();\n\n        // Update price displays\n        updatePriceDisplay(doms.domGuiStakingValue, true);\n    }\n\n    return nBalance;\n}\n\n/**\n * Fill a 'Coin Amount' with all of a balance type, and update the 'Coin Value'\n * @param {HTMLInputElement} domCoin - The 'Coin Amount' input element\n * @param {HTMLInputElement} domValue - Th 'Coin Value' input element\n * @param {boolean} fCold - Use the Cold Staking balance, or Available balance\n */\nexport function selectMaxBalance(domCoin, domValue, fCold = false) {\n    domCoin.value = (fCold ? getStakingBalance() : getBalance()) / COIN;\n    // Update the Send menu's value (assumption: if it's not a Cold balance, it's probably for Sending!)\n    updateAmountInputPair(domCoin, domValue, true);\n}\n\n/**\n * Prompt a QR scan for a Payment (Address or BIP21)\n */\nexport async function openSendQRScanner() {\n    const cScan = await scanQRCode();\n\n    if (!cScan || !cScan.data) return;\n\n    /* Check what data the scan contains - for the various QR request types */\n\n    // Plain address (Length and prefix matches)\n    if (isStandardAddress(cScan.data)) {\n        return guiPreparePayment(cScan.data);\n    }\n\n    // Shield address (Valid bech32 string)\n    if (isValidBech32(cScan.data).valid) {\n        return guiPreparePayment(cScan.data);\n    }\n\n    // BIP21 Payment Request (Optional 'amount' and 'label')\n    const cBIP21Req = parseBIP21Request(cScan.data);\n    if (cBIP21Req) {\n        return guiPreparePayment(\n            cBIP21Req.address,\n            cBIP21Req.options.amount || 0,\n            cBIP21Req.options.label || ''\n        );\n    }\n\n    // MPW Contact Request URI\n    if (cScan.data.includes('addcontact=')) {\n        // Parse as URL Params\n        const cURL = new URL(cScan.data);\n        const urlParams = new URLSearchParams(cURL.search);\n        const strURI = urlParams.get('addcontact');\n\n        // Sanity check the URI\n        if (strURI?.includes(':')) {\n            // Split to 'name' and 'pubkey'\n            const arrParts = strURI.split(':');\n\n            // If the wallet is encrypted, prompt the user to (optionally) add the Contact, before the Tx\n            const fUseName = (await hasEncryptedWallet())\n                ? await guiAddContactPrompt(\n                      sanitizeHTML(arrParts[0]),\n                      arrParts[1],\n                      false\n                  )\n                : false;\n\n            // Prompt for payment\n            return guiPreparePayment(fUseName ? arrParts[0] : arrParts[1]);\n        }\n    }\n\n    // No idea what this is...\n    createAlert(\n        'warning',\n        `\"${sanitizeHTML(\n            cScan.data.substring(0, Math.min(cScan.data.length, 6))\n        )}…\" ${ALERTS.QR_SCANNER_BAD_RECEIVER}`,\n        7500\n    );\n}\n\n/**\n * Open the Explorer in a new tab for the current wallet, or a specific address\n * @param {string?} strAddress - Optional address to open, if void, the master key is used\n */\nexport async function openExplorer(strAddress = '') {\n    if (wallet.isLoaded() && wallet.isHD() && !strAddress) {\n        const xpub = await wallet.getXPub();\n        window.open(cExplorer.url + '/xpub/' + xpub, '_blank');\n    } else {\n        const address = strAddress || (await wallet.getAddress());\n        window.open(cExplorer.url + '/address/' + address, '_blank');\n    }\n}\n\nasync function loadImages() {\n    const images = [\n        ['mpw-main-logo', import('../assets/logo.png')],\n        ['privateKeyImage', import('../assets/key.png')],\n    ];\n\n    const promises = images.map(([id, path]) =>\n        (async () => {\n            document.getElementById(id).src = (await path).default;\n        })()\n    );\n    await Promise.all(promises);\n}\n\nlet audio = null;\nexport async function playMusic() {\n    // On first play: load the audio into memory from the host\n    if (audio === null) {\n        // Dynamically load the file\n        audio = new Audio((await import('../assets/music.mp3')).default);\n    }\n\n    // Play or Pause\n    if (audio.paused || audio.ended) {\n        audio.play();\n        for (const domImg of document.getElementsByTagName('img'))\n            domImg.classList.add('discoFilter');\n    } else {\n        audio.pause();\n        for (const domImg of document.getElementsByTagName('img'))\n            domImg.classList.remove('discoFilter');\n    }\n}\n\nexport function unblurPrivKey() {\n    if (\n        document\n            .getElementById('exportPrivateKeyText')\n            .classList.contains('blurred')\n    ) {\n        document\n            .getElementById('exportPrivateKeyText')\n            .classList.remove('blurred');\n    } else {\n        document\n            .getElementById('exportPrivateKeyText')\n            .classList.add('blurred');\n    }\n}\n\nexport function toggleBottomMenu(dom, ani) {\n    let element = document.getElementById(dom);\n    if (element.classList.contains(ani)) {\n        element.classList.remove(ani);\n        doms.domBlackBack.classList.remove('d-none');\n        setTimeout(() => {\n            doms.domBlackBack.classList.remove('blackBackHide');\n        }, 10);\n    } else {\n        element.classList.add(ani);\n        doms.domBlackBack.classList.add('blackBackHide');\n        setTimeout(() => {\n            doms.domBlackBack.classList.add('d-none');\n        }, 150);\n    }\n}\n\n/**\n * Updates an Amount Input UI pair ('Coin' and 'Value' input boxes) in relation to the input box used\n * @param {HTMLInputElement} domCoin - The DOM input for the Coin amount\n * @param {HTMLInputElement} domValue - The DOM input for the Value amount\n * @param {boolean} fCoinEdited - `true` if Coin, `false` if Value\n */\nexport async function updateAmountInputPair(domCoin, domValue, fCoinEdited) {\n    // Fetch the price in the user's preferred currency\n    const nPrice = await cMarket.getPrice(strCurrency);\n\n    // If there is no price loaded, then we just won't do anything\n    if (!nPrice) return;\n\n    if (fCoinEdited) {\n        // If the 'Coin' input is edited, then update the 'Value' input with it's converted currency\n        const nValue = Number(domCoin.value) * nPrice;\n        domValue.value = nValue <= 0 ? '' : nValue;\n    } else {\n        // If the 'Value' input is edited, then update the 'Coin' input with the reversed conversion rate\n        const nValue = Number(domValue.value) / nPrice;\n        domCoin.value = nValue <= 0 ? '' : nValue;\n    }\n}\n\nexport function toClipboard(source, caller) {\n    // Fetch the text/value source\n    const domCopy = document.getElementById(source) || source;\n\n    // Use an invisible textbox as the clipboard source\n    const domClipboard = document.getElementById('clipboard');\n    domClipboard.value = domCopy.value || domCopy.innerHTML || domCopy;\n    domClipboard.select();\n    domClipboard.setSelectionRange(0, 99999);\n\n    // Browser-dependent clipboard execution\n    if (!navigator.clipboard) {\n        document.execCommand('copy');\n    } else {\n        navigator.clipboard.writeText(domCopy.innerHTML || domCopy);\n    }\n\n    // Display a temporary checkmark response\n    caller.classList.add('fa-check');\n    caller.classList.remove('fa-clipboard');\n    caller.style.cursor = 'default';\n    setTimeout(() => {\n        caller.classList.add('fa-clipboard');\n        caller.classList.remove('fa-check');\n        caller.style.cursor = 'pointer';\n    }, 1000);\n}\n\n/**\n * Prompt for a payment in the GUI with pre-filled inputs\n * @param {string} strTo - The address receiving the payment\n * @param {number} nAmount - The payment amount in full coins\n * @param {string} strDesc - The payment message or description\n */\nexport function guiPreparePayment(strTo = '', nAmount = 0, strDesc = '') {\n    // Apply values\n    doms.domAddress1s.value = strTo;\n    doms.domSendAmountCoins.value = nAmount;\n    doms.domReqDesc.value = strDesc;\n    doms.domReqDisplay.style.display = strDesc ? 'block' : 'none';\n\n    // Switch to the Dashboard\n    doms.domDashboard.click();\n\n    // Open the Send menu, if not already open (with a small timeout post-load to allow for CSS loading)\n    if (\n        document\n            .getElementById('transferMenu')\n            .classList.contains('transferAnimation')\n    ) {\n        setTimeout(() => {\n            toggleBottomMenu('transferMenu', 'transferAnimation');\n        }, 300);\n    }\n\n    // Update the conversion value\n    updateAmountInputPair(\n        doms.domSendAmountCoins,\n        doms.domSendAmountValue,\n        true\n    );\n\n    // Run the Input Validity checker\n    guiCheckRecipientInput({ target: doms.domAddress1s });\n\n    // Focus on the coin input box (if no pre-fill was specified)\n    if (nAmount <= 0) {\n        doms.domSendAmountCoins.focus();\n    }\n}\n\n/**\n * Set the \"Wallet Options\" menu visibility\n * @param {String} strDisplayCSS - The `display` CSS option to set the Wallet Options to\n */\nexport function setDisplayForAllWalletOptions(strDisplayCSS) {\n    // Set the display and Reset the Vanity address input\n    doms.domPrefix.value = '';\n    doms.domPrefix.style.display = strDisplayCSS;\n\n    // Set all \"*Wallet\" buttons\n    doms.domGenerateWallet.style.display = strDisplayCSS;\n    doms.domImportWallet.style.display = strDisplayCSS;\n    doms.domGenVanityWallet.style.display = strDisplayCSS;\n    doms.domAccessWallet.style.display = strDisplayCSS;\n    doms.domGenHardwareWallet.style.display = strDisplayCSS;\n}\n\nexport async function govVote(hash, voteCode) {\n    if (\n        (await confirmPopup({\n            title: ALERTS.CONFIRM_POPUP_VOTE,\n            html: ALERTS.CONFIRM_POPUP_VOTE_HTML,\n        })) == true\n    ) {\n        const database = await Database.getInstance();\n        const cMasternode = await database.getMasternode();\n        if (cMasternode) {\n            if ((await cMasternode.getStatus()) !== 'ENABLED') {\n                createAlert('warning', ALERTS.MN_NOT_ENABLED, 6000);\n                return;\n            }\n            const result = await cMasternode.vote(hash.toString(), voteCode); //1 yes 2 no\n            if (result.includes('Voted successfully')) {\n                //good vote\n                cMasternode.storeVote(hash.toString(), voteCode);\n                await updateGovernanceTab();\n                createAlert('success', ALERTS.VOTE_SUBMITTED, 6000);\n            } else if (result.includes('Error voting :')) {\n                //If you already voted return an alert\n                createAlert('warning', ALERTS.VOTED_ALREADY, 6000);\n            } else if (result.includes('Failure to verify signature.')) {\n                //wrong masternode private key\n                createAlert('warning', ALERTS.VOTE_SIG_BAD, 6000);\n            } else {\n                //this could be everything\n                console.error(result);\n                createAlert('warning', ALERTS.INTERNAL_ERROR, 6000);\n            }\n        } else {\n            createAlert('warning', ALERTS.MN_ACCESS_BEFORE_VOTE, 6000);\n        }\n    }\n}\n\n/**\n * Start a Masternode via a signed network broadcast\n * @param {boolean} fRestart - Whether this is a Restart or a first Start\n */\nexport async function startMasternode(fRestart = false) {\n    const database = await Database.getInstance();\n    const cMasternode = await database.getMasternode(wallet.getMasterKey());\n    if (cMasternode) {\n        if (\n            wallet.isViewOnly() &&\n            !(await restoreWallet(translation.walletUnlockMNStart))\n        )\n            return;\n        if (await cMasternode.start()) {\n            const strMsg = fRestart ? ALERTS.MN_RESTARTED : ALERTS.MN_STARTED;\n            createAlert('success', strMsg, 4000);\n        } else {\n            const strMsg = fRestart\n                ? ALERTS.MN_RESTART_FAILED\n                : ALERTS.MN_START_FAILED;\n            createAlert('warning', strMsg, 4000);\n        }\n    }\n}\n\nexport async function destroyMasternode() {\n    const database = await Database.getInstance();\n\n    if (await database.getMasternode(wallet.getMasterKey())) {\n        database.removeMasternode(wallet.getMasterKey());\n        createAlert('success', ALERTS.MN_DESTROYED, 5000);\n        updateMasternodeTab();\n    }\n}\n\n/**\n * Takes an ip address and adds the port.\n * If it's a tor address, ip.onion:port will be used (e.g. expyuzz4wqqyqhjn.onion:12345)\n * If it's an IPv4 address, ip:port will be used, (e.g. 127.0.0.1:12345)\n * If it's an IPv6 address, [ip]:port will be used, (e.g. [::1]:12345)\n * @param {String} ip - Ip address with or without port\n * @returns {String}\n */\nfunction parseIpAddress(ip) {\n    // IPv4 or tor without port\n    if (ip.match(/\\d+\\.\\d+\\.\\d+\\.\\d+/) || ip.match(/\\w+\\.onion/)) {\n        return `${ip}:${cChainParams.current.MASTERNODE_PORT}`;\n    }\n\n    // IPv4 or tor with port\n    if (ip.match(/\\d+\\.\\d+\\.\\d+\\.\\d+:\\d+/) || ip.match(/\\w+\\.onion:\\d+/)) {\n        return ip;\n    }\n\n    // IPv6 without port\n    if (Address6.isValid(ip)) {\n        return `[${ip}]:${cChainParams.current.MASTERNODE_PORT}`;\n    }\n\n    const groups = /\\[(.*)\\]:\\d+/.exec(ip);\n    if (groups !== null && groups.length > 1) {\n        // IPv6 with port\n        if (Address6.isValid(groups[1])) {\n            return ip;\n        }\n    }\n\n    // If we haven't returned yet, the address was invalid.\n    return null;\n}\n\nexport async function importMasternode() {\n    const mnPrivKey = doms.domMnPrivateKey.value;\n    const address = parseIpAddress(doms.domMnIP.value);\n    if (!address) {\n        createAlert('warning', ALERTS.MN_BAD_IP, 5000);\n        return;\n    }\n\n    let collateralTxId;\n    let outidx;\n    let collateralPrivKeyPath;\n    doms.domMnIP.value = '';\n    doms.domMnPrivateKey.value = '';\n\n    if (!wallet.isHD()) {\n        // Find the first UTXO matching the expected collateral size\n        const cCollaUTXO = mempool\n            .getConfirmed()\n            .find(\n                (cUTXO) => cUTXO.sats === cChainParams.current.collateralInSats\n            );\n\n        // If there's no valid UTXO, exit with a contextual message\n        if (!cCollaUTXO) {\n            if (getBalance(false) < cChainParams.current.collateralInSats) {\n                // Not enough balance to create an MN UTXO\n                const amount =\n                    (cChainParams.current.collateralInSats -\n                        getBalance(false)) /\n                    COIN;\n                const ticker = cChainParams.current.TICKER;\n                createAlert(\n                    'warning',\n                    tr(ALERTS.MN_NOT_ENOUGH_COLLAT, [\n                        { amount: amount },\n                        { ticker: ticker },\n                    ]),\n                    10000\n                );\n            } else {\n                // Balance is capable of a masternode, just needs to be created\n                // TODO: this UX flow is weird, is it even possible? perhaps we can re-design this entire function accordingly\n                const amount = cChainParams.current.collateralInSats / COIN;\n                const ticker = cChainParams.current.TICKER;\n                createAlert(\n                    'warning',\n                    tr(ALERTS.MN_ENOUGH_BUT_NO_COLLAT, [\n                        { amount },\n                        { ticker },\n                    ]),\n                    10000\n                );\n            }\n            return;\n        }\n\n        collateralTxId = cCollaUTXO.id;\n        outidx = cCollaUTXO.vout;\n        collateralPrivKeyPath = 'legacy';\n    } else {\n        const path = doms.domMnTxId.value;\n        const masterUtxo = mempool\n            .getConfirmed()\n            .findLast((u) => u.path === path); // first UTXO for each address in HD\n        // sanity check:\n        if (masterUtxo.sats !== cChainParams.current.collateralInSats) {\n            return createAlert('warning', ALERTS.MN_COLLAT_NOT_SUITABLE, 10000);\n        }\n        collateralTxId = masterUtxo.id;\n        outidx = masterUtxo.vout;\n        collateralPrivKeyPath = path;\n    }\n    doms.domMnTxId.value = '';\n\n    const cMasternode = new Masternode({\n        walletPrivateKeyPath: collateralPrivKeyPath,\n        mnPrivateKey: mnPrivKey,\n        collateralTxId: collateralTxId,\n        outidx: outidx,\n        addr: address,\n    });\n    await refreshMasternodeData(cMasternode, true);\n    await updateMasternodeTab();\n}\n\nexport async function accessOrImportWallet() {\n    // Hide and Reset the Vanity address input\n    doms.domPrefix.value = '';\n    doms.domPrefix.style.display = 'none';\n\n    // Show Import button, hide access button\n    doms.domImportWallet.style.display = 'block';\n    setTimeout(() => {\n        doms.domPrivKey.style.opacity = '1';\n    }, 100);\n    doms.domAccessWalletBtn.style.display = 'none';\n\n    // If we have a local wallet, display the decryption prompt\n    // This is no longer being used, as the user will be put in view-only\n    // mode when logging in, however if the user locked the wallet before\n    // #52 there would be no way to recover the public key without getting\n    // The password from the user\n    if (await hasEncryptedWallet()) {\n        doms.domPrivKey.placeholder = translation.encryptPasswordFirst;\n        doms.domImportWalletText.innerText = translation.unlockWallet;\n        doms.domPrivKey.focus();\n    }\n}\n/**\n * An event function triggered apon private key UI input changes\n *\n * Useful for adjusting the input types or displaying password prompts depending on the import scheme\n */\nexport async function guiUpdateImportInput() {\n    if (await hasEncryptedWallet()) return;\n    // Check whether the string is Base64 (would likely be an MPW-encrypted import)\n    // and it doesn't have any spaces (would be a mnemonic seed)\n    const fContainsSpaces = doms.domPrivKey.value.trim().includes(' ');\n\n    // If this could require a Seed Passphrase (BIP39 Passphrase) and Advanced Mode is enabled\n    // ...or if this is an Encrypted Import (Encrypted Base64 MPW key)\n    const fBIP39Passphrase = fContainsSpaces && fAdvancedMode;\n    doms.domPrivKeyPassword.hidden =\n        (doms.domPrivKey.value.length < 128 ||\n            !isBase64(doms.domPrivKey.value)) &&\n        !fBIP39Passphrase;\n\n    doms.domPrivKeyPassword.placeholder = fContainsSpaces\n        ? translation.optionalPassphrase\n        : translation.password;\n\n    // If the \"Import Password/Passphrase\" is hidden, we'll also wipe it's input, in the\n    // ... edge-case that a passphrase was entered, then the import key had changed.\n    if (doms.domPrivKeyPassword.hidden) doms.domPrivKeyPassword.value = '';\n\n    // Uncloak the private input IF spaces are detected, to make Seed Phrases easier to input and verify\n    doms.domPrivKey.setAttribute('type', fContainsSpaces ? 'text' : 'password');\n}\n\n/**\n * Imports a wallet using the GUI input, handling decryption via UI\n */\nexport async function guiImportWallet() {\n    // Important: These fields will be wiped by importWallet();\n    const strPrivKey = doms.domPrivKey.value;\n    const strPassword = doms.domPrivKeyPassword.value;\n    const fEncrypted = strPrivKey.length >= 128 && isBase64(strPrivKey);\n\n    // If we are in testnet: prompt an import\n    if (cChainParams.current.isTestnet) return importWallet();\n\n    // If we don't have a DB wallet and the input is plain: prompt an import\n    if (!(await hasEncryptedWallet()) && !fEncrypted) return importWallet();\n\n    // If we don't have a DB wallet and the input is ciphered:\n    if (!(await hasEncryptedWallet()) && fEncrypted) {\n        const strDecWIF = await decrypt(strPrivKey, strPassword);\n        if (!strDecWIF || strDecWIF === 'decryption failed!') {\n            return createAlert('warning', ALERTS.FAILED_TO_IMPORT, 6000);\n        } else {\n            await importWallet({\n                newWif: strDecWIF,\n                // Save the public key to disk for future View Only mode post-decryption\n                fSavePublicKey: true,\n            });\n\n            if (wallet.isLoaded()) {\n                // Prepare a new Account to add\n                const cAccount = new Account({\n                    publicKey: await wallet.getKeyToExport(),\n                    encWif: strPrivKey,\n                });\n\n                // Add the new Account to the DB\n                const database = await Database.getInstance();\n                database.addAccount(cAccount);\n            }\n\n            // Destroy residue import data\n            doms.domPrivKey.value = '';\n            doms.domPrivKeyPassword.value = '';\n            return;\n        }\n    }\n    // Prompt for decryption of the existing wallet\n    const fHasWallet = await decryptWallet(doms.domPrivKey.value);\n\n    // If the wallet was successfully loaded, hide all options and load the dash!\n    if (fHasWallet) setDisplayForAllWalletOptions('none');\n}\n\nexport async function guiEncryptWallet() {\n    // Fetch our inputs, ensure they're of decent entropy + match eachother\n    const strPass = doms.domEncryptPasswordFirst.value,\n        strPassRetype = doms.domEncryptPasswordSecond.value;\n    if (strPass.length < MIN_PASS_LENGTH)\n        return createAlert(\n            'warning',\n            tr(ALERTS.PASSWORD_TOO_SMALL, [\n                { MIN_PASS_LENGTH: MIN_PASS_LENGTH },\n            ]),\n            4000\n        );\n    if (strPass !== strPassRetype)\n        return createAlert('warning', ALERTS.PASSWORD_DOESNT_MATCH, 2250);\n\n    // If this wallet is already encrypted, then we'll check for the current password and ensure it decrypts properly too\n    if (await hasEncryptedWallet()) {\n        // Grab the pass, and wipe the dialog immediately\n        const strCurrentPass = doms.domEncryptPasswordCurrent.value;\n        doms.domEncryptPasswordCurrent.value = '';\n\n        // If the decryption fails: we don't allow changing the password\n        if (!(await decryptWallet(strCurrentPass))) return;\n    }\n\n    // Encrypt the wallet using the new password\n    await wallet.encryptWallet(strPass);\n    createAlert('success', ALERTS.NEW_PASSWORD_SUCCESS, 5500);\n\n    // Hide and reset the encryption modal\n    $('#encryptWalletModal').modal('hide');\n    doms.domEncryptPasswordFirst.value = '';\n    doms.domEncryptPasswordSecond.value = '';\n\n    // Display the 'Unlock/Lock Wallet' buttons accordingly based on state\n    doms.domWipeWallet.hidden = wallet.isViewOnly();\n    doms.domRestoreWallet.hidden = !wallet.isViewOnly();\n\n    // Update the encryption UI (changes to \"Change Password\" now)\n    await updateEncryptionGUI(true);\n}\n\n/** Update the \"Encrypt Wallet\" / \"Change Password\" dialog to match the current wallet state */\nexport async function updateEncryptionGUI(fEncrypted = null) {\n    // If no param is provided, check if a wallet exists in the database\n    if (fEncrypted === null) {\n        fEncrypted = await hasEncryptedWallet();\n    }\n    // If the wallet is encrypted, we display a \"Current Password\" input in the Encryption dialog, otherwise, only accept New Passwords\n    doms.domEncryptPasswordCurrent.style.display = fEncrypted ? '' : 'none';\n    // And we adjust the displays to accomodate the mode as well\n    doms.domEncryptWalletLabel.innerText = fEncrypted\n        ? translation.changePassword\n        : translation.encryptWallet;\n    doms.domChangePasswordContainer.style.display = fEncrypted ? '' : 'none';\n}\n\nexport async function toggleExportUI() {\n    if (!exportHidden) {\n        if (await hasEncryptedWallet()) {\n            const { encWif } = await (\n                await Database.getInstance()\n            ).getAccount();\n            doms.domExportPrivateKey.innerHTML = encWif;\n            exportHidden = true;\n        } else {\n            if (wallet.isViewOnly()) {\n                exportHidden = false;\n            } else {\n                doms.domExportPrivateKey.innerHTML =\n                    wallet.getMasterKey().keyToBackup;\n                exportHidden = true;\n            }\n        }\n    } else {\n        doms.domExportPrivateKey.innerHTML = '';\n        exportHidden = false;\n    }\n}\n\nexport function checkVanity() {\n    var e = event || window.event; // get event object\n    var key = e.keyCode || e.which; // get key cross-browser\n    var char = String.fromCharCode(key).trim(); // convert key to char\n    if (char.length == 0) return;\n\n    // Ensure the input is base58 compatible\n    if (!MAP_B58.toLowerCase().includes(char.toLowerCase())) {\n        if (e.preventDefault) e.preventDefault();\n        e.returnValue = false;\n        return createAlert(\n            'warning',\n            tr(ALERTS.UNSUPPORTED_CHARACTER, [{ char: char }]),\n            3500\n        );\n    }\n}\n\nlet isVanityGenerating = false;\nconst arrWorkers = [];\nlet vanUiUpdater;\n\nfunction stopSearch() {\n    isVanityGenerating = false;\n    for (let thread of arrWorkers) {\n        thread.terminate();\n    }\n    while (arrWorkers.length) arrWorkers.pop();\n    doms.domPrefix.disabled = false;\n    doms.domVanityUiButtonTxt.innerText = translation.dCardTwoButton;\n    clearInterval(vanUiUpdater);\n}\n\nexport async function generateVanityWallet() {\n    if (isVanityGenerating) return stopSearch();\n    if (typeof Worker === 'undefined')\n        return createAlert('error', ALERTS.UNSUPPORTED_WEBWORKERS, 7500);\n    // Generate a vanity address with the given prefix\n    if (\n        doms.domPrefix.value.length === 0 ||\n        doms.domPrefix.style.display === 'none'\n    ) {\n        // No prefix, display the intro!\n        doms.domPrefix.style.display = 'block';\n        setTimeout(() => {\n            doms.domPrefix.style.opacity = '1';\n        }, 100);\n        doms.domPrefix.focus();\n    } else {\n        // Remove spaces from prefix\n        doms.domPrefix.value = doms.domPrefix.value.replace(/ /g, '');\n\n        // Cache a lowercase equivilent for lower-entropy comparisons (a case-insensitive search is ALOT faster!) and strip accidental spaces\n        const nInsensitivePrefix = doms.domPrefix.value.toLowerCase();\n        const nPrefixLen = nInsensitivePrefix.length;\n\n        // Ensure the input is base58 compatible\n        for (const char of doms.domPrefix.value) {\n            if (!MAP_B58.toLowerCase().includes(char.toLowerCase()))\n                return createAlert(\n                    'warning',\n                    tr(ALERTS.UNSUPPORTED_CHARACTER, [{ char: char }]),\n                    3500\n                );\n            // We also don't want users to be mining addresses for years... so cap the letters to four until the generator is more optimized\n            if (doms.domPrefix.value.length > 5)\n                return createAlert(\n                    'warning',\n                    tr(ALERTS.UNSUPPORTED_CHARACTER, [{ char: char }]),\n                    3500\n                );\n        }\n        isVanityGenerating = true;\n        doms.domPrefix.disabled = true;\n        let attempts = 0;\n\n        // Setup workers\n        const nThreads = Math.max(\n            Math.floor(window.navigator.hardwareConcurrency * 0.75),\n            1\n        );\n        console.log('Spawning ' + nThreads + ' vanity search threads!');\n        while (arrWorkers.length < nThreads) {\n            arrWorkers.push(\n                new Worker(new URL('./vanitygen_worker.js', import.meta.url))\n            );\n            const checkResult = (data) => {\n                attempts++;\n                if (\n                    data.pub.substr(1, nPrefixLen).toLowerCase() ==\n                    nInsensitivePrefix\n                ) {\n                    importWallet({\n                        newWif: data.priv,\n                        fRaw: true,\n                    });\n                    stopSearch();\n                    doms.domGuiBalance.innerHTML = '0';\n                    return console.log(\n                        'VANITY: Found an address after ' +\n                            attempts +\n                            ' attempts!'\n                    );\n                }\n            };\n\n            arrWorkers[arrWorkers.length - 1].onmessage = (event) =>\n                checkResult(event.data);\n            arrWorkers[arrWorkers.length - 1].postMessage(\n                cChainParams.current.PUBKEY_ADDRESS\n            );\n        }\n\n        // GUI Updater\n        doms.domVanityUiButtonTxt.innerText =\n            'Stop (Searched ' + attempts.toLocaleString('en-GB') + ' keys)';\n        vanUiUpdater = setInterval(() => {\n            doms.domVanityUiButtonTxt.innerText =\n                'Stop (Searched ' + attempts.toLocaleString('en-GB') + ' keys)';\n        }, 200);\n    }\n}\n\n/**\n * Sweep an address to our own wallet, spending all it's UTXOs without change\n * @param {Array<object>} arrUTXOs - The UTXOs belonging to the address to sweep\n * @param {LegacyMasterKey} sweepingMasterKey - The address to sweep from\n * @param {number} nFixedFee - An optional fixed satoshi fee\n * @returns {Promise<string|false>} - TXID on success, false or error on failure\n */\nexport async function sweepAddress(arrUTXOs, sweepingMasterKey, nFixedFee = 0) {\n    const cTx = new bitjs.transaction();\n\n    // Load all UTXOs as inputs\n    let nTotal = 0;\n    for (const cUTXO of arrUTXOs) {\n        nTotal += cUTXO.sats;\n        cTx.addinput({\n            txid: cUTXO.id,\n            index: cUTXO.vout,\n            script: cUTXO.script,\n            path: cUTXO.path,\n        });\n    }\n\n    // Use a given fixed fee, or use the network fee if unspecified\n    const nFee = nFixedFee || getNetwork().getFee(cTx.serialize().length);\n\n    // Use a new address from our wallet to sweep the UTXOs in to\n    const strAddress = (await getNewAddress(true, false))[0];\n\n    // Sweep the full funds amount, minus the fee, leaving no change from any sweeped UTXOs\n    cTx.addoutput(strAddress, (nTotal - nFee) / COIN);\n\n    // Sign using the given Master Key, then broadcast the sweep, returning the TXID (or a failure)\n    const sign = await signTransaction(cTx, sweepingMasterKey);\n    return await getNetwork().sendTransaction(sign);\n}\n\nexport function toggleDropDown(id) {\n    const domID = document.getElementById(id);\n    domID.style.display = domID.style.display === 'block' ? 'none' : 'block';\n}\n\nexport function isMasternodeUTXO(cUTXO, cMasternode) {\n    if (cMasternode?.collateralTxId) {\n        const { collateralTxId, outidx } = cMasternode;\n        return collateralTxId === cUTXO.id && cUTXO.vout === outidx;\n    } else {\n        return false;\n    }\n}\n\n/**\n * Creates a GUI popup for the user to check or customise their Cold Address\n */\nexport async function guiSetColdStakingAddress() {\n    if (\n        await confirmPopup({\n            title: translation.popupSetColdAddr,\n            html: `<p>${\n                translation.popupCurrentAddress\n            }<br><span class=\"mono\">${strColdStakingAddress}</span><br><br><span style=\"opacity: 0.65; margin: 10px;\">${\n                translation.popupColdStakeNote\n            }</span></p><br><input type=\"text\" id=\"newColdAddress\" placeholder=\"${\n                translation.popupExample\n            } ${strColdStakingAddress.substring(\n                0,\n                6\n            )}...\" style=\"text-align: center;\">`,\n        })\n    ) {\n        // Fetch address from the popup input\n        const strColdAddress = document.getElementById('newColdAddress').value;\n\n        // If it's empty, just return false\n        if (!strColdAddress) return false;\n\n        // Sanity-check, and set!\n        if (\n            strColdAddress[0] === cChainParams.current.STAKING_PREFIX &&\n            strColdAddress.length === 34\n        ) {\n            await setColdStakingAddress(strColdAddress);\n            createAlert('info', ALERTS.STAKE_ADDR_SET, 5000);\n            return true;\n        } else {\n            createAlert('warning', ALERTS.STAKE_ADDR_BAD, 2500);\n            return false;\n        }\n    } else {\n        return false;\n    }\n}\n\nexport async function wipePrivateData() {\n    const isEncrypted = await hasEncryptedWallet();\n    const title = isEncrypted\n        ? translation.popupWalletLock\n        : translation.popupWalletWipe;\n    const html = isEncrypted\n        ? translation.popupWalletLockNote\n        : translation.popupWalletWipeNote;\n    if (\n        await confirmPopup({\n            title,\n            html,\n        })\n    ) {\n        wallet.wipePrivateData();\n        doms.domWipeWallet.hidden = true;\n        if (isEncrypted) {\n            doms.domRestoreWallet.hidden = false;\n        }\n    }\n}\n\n/**\n * Prompt the user in the GUI to unlock their wallet\n * @param {string} strReason - An optional reason for the unlock\n * @returns {Promise<boolean>} - If the unlock was successful or rejected\n */\nexport async function restoreWallet(strReason = '') {\n    // Build up the UI elements based upon conditions for the unlock prompt\n    let strHTML = '';\n\n    // If there's a reason given; display it as a sub-text\n    strHTML += `<p style=\"opacity: 0.75\">${strReason}</p>`;\n\n    // Prompt the user\n    if (\n        await confirmPopup({\n            title: translation.walletUnlock,\n            html: `${strHTML}<input type=\"password\" id=\"restoreWalletPassword\" placeholder=\"${translation.walletPassword}\" style=\"text-align: center;\">`,\n        })\n    ) {\n        // Fetch the password from the prompt, and immediately destroy the prompt input\n        const domPassword = document.getElementById('restoreWalletPassword');\n        const strPassword = domPassword.value;\n        domPassword.value = '';\n\n        // Attempt to unlock the wallet with the provided password\n        if (await decryptWallet(strPassword)) {\n            doms.domRestoreWallet.hidden = true;\n            doms.domWipeWallet.hidden = false;\n            // Wallet is unlocked!\n            return true;\n        } else {\n            // Password is invalid\n            return false;\n        }\n    } else {\n        // User rejected the unlock\n        return false;\n    }\n}\n\n/** A lock to prevent rendering the Governance Dashboard multiple times */\nlet fRenderingGovernance = false;\n\n/**\n * Fetch Governance data and re-render the Governance UI\n */\nexport async function updateGovernanceTab() {\n    if (fRenderingGovernance) return;\n    fRenderingGovernance = true;\n\n    // Setup the Superblock countdown (if not already done), no need to block thread with await, either.\n    let cNet = getNetwork();\n\n    // When switching to mainnet from testnet or vise versa, you ned to use an await on getBlockCount() or cNet.cachedBlockCount returns 0\n    if (!isTestnetLastState == cChainParams.current.isTestnet) {\n        // Reset flipdown\n        governanceFlipdown = null;\n        doms.domFlipdown.innerHTML = '';\n\n        // Get new network blockcount\n        await getNetwork().getBlockCount();\n        cNet = getNetwork();\n    }\n\n    // Update governance counter when testnet/mainnet has been switched\n    if (!governanceFlipdown && cNet.cachedBlockCount > 0) {\n        Masternode.getNextSuperblock().then((nSuperblock) => {\n            // The estimated time to the superblock (using the block target and remaining blocks)\n            const nTimestamp =\n                Date.now() / 1000 + (nSuperblock - cNet.cachedBlockCount) * 60;\n            governanceFlipdown = new FlipDown(nTimestamp).start();\n        });\n        isTestnetLastState = cChainParams.current.isTestnet;\n    }\n\n    // Fetch all proposals from the network\n    const arrProposals = await Masternode.getProposals({\n        fAllowFinished: false,\n    });\n\n    /* Sort proposals into two categories\n        - Standard (Proposal is either new with <100 votes, or has a healthy vote count)\n        - Contested (When a proposal may be considered spam, malicious, or simply highly contestable)\n    */\n    const arrStandard = arrProposals.filter(\n        (a) => a.Yeas + a.Nays < 100 || a.Ratio > 0.25\n    );\n    const arrContested = arrProposals.filter(\n        (a) => a.Yeas + a.Nays >= 100 && a.Ratio <= 0.25\n    );\n\n    // Render Proposals\n    await Promise.all([\n        renderProposals(arrStandard, false),\n        renderProposals(arrContested, true),\n    ]);\n\n    // Remove lock\n    fRenderingGovernance = false;\n}\n\n/**\n * @typedef {Object} ProposalCache\n * @property {number} nSubmissionHeight - The submission height of the proposal.\n * @property {string} txid - The transaction ID of the proposal (string).\n * @property {boolean} fFetching - Indicates whether the proposal is currently being fetched or not.\n */\n\n/**\n * An array of Proposal Finalisation caches\n * @type {Array<ProposalCache>}\n */\nconst arrProposalFinalisationCache = [];\n\n/**\n * Asynchronously wait for a Proposal Tx to confirm, then cache the height.\n *\n * Do NOT await unless you want to lock the thread for a long time.\n * @param {ProposalCache} cProposalCache - The proposal cache to wait for\n * @returns {Promise<boolean>} Returns `true` once the block height is cached\n */\nasync function waitForSubmissionBlockHeight(cProposalCache) {\n    let nHeight = null;\n\n    // Wait in a permanent throttled loop until we successfully fetch the block\n    const cNet = getNetwork();\n    while (true) {\n        // If a proposal is already fetching, then consequtive calls will be rejected\n        cProposalCache.fFetching = true;\n\n        // Attempt to fetch the submission Tx (may not exist yet!)\n        let cTx = null;\n        try {\n            cTx = await cNet.getTxInfo(cProposalCache.txid);\n        } catch (_) {}\n\n        if (!cTx || !cTx.blockHeight) {\n            // Didn't get the TX, throttle the thread by sleeping for a bit, then try again.\n            await sleep(30000);\n        } else {\n            nHeight = cTx.blockHeight;\n            break;\n        }\n    }\n\n    // Update the proposal finalisation cache\n    cProposalCache.nSubmissionHeight = nHeight;\n\n    return true;\n}\n\n/**\n * Create a Status String for a proposal's finalisation status\n * @param {ProposalCache} cPropCache - The proposal cache to check\n * @returns {string} The string status, for display purposes\n */\nfunction getProposalFinalisationStatus(cPropCache) {\n    const cNet = getNetwork();\n    // Confirmations left until finalisation, by network consensus\n    const nConfsLeft =\n        cPropCache.nSubmissionHeight +\n        cChainParams.current.proposalFeeConfirmRequirement -\n        cNet.cachedBlockCount;\n\n    if (cPropCache.nSubmissionHeight === 0 || cNet.cachedBlockCount === 0) {\n        return translation.proposalFinalisationConfirming;\n    } else if (nConfsLeft > 0) {\n        return (\n            nConfsLeft +\n            ' block' +\n            (nConfsLeft === 1 ? '' : 's') +\n            ' ' +\n            translation.proposalFinalisationRemaining\n        );\n    } else if (Math.abs(nConfsLeft) >= cChainParams.current.budgetCycleBlocks) {\n        return translation.proposalFinalisationExpired;\n    } else {\n        return translation.proposalFinalisationReady;\n    }\n}\n\n/**\n *\n * @param {Object} cProposal - A local proposal to add to the cache tracker\n * @returns {ProposalCache} - The finalisation cache object pointer of the local proposal\n */\nfunction addProposalToFinalisationCache(cProposal) {\n    // If it exists, return the existing cache\n    /** @type ProposalCache */\n    let cPropCache = arrProposalFinalisationCache.find(\n        (a) => a.txid === cProposal.mpw.txid\n    );\n    if (cPropCache) return cPropCache;\n\n    // Create a new cache\n    cPropCache = {\n        nSubmissionHeight: 0,\n        txid: cProposal.mpw.txid,\n        fFetching: false,\n    };\n    arrProposalFinalisationCache.push(cPropCache);\n\n    // Return the object 'pointer' in the array for further updating\n    return cPropCache;\n}\n\n/**\n * Render Governance proposal objects to a given Proposal category\n * @param {Array<object>} arrProposals - The proposals to render\n * @param {boolean} fContested - The proposal category\n */\nasync function renderProposals(arrProposals, fContested) {\n    // Set the total budget\n    doms.domTotalGovernanceBudget.innerText = (\n        cChainParams.current.maxPayment / COIN\n    ).toLocaleString('en-gb');\n\n    // Update total budget in user's currency\n    const nPrice = await cMarket.getPrice(strCurrency);\n    const nCurrencyValue = (cChainParams.current.maxPayment / COIN) * nPrice;\n    const { nValue, cLocale } = optimiseCurrencyLocale(nCurrencyValue);\n    doms.domTotalGovernanceBudgetValue.innerHTML =\n        nValue.toLocaleString('en-gb', cLocale) +\n        ' <span style=\"color:#8b38ff;\">' +\n        strCurrency.toUpperCase() +\n        '</span>';\n\n    // Select the table based on the proposal category\n    const domTable = fContested\n        ? doms.domGovProposalsContestedTableBody\n        : doms.domGovProposalsTableBody;\n\n    // Render the proposals in the relevent table\n    const database = await Database.getInstance();\n    const cMasternode = await database.getMasternode();\n\n    if (!fContested) {\n        const localProposals =\n            (await database.getAccount())?.localProposals?.map((p) => {\n                return {\n                    Name: p.name,\n                    URL: p.url,\n                    PaymentAddress: p.address,\n                    MonthlyPayment: p.monthlyPayment / COIN,\n                    RemainingPaymentCount: p.nPayments,\n                    TotalPayment: p.nPayments * (p.monthlyPayment / COIN),\n                    Yeas: 0,\n                    Nays: 0,\n                    local: true,\n                    Ratio: 0,\n                    IsEstablished: false,\n                    mpw: p,\n                };\n            }) || [];\n        arrProposals = localProposals.concat(arrProposals);\n    }\n    arrProposals = await Promise.all(\n        arrProposals.map(async (p) => {\n            return {\n                YourVote:\n                    cMasternode && p.Hash\n                        ? await cMasternode.getVote(p.Name, p.Hash)\n                        : null,\n                ...p,\n            };\n        })\n    );\n\n    // Fetch the Masternode count for proposal status calculations\n    const cMasternodes = await Masternode.getMasternodeCount();\n\n    let totalAllocatedAmount = 0;\n\n    // Wipe the current table and start rendering proposals\n    let i = 0;\n    domTable.innerHTML = '';\n    for (const cProposal of arrProposals) {\n        const domRow = domTable.insertRow();\n\n        const domStatus = domRow.insertCell();\n        domStatus.classList.add('governStatusCol');\n        if (domTable.id == 'proposalsTableBody') {\n            domStatus.setAttribute(\n                'onclick',\n                `if(document.getElementById('governMob${i}').classList.contains('d-none')) { document.getElementById('governMob${i}').classList.remove('d-none'); } else { document.getElementById('governMob${i}').classList.add('d-none'); }`\n            );\n        } else if (domTable.id == 'proposalsContestedTableBody') {\n            domStatus.setAttribute(\n                'onclick',\n                `if(document.getElementById('governMobCon${i}').classList.contains('d-none')) { document.getElementById('governMobCon${i}').classList.remove('d-none'); } else { document.getElementById('governMobCon${i}').classList.add('d-none'); }`\n            );\n        }\n\n        // Add border radius to last row\n        if (arrProposals.length - 1 == i) {\n            domStatus.classList.add('bblr-7p');\n        }\n\n        // Net Yes calculation\n        const { Yeas, Nays } = cProposal;\n        const nNetYes = Yeas - Nays;\n        const nNetYesPercent = (nNetYes / cMasternodes.enabled) * 100;\n\n        // Proposal Status calculation\n        const nRequiredVotes = cMasternodes.enabled / 10;\n        let strStatus = '';\n        let strFundingStatus = '';\n\n        // Proposal Status calculations\n        if (nNetYes < nRequiredVotes) {\n            // Scenario 1: Not enough votes\n            strStatus = translation.proposalFailing;\n            strFundingStatus = translation.proposalNotFunded;\n        } else if (!cProposal.IsEstablished) {\n            // Scenario 2: Enough votes, but not established\n            strStatus = translation.proposalFailing;\n            strFundingStatus = translation.proposalTooYoung;\n        } else {\n            // Scenario 3: Enough votes, and established\n            strStatus = translation.proposalPassing;\n            strFundingStatus = translation.proposalFunded;\n        }\n\n        // Funding Status and allocation calculations\n        if (cProposal.local) {\n            // Check the finalisation cache\n            const cPropCache = addProposalToFinalisationCache(cProposal);\n            if (!cPropCache.fFetching) {\n                waitForSubmissionBlockHeight(cPropCache).then(\n                    updateGovernanceTab\n                );\n            }\n            const strLocalStatus = getProposalFinalisationStatus(cPropCache);\n            const finalizeButton = document.createElement('button');\n            finalizeButton.className = 'pivx-button-small';\n            finalizeButton.innerHTML = '<i class=\"fas fa-check\"></i>';\n\n            if (\n                strLocalStatus === translation.proposalFinalisationReady ||\n                strLocalStatus === translation.proposalFinalisationExpired\n            ) {\n                finalizeButton.addEventListener('click', async () => {\n                    const result = await Masternode.finalizeProposal(\n                        cProposal.mpw\n                    );\n\n                    const deleteProposal = async () => {\n                        // Fetch Account\n                        const account = await database.getAccount();\n\n                        // Find index of Account local proposal to remove\n                        const nProposalIndex = account.localProposals.findIndex(\n                            (p) => p.txid === cProposal.mpw.txid\n                        );\n\n                        // If found, remove the proposal and update the account with the modified localProposals array\n                        if (nProposalIndex > -1) {\n                            // Remove our proposal from it\n                            account.localProposals.splice(nProposalIndex, 1);\n\n                            // Update the DB\n                            await database.updateAccount(account, true);\n                        }\n                    };\n\n                    if (result.ok) {\n                        deleteProposal();\n                        // Create a prompt showing the finalisation success, vote hash, and further details\n                        confirmPopup({\n                            title: translation.PROPOSAL_FINALISED + ' 🚀',\n                            html: `<p><span style=\"opacity: 0.65; margin: 10px;\">${\n                                translation.popupProposalFinalisedNote\n                            }</span><br><br>${\n                                translation.popupProposalVoteHash\n                            }<br><span class=\"mono\" style=\"font-size: small;\">${sanitizeHTML(\n                                result.hash\n                            )}</span><br><br>${\n                                translation.popupProposalFinalisedSignoff\n                            } 👋</p>`,\n                            hideConfirm: true,\n                        });\n                        updateGovernanceTab();\n                    } else {\n                        if (result.err === 'unconfirmed') {\n                            createAlert(\n                                'warning',\n                                ALERTS.PROPOSAL_UNCONFIRMED,\n                                5000\n                            );\n                        } else if (result.err === 'invalid') {\n                            createAlert(\n                                'warning',\n                                ALERTS.PROPOSAL_EXPIRED,\n                                5000\n                            );\n                            deleteProposal();\n                            updateGovernanceTab();\n                        } else {\n                            createAlert(\n                                'warning',\n                                ALERTS.PROPOSAL_FINALISE_FAIL\n                            );\n                        }\n                    }\n                });\n            } else {\n                finalizeButton.style.opacity = 0.5;\n                finalizeButton.style.cursor = 'default';\n            }\n\n            domStatus.innerHTML = `\n            <span style=\"font-size:12px; line-height: 15px; display: block; margin-bottom:15px;\">\n                <span style=\"color:#fff; font-weight:700;\">${strLocalStatus}</span><br>\n            </span>\n            <span class=\"governArrow for-mobile ptr\">\n                <i class=\"fa-solid fa-angle-down\"></i>\n            </span>`;\n            domStatus.appendChild(finalizeButton);\n        } else {\n            if (domTable.id == 'proposalsTableBody') {\n                if (\n                    cProposal.IsEstablished &&\n                    nNetYes >= nRequiredVotes &&\n                    totalAllocatedAmount + cProposal.MonthlyPayment <=\n                        cChainParams.current.maxPayment / COIN\n                ) {\n                    strFundingStatus = translation.proposalFunded;\n                    totalAllocatedAmount += cProposal.MonthlyPayment;\n                }\n            }\n\n            // Figure out the colour of the Status, if any (using CSS class `votes[Yes/No]`)\n            const strColourClass =\n                strStatus === translation.proposalPassing ? 'Yes' : 'No';\n\n            domStatus.innerHTML = `\n            <span style=\"font-size:12px; line-height: 15px; display: block; margin-bottom:15px;\">\n                <span style=\"font-weight:700;\" class=\"votes${strColourClass}\">${strStatus}</span><br>\n                <span style=\"color:hsl(265 100% 67% / 1);\">(${strFundingStatus})</span><br>\n            </span>\n            <span style=\"font-size:12px; line-height: 15px; display: block; color:#d1d1d1;\">\n                <b>${nNetYesPercent.toFixed(1)}%</b><br>\n                ${translation.proposalNetYes}\n            </span>\n            <span class=\"governArrow for-mobile ptr\">\n                <i class=\"fa-solid fa-angle-down\"></i>\n            </span>`;\n        }\n\n        // Name, Payment Address and URL hyperlink\n        const domNameAndURL = domRow.insertCell();\n        domNameAndURL.style = 'vertical-align: middle;';\n\n        // IMPORTANT: Sanitise all of our HTML or a rogue server or malicious proposal could perform a cross-site scripting attack\n        domNameAndURL.innerHTML = `<a class=\"governLink\" style=\"color: white\" href=\"${sanitizeHTML(\n            cProposal.URL\n        )}\" target=\"_blank\" rel=\"noopener noreferrer\"><b>${sanitizeHTML(\n            cProposal.Name\n        )} <span class=\"governLinkIco\"><i class=\"fa-solid fa-arrow-up-right-from-square\"></i></b></a></span><br><a class=\"governLink\" style=\"font-size: small; color:#8b38ff;\" onclick=\"MPW.openExplorer('${\n            cProposal.PaymentAddress\n        }')\"><i class=\"fa-solid fa-user-large\" style=\"margin-right: 5px\"></i><b>${sanitizeHTML(\n            cProposal.PaymentAddress.slice(0, 6) + '...'\n        )}`;\n\n        // Convert proposal amount to user's currency\n        const nProposalValue = parseInt(cProposal.MonthlyPayment) * nPrice;\n        const { nValue } = optimiseCurrencyLocale(nProposalValue);\n        const strProposalCurrency = nValue.toLocaleString('en-gb', cLocale);\n\n        // Payment Schedule and Amounts\n        const domPayments = domRow.insertCell();\n        domPayments.classList.add('for-desktop');\n        domPayments.style = 'vertical-align: middle;';\n        domPayments.innerHTML = `<span class=\"governValues\"><b>${sanitizeHTML(\n            parseInt(cProposal.MonthlyPayment).toLocaleString('en-gb', ',', '.')\n        )}</b> <span class=\"governMarked\">${\n            cChainParams.current.TICKER\n        }</span> <br>\n        <b class=\"governFiatSize\">(${strProposalCurrency} <span style=\"color:#8b38ff;\">${strCurrency.toUpperCase()}</span>)</b></span>\n\n        <span class=\"governInstallments\"> ${sanitizeHTML(\n            cProposal['RemainingPaymentCount']\n        )} ${translation.proposalPaymentsRemaining} <b>${sanitizeHTML(\n            parseInt(cProposal.TotalPayment).toLocaleString('en-gb', ',', '.')\n        )} ${cChainParams.current.TICKER}</b> ${\n            translation.proposalPaymentTotal\n        }</span>`;\n\n        // Vote Counts and Consensus Percentages\n        const domVoteCounters = domRow.insertCell();\n        domVoteCounters.classList.add('for-desktop');\n        domVoteCounters.style = 'vertical-align: middle;';\n\n        const nLocalPercent = cProposal.Ratio * 100;\n        domVoteCounters.innerHTML = `<b>${parseFloat(\n            nLocalPercent\n        ).toLocaleString(\n            'en-gb',\n            { minimumFractionDigits: 0, maximumFractionDigits: 1 },\n            ',',\n            '.'\n        )}%</b> <br>\n        <small class=\"votesBg\"> <b><div class=\"votesYes\" style=\"display:inline;\"> ${sanitizeHTML(\n            Yeas\n        )} </div></b> /\n        <b><div class=\"votesNo\" style=\"display:inline;\"> ${sanitizeHTML(\n            Nays\n        )} </div></b></small>\n        `;\n\n        // Voting Buttons for Masternode owners (MNOs)\n        let voteBtn;\n        if (cProposal.local) {\n            const domVoteBtns = domRow.insertCell();\n            domVoteBtns.classList.add('for-desktop');\n            domVoteBtns.style = 'vertical-align: middle;';\n            voteBtn = '';\n        } else {\n            let btnYesClass = 'pivx-button-small';\n            let btnNoClass = 'pivx-button-small';\n            if (cProposal.YourVote) {\n                if (cProposal.YourVote === 1) {\n                    btnYesClass += ' pivx-button-big-yes-gov';\n                } else {\n                    btnNoClass += ' pivx-button-big-no-gov';\n                }\n            }\n            const domVoteBtns = domRow.insertCell();\n            domVoteBtns.style = 'vertical-align: middle;';\n            const domNoBtn = document.createElement('button');\n            domNoBtn.className = btnNoClass;\n            domNoBtn.innerText = translation.no;\n            domNoBtn.onclick = () => govVote(cProposal.Hash, 2);\n\n            const domYesBtn = document.createElement('button');\n            domYesBtn.className = btnYesClass;\n            domYesBtn.innerText = translation.yes;\n            domYesBtn.onclick = () => govVote(cProposal.Hash, 1);\n\n            // Add border radius to last row\n            if (arrProposals.length - 1 == i) {\n                domVoteBtns.classList.add('bbrr-7p');\n            }\n\n            domVoteBtns.classList.add('for-desktop');\n            domVoteBtns.appendChild(domNoBtn);\n            domVoteBtns.appendChild(domYesBtn);\n\n            domNoBtn.setAttribute(\n                'onclick',\n                `MPW.govVote('${cProposal.Hash}', 2)`\n            );\n            domYesBtn.setAttribute(\n                'onclick',\n                `MPW.govVote('${cProposal.Hash}', 1);`\n            );\n            voteBtn = domNoBtn.outerHTML + domYesBtn.outerHTML;\n        }\n\n        // Create extended row for mobile\n        const mobileDomRow = domTable.insertRow();\n        const mobileExtended = mobileDomRow.insertCell();\n        mobileExtended.style = 'vertical-align: middle;';\n        if (domTable.id == 'proposalsTableBody') {\n            mobileExtended.id = `governMob${i}`;\n        } else if (domTable.id == 'proposalsContestedTableBody') {\n            mobileExtended.id = `governMobCon${i}`;\n        }\n        mobileExtended.colSpan = '2';\n        mobileExtended.classList.add('text-left');\n        mobileExtended.classList.add('d-none');\n        mobileExtended.classList.add('for-mobile');\n        mobileExtended.innerHTML = `\n        <div class=\"row pt-2\">\n            <div class=\"col-5 fs-13 fw-600\">\n                <div class=\"governMobDot\"></div> ${translation.govTablePayment}\n            </div>\n            <div class=\"col-7\">\n                <span class=\"governValues\"><b>${sanitizeHTML(\n                    parseInt(cProposal.MonthlyPayment).toLocaleString(\n                        'en-gb',\n                        ',',\n                        '.'\n                    )\n                )}</b> <span class=\"governMarked\">${\n            cChainParams.current.TICKER\n        }</span> <span style=\"margin-left:10px; margin-right: 2px;\" class=\"governMarked governFiatSize\">${strProposalCurrency}</span></b></span>\n        \n                <span class=\"governInstallments\"> ${sanitizeHTML(\n                    cProposal['RemainingPaymentCount']\n                )} ${translation.proposalPaymentsRemaining} <b>${sanitizeHTML(\n            parseInt(cProposal.TotalPayment).toLocaleString('en-gb', ',', '.')\n        )} ${cChainParams.current.TICKER}</b> ${\n            translation.proposalPaymentTotal\n        }</span>\n            </div>\n        </div>\n        <hr class=\"governHr\">\n        <div class=\"row\">\n            <div class=\"col-5 fs-13 fw-600\">\n                <div class=\"governMobDot\"></div> ${translation.govTableVotes}\n            </div>\n            <div class=\"col-7\">\n                <b>${parseFloat(nLocalPercent).toLocaleString(\n                    'en-gb',\n                    { minimumFractionDigits: 0, maximumFractionDigits: 1 },\n                    ',',\n                    '.'\n                )}%</b>\n                <small class=\"votesBg\"> <b><div class=\"votesYes\" style=\"display:inline;\"> ${sanitizeHTML(\n                    Yeas\n                )} </div></b> /\n                <b><div class=\"votesNo\" style=\"display:inline;\"> ${sanitizeHTML(\n                    Nays\n                )} </div></b></small>\n            </div>\n        </div>\n        <hr class=\"governHr\">\n        <div class=\"row pb-2\">\n            <div class=\"col-5 fs-13 fw-600\">\n                <div class=\"governMobDot\"></div> ${translation.govTableVote}\n            </div>\n            <div class=\"col-7\">\n                ${voteBtn}\n            </div>\n        </div>`;\n\n        i++;\n    }\n\n    // Show allocated budget\n    if (domTable.id == 'proposalsTableBody') {\n        const strAlloc = sanitizeHTML(\n            totalAllocatedAmount.toLocaleString('en-gb')\n        );\n        doms.domAllocatedGovernanceBudget.innerHTML = strAlloc;\n        doms.domAllocatedGovernanceBudget2.innerHTML = strAlloc;\n\n        // Update allocated budget in user's currency\n        const nCurrencyValue = totalAllocatedAmount * nPrice;\n        const { nValue } = optimiseCurrencyLocale(nCurrencyValue);\n        const strAllocCurrency =\n            nValue.toLocaleString('en-gb', cLocale) +\n            ' <span style=\"color:#8b38ff;\">' +\n            strCurrency.toUpperCase() +\n            '</span>';\n        doms.domAllocatedGovernanceBudgetValue.innerHTML = strAllocCurrency;\n        doms.domAllocatedGovernanceBudgetValue2.innerHTML = strAllocCurrency;\n    }\n}\n\nexport async function updateMasternodeTab() {\n    //TODO: IN A FUTURE ADD MULTI-MASTERNODE SUPPORT BY SAVING MNs with which you logged in the past.\n    // Ensure a wallet is loaded\n    doms.domMnTextErrors.innerHTML = '';\n    doms.domAccessMasternode.style.display = 'none';\n    doms.domCreateMasternode.style.display = 'none';\n    doms.domMnDashboard.style.display = 'none';\n\n    if (!wallet.isLoaded()) {\n        doms.domMnTextErrors.innerHTML =\n            'Please ' +\n            ((await hasEncryptedWallet()) ? 'unlock' : 'import') +\n            ' your <b>COLLATERAL WALLET</b> first.';\n        return;\n    }\n\n    if (!mempool.getConfirmed().length) {\n        doms.domMnTextErrors.innerHTML =\n            'Your wallet is empty or still loading, re-open the tab in a few seconds!';\n        return;\n    }\n\n    const database = await Database.getInstance();\n\n    let cMasternode = await database.getMasternode();\n    // If the collateral is missing (spent, or switched wallet) then remove the current MN\n    if (cMasternode) {\n        if (\n            !mempool\n                .getConfirmed()\n                .find((utxo) => isMasternodeUTXO(utxo, cMasternode))\n        ) {\n            database.removeMasternode();\n            cMasternode = null;\n        }\n    }\n\n    doms.domControlMasternode.style.display = cMasternode ? 'block' : 'none';\n\n    // first case: the wallet is not HD and it is not hardware, so in case the wallet has collateral the user can check its status and do simple stuff like voting\n    if (!wallet.isHD()) {\n        doms.domMnAccessMasternodeText.innerHTML =\n            doms.masternodeLegacyAccessText;\n        doms.domMnTxId.style.display = 'none';\n        // Find the first UTXO matching the expected collateral size\n        const cCollaUTXO = mempool\n            .getConfirmed()\n            .find(\n                (cUTXO) => cUTXO.sats === cChainParams.current.collateralInSats\n            );\n        const balance = getBalance(false);\n        if (cCollaUTXO) {\n            if (cMasternode) {\n                await refreshMasternodeData(cMasternode);\n                doms.domMnDashboard.style.display = '';\n            } else {\n                doms.domMnTxId.style.display = 'none';\n                doms.domccessMasternode.style.display = 'block';\n            }\n        } else if (balance < cChainParams.current.collateralInSats) {\n            // The user needs more funds\n            doms.domMnTextErrors.innerHTML =\n                'You need <b>' +\n                (cChainParams.current.collateralInSats - balance) / COIN +\n                ' more ' +\n                cChainParams.current.TICKER +\n                '</b> to create a Masternode!';\n        } else {\n            // The user has the funds, but not an exact collateral, prompt for them to create one\n            doms.domCreateMasternode.style.display = 'block';\n            doms.domMnTxId.style.display = 'none';\n            doms.domMnTxId.innerHTML = '';\n        }\n    } else {\n        doms.domMnTxId.style.display = 'none';\n        doms.domMnTxId.innerHTML = '';\n        doms.domMnAccessMasternodeText.innerHTML = doms.masternodeHDAccessText;\n\n        // First UTXO for each address in HD\n        const mapCollateralAddresses = new Map();\n\n        // Aggregate all valid Masternode collaterals into a map of Address <--> Collateral\n        for (const cUTXO of mempool.getConfirmed()) {\n            if (cUTXO.sats !== cChainParams.current.collateralInSats) continue;\n            mapCollateralAddresses.set(cUTXO.path, cUTXO);\n        }\n        const fHasCollateral = mapCollateralAddresses.size > 0;\n\n        // If there's no loaded MN, but valid collaterals, display the configuration screen\n        if (!cMasternode && fHasCollateral) {\n            doms.domMnTxId.style.display = 'block';\n            doms.domAccessMasternode.style.display = 'block';\n\n            for (const [key] of mapCollateralAddresses) {\n                const option = document.createElement('option');\n                option.value = key;\n                option.innerText = await wallet.getAddress(key);\n                doms.domMnTxId.appendChild(option);\n            }\n        }\n\n        // If there's no collateral found, display the creation UI\n        if (!fHasCollateral) doms.domCreateMasternode.style.display = 'block';\n\n        // If we have a collateral and a loaded Masternode, display the Dashboard\n        if (fHasCollateral && cMasternode) {\n            // Refresh the display\n            refreshMasternodeData(cMasternode);\n            doms.domMnDashboard.style.display = '';\n        }\n    }\n}\n\nasync function refreshMasternodeData(cMasternode, fAlert = false) {\n    const cMasternodeData = await cMasternode.getFullData();\n    if (debug) {\n        console.log('---- NEW MASTERNODE DATA (Debug Mode) ----');\n        console.log(cMasternodeData);\n        console.log('---- END MASTERNODE DATA (Debug Mode) ----');\n    }\n\n    // If we have MN data available, update the dashboard\n    if (cMasternodeData && cMasternodeData.status !== 'MISSING') {\n        doms.domMnTextErrors.innerHTML = '';\n        doms.domMnProtocol.innerText = `(${sanitizeHTML(\n            cMasternodeData.version\n        )})`;\n        doms.domMnStatus.innerText = sanitizeHTML(cMasternodeData.status);\n        doms.domMnNetType.innerText = sanitizeHTML(\n            cMasternodeData.network.toUpperCase()\n        );\n        doms.domMnNetIP.innerText = cMasternode.addr;\n        doms.domMnLastSeen.innerText = new Date(\n            cMasternodeData.lastseen * 1000\n        ).toLocaleTimeString();\n    }\n\n    if (cMasternodeData.status === 'MISSING') {\n        doms.domMnTextErrors.innerHTML =\n            'Masternode is currently <b>OFFLINE</b>';\n        if (!wallet.isViewOnly()) {\n            createAlert('warning', ALERTS.MN_OFFLINE_STARTING, 6000);\n            // try to start the masternode\n            const started = await cMasternode.start();\n            if (started) {\n                doms.domMnTextErrors.innerHTML = ALERTS.MN_STARTED;\n                createAlert('success', ALERTS.MN_STARTED_ONLINE_SOON, 6000);\n                const database = await Database.getInstance();\n                await database.addMasternode(cMasternode);\n            } else {\n                doms.domMnTextErrors.innerHTML = ALERTS.MN_START_FAILED;\n                createAlert('warning', ALERTS.MN_START_FAILED, 6000);\n            }\n        }\n    } else if (\n        cMasternodeData.status === 'ENABLED' ||\n        cMasternodeData.status === 'PRE_ENABLED'\n    ) {\n        if (fAlert)\n            createAlert(\n                'success',\n                `${ALERTS.MN_STATUS_IS} <b> ${sanitizeHTML(\n                    cMasternodeData.status\n                )} </b>`,\n                6000\n            );\n        const database = await Database.getInstance();\n        await database.addMasternode(cMasternode);\n    } else if (cMasternodeData.status === 'REMOVED') {\n        const state = cMasternodeData.status;\n        doms.domMnTextErrors.innerHTML = tr(ALERTS.MN_STATE, [\n            { state: state },\n        ]);\n        if (fAlert)\n            createAlert(\n                'warning',\n                tr(ALERTS.MN_STATE, [{ state: state }]),\n                6000\n            );\n    } else {\n        // connection problem\n        doms.domMnTextErrors.innerHTML = ALERTS.MN_CANT_CONNECT;\n        if (fAlert) createAlert('warning', ALERTS.MN_CANT_CONNECT, 6000);\n    }\n\n    // Return the data in case the caller needs additional context\n    return cMasternodeData;\n}\n\nexport async function createProposal() {\n    // Must have a wallet\n    if (!wallet.isLoaded()) {\n        return createAlert('warning', ALERTS.PROPOSAL_IMPORT_FIRST, 4500);\n    }\n    // Wallet must be encrypted\n    if (!(await hasEncryptedWallet())) {\n        return createAlert(\n            'warning',\n            tr(translation.popupProposalEncryptFirst, [\n                { button: translation.secureYourWallet },\n            ]),\n            4500\n        );\n    }\n    // Wallet must be unlocked\n    if (\n        wallet.isViewOnly() &&\n        !(await restoreWallet(translation.walletUnlockProposal))\n    ) {\n        return;\n    }\n    // Must have enough funds\n    if (getBalance() * COIN < cChainParams.current.proposalFee) {\n        return createAlert('warning', ALERTS.PROPOSAL_NOT_ENOUGH_FUNDS, 4500);\n    }\n\n    // Create the popup, wait for the user to confirm or cancel\n    const fConfirmed = await confirmPopup({\n        title: `${translation.popupCreateProposal} (${\n            translation.popupCreateProposalCost\n        } ${cChainParams.current.proposalFee / COIN} ${\n            cChainParams.current.TICKER\n        })`,\n        html: `<input id=\"proposalTitle\" maxlength=\"20\" placeholder=\"${\n            translation.popupProposalName\n        }\" style=\"text-align: center;\"><br>\n               <input id=\"proposalUrl\" maxlength=\"64\" placeholder=\"${\n                   translation.popupExample\n               } https://forum.pivx.org/...\" style=\"text-align: center;\"><br>\n               <input type=\"number\" id=\"proposalCycles\" min=\"1\" max=\"${\n                   cChainParams.current.maxPaymentCycles\n               }\" placeholder=\"${\n            translation.popupProposalDuration\n        }\" style=\"text-align: center;\"><br>\n               <input type=\"number\" id=\"proposalPayment\" min=\"10\" max=\"${\n                   cChainParams.current.maxPayment / COIN\n               }\" placeholder=\"${cChainParams.current.TICKER} ${\n            translation.popupProposalPerCycle\n        }\" style=\"text-align: center;\"><br>\n               <input id=\"proposalAddress\" maxlength=\"34\" placeholder=\"${\n                   translation.popupProposalAddress\n               }\" style=\"text-align: center; ${\n            !fAdvancedMode ? 'display: none' : ''\n        }\"><br>`,\n    });\n\n    // If the user cancelled, then we return\n    if (!fConfirmed) return;\n\n    const strTitle = document.getElementById('proposalTitle').value.trim();\n    const strUrl = document.getElementById('proposalUrl').value.trim();\n    const numCycles = parseInt(\n        document.getElementById('proposalCycles').value.trim()\n    );\n    const numPayment = parseInt(\n        document.getElementById('proposalPayment').value.trim()\n    );\n\n    // If Advanced Mode is enabled and an address is given, use the provided address, otherwise, generate a new one\n    const strAddress =\n        document.getElementById('proposalAddress').value.trim() ||\n        (await wallet.getNewAddress())[0];\n    const nextSuperblock = await Masternode.getNextSuperblock();\n    const proposal = {\n        name: strTitle,\n        url: strUrl,\n        nPayments: numCycles,\n        start: nextSuperblock,\n        address: strAddress,\n        monthlyPayment: numPayment * COIN,\n    };\n\n    const isValid = Masternode.isValidProposal(proposal);\n    if (!isValid.ok) {\n        createAlert(\n            'warning',\n            `${ALERTS.PROPOSAL_INVALID_ERROR} ${isValid.err}`,\n            7500\n        );\n        return;\n    }\n\n    const hash = Masternode.createProposalHash(proposal);\n    const { ok, txid } = await createAndSendTransaction({\n        address: hash,\n        amount: cChainParams.current.proposalFee,\n        isProposal: true,\n    });\n    if (ok) {\n        proposal.txid = txid;\n        const database = await Database.getInstance();\n\n        // Fetch our Account, add the proposal to it\n        const account = await database.getAccount();\n        account.localProposals.push(proposal);\n\n        // Update the DB\n        await database.updateAccount(account);\n        createAlert('success', translation.PROPOSAL_CREATED, 10000);\n        updateGovernanceTab();\n    }\n}\n\nexport function refreshChainData() {\n    const cNet = getNetwork();\n    // If in offline mode: don't sync ANY data or connect to the internet\n    if (!cNet.enabled)\n        return console.warn(\n            'Offline mode active: For your security, the wallet will avoid ALL internet requests.'\n        );\n    if (!wallet.isLoaded()) return;\n\n    // Fetch block count + UTXOs, update the UI for new transactions\n    cNet.getBlockCount().then((_) => {\n        // Fetch latest Activity\n        activityDashboard.update(true);\n\n        // If it's open: update the Governance Dashboard\n        if (doms.domGovTab.classList.contains('active')) {\n            updateGovernanceTab();\n        }\n    });\n    getBalance(true);\n}\n\n// A safety mechanism enabled if the user attempts to leave without encrypting/saving their keys\nexport const beforeUnloadListener = (evt) => {\n    evt.preventDefault();\n    // Disable Save your wallet warning on unload\n    createAlert('warning', ALERTS.SAVE_WALLET_PLEASE, 10000);\n    // Most browsers ignore this nowadays, but still, keep it 'just incase'\n    return (evt.returnValue = translation.BACKUP_OR_ENCRYPT_WALLET);\n};\n\n/**\n * @typedef {Object} SettingsDOM - An object that contains the DOM elements for settings pages.\n * @property {HTMLElement} btn - The button to switch to this setting type.\n * @property {HTMLElement} section - The container for this setting type.\n */\n\n/**\n * Returns a list of all pages and their DOM elements.\n *\n * This must be a function, since, the DOM elements are `undefined` until\n * after the startup sequence.\n *\n * Types are inferred.\n */\nfunction getSettingsPages() {\n    return {\n        /** @type {SettingsDOM} */\n        wallet: {\n            btn: doms.domWalletSettingsBtn,\n            section: doms.domWalletSettings,\n        },\n        /** @type {SettingsDOM} */\n        display: {\n            btn: doms.domDisplaySettingsBtn,\n            section: doms.domDisplaySettings,\n        },\n    };\n}\n\n/**\n * Switch between screens in the settings menu\n * @param {string} page - The name of the setting page to switch to\n */\nexport function switchSettings(page) {\n    const SETTINGS = getSettingsPages();\n    const { btn, section } = SETTINGS[page];\n\n    Object.values(SETTINGS).forEach(({ section, btn }) => {\n        // Set the slider to the proper location\n        if (page == 'display') {\n            doms.domDisplayDecimalsSlider.oninput = function () {\n                doms.domDisplayDecimalsSliderDisplay.innerHTML = this.value;\n                //let val =  ((((doms.domDisplayDecimalsSlider.offsetWidth - 24) / 9) ) * parseInt(this.value));\n\n                //doms.domDisplayDecimalsSliderDisplay.style.marginLeft = (val) + 'px';\n            };\n\n            // Triggers the input event\n            setTimeout(\n                () =>\n                    doms.domDisplayDecimalsSlider.dispatchEvent(\n                        new Event('input')\n                    ),\n                10\n            );\n        }\n        // Hide all settings sections\n        section.classList.add('d-none');\n        // Make all buttons inactive\n        btn.classList.remove('active');\n    });\n\n    // Show selected section and make its button active\n    section.classList.remove('d-none');\n    btn.classList.add('active');\n}\n\nfunction errorHandler(e) {\n    const message = `${translation.unhandledException} <br> ${sanitizeHTML(\n        e.message || e.reason\n    )}`;\n    try {\n        createAlert('warning', message);\n    } catch (_) {\n        // Something as gone wrong, so we fall back to the default alert\n        // This can happen on early errors for example\n        alert(message);\n    }\n}\n\n// This code is ran in the vanity gen worker as well!\n// In which case, window would be not defined.\n// `if (window)` wouldn't work either because\n// window is not defined as opposed to undefined\ntry {\n    window.addEventListener('error', errorHandler);\n    window.addEventListener('unhandledrejection', errorHandler);\n} catch (_) {}\n","import { cChainParams, COIN } from './chain_params.js';\nimport { createAlert } from './misc.js';\nimport { Mempool, UTXO } from './mempool.js';\nimport { getEventEmitter } from './event_bus.js';\nimport {\n    STATS,\n    cStatKeys,\n    cAnalyticsLevel,\n    setExplorer,\n    fAutoSwitch,\n} from './settings.js';\nimport { ALERTS } from './i18n.js';\n\n/**\n * @typedef {Object} XPUBAddress\n * @property {string} type - Type of address (always 'XPUBAddress' for XPUBInfo classes)\n * @property {string} name - PIVX address string\n * @property {string} path - BIP44 path of the address derivation\n * @property {number} transfers - Number of transfers involving the address\n * @property {number} decimals - Decimal places in the amounts (PIVX has 8 decimals)\n * @property {string} balance - Current balance of the address (satoshi)\n * @property {string} totalReceived - Total ever received by the address (satoshi)\n * @property {string} totalSent - Total ever sent from the address (satoshi)\n */\n\n/**\n * @typedef {Object} XPUBInfo\n * @property {number} page - Current response page in a paginated data\n * @property {number} totalPages - Total pages in the paginated data\n * @property {number} itemsOnPage - Number of items on the current page\n * @property {string} address - XPUB string of the address\n * @property {string} balance - Current balance of the xpub (satoshi)\n * @property {string} totalReceived - Total ever received by the xpub (satoshi)\n * @property {string} totalSent - Total ever sent from the xpub (satoshi)\n * @property {string} unconfirmedBalance - Unconfirmed balance of the xpub (satoshi)\n * @property {number} unconfirmedTxs - Number of unconfirmed transactions of the xpub\n * @property {number} txs - Total number of transactions of the xpub\n * @property {string[]?} txids - Transaction ids involving the xpub\n * @property {number?} usedTokens - Number of used token addresses from the xpub\n * @property {XPUBAddress[]?} tokens - Array of used token addresses\n */\n\n/**\n * A historical transaction type.\n * @enum {number}\n */\nexport const HistoricalTxType = {\n    UNKNOWN: 0,\n    STAKE: 1,\n    DELEGATION: 2,\n    UNDELEGATION: 3,\n    RECEIVED: 4,\n    SENT: 5,\n};\n\n/**\n * A historical transaction\n */\nexport class HistoricalTx {\n    /**\n     * @param {HistoricalTxType} type - The type of transaction.\n     * @param {string} id - The transaction ID.\n     * @param {Array<string>} senders - The list of 'input addresses'.\n     * @param {Array<string>} receivers - The list of 'output addresses'.\n     * @param {boolean} shieldedOutputs - If this transaction contains Shield outputs.\n     * @param {number} time - The block time of the transaction.\n     * @param {number} blockHeight - The block height of the transaction.\n     * @param {number} amount - The amount transacted, in coins.\n     */\n    constructor(\n        type,\n        id,\n        senders,\n        receivers,\n        shieldedOutputs,\n        time,\n        blockHeight,\n        amount\n    ) {\n        this.type = type;\n        this.id = id;\n        this.senders = senders;\n        this.receivers = receivers;\n        this.shieldedOutputs = shieldedOutputs;\n        this.time = time;\n        this.blockHeight = blockHeight;\n        this.amount = amount;\n    }\n}\n\n/**\n * Virtual class rapresenting any network backend\n *\n */\nexport class Network {\n    wallet;\n    /**\n     * @param {import('./wallet.js').Wallet} wallet\n     */\n    constructor(wallet) {\n        if (this.constructor === Network) {\n            throw new Error('Initializing virtual class');\n        }\n        this._enabled = true;\n        this.wallet = wallet;\n\n        this.lastWallet = 0;\n        this.isHistorySynced = false;\n    }\n\n    /**\n     * @param {boolean} value\n     */\n    set enabled(value) {\n        if (value !== this._enabled) {\n            getEventEmitter().emit('network-toggle', value);\n            this._enabled = value;\n        }\n    }\n\n    get enabled() {\n        return this._enabled;\n    }\n\n    enable() {\n        this.enabled = true;\n    }\n\n    disable() {\n        this.enabled = false;\n    }\n\n    toggle() {\n        this.enabled = !this.enabled;\n    }\n\n    getFee(bytes) {\n        // TEMPORARY: Hardcoded fee per-byte\n        return bytes * 50; // 50 sat/byte\n    }\n\n    get cachedBlockCount() {\n        throw new Error('cachedBlockCount must be implemented');\n    }\n\n    error() {\n        throw new Error('Error must be implemented');\n    }\n\n    getBlockCount() {\n        throw new Error('getBlockCount must be implemented');\n    }\n\n    sentTransaction() {\n        throw new Error('sendTransaction must be implemented');\n    }\n\n    submitAnalytics(_strType, _cData = {}) {\n        throw new Error('submitAnalytics must be implemented');\n    }\n\n    setWallet(wallet) {\n        this.wallet = wallet;\n    }\n\n    async getTxInfo(_txHash) {\n        throw new Error('getTxInfo must be implemented');\n    }\n}\n\n/**\n *\n */\nexport class ExplorerNetwork extends Network {\n    /**\n     * @param {string} strUrl - Url pointing to the blockbook explorer\n     */\n    constructor(strUrl, wallet) {\n        super(wallet);\n        /**\n         * @type{string}\n         * @public\n         */\n        this.strUrl = strUrl;\n\n        /**\n         * @type{Number}\n         * @private\n         */\n        this.blocks = 0;\n\n        /**\n         * @type {Array<HistoricalTx>}\n         */\n        this.arrTxHistory = [];\n\n        this.historySyncing = false;\n    }\n\n    error() {\n        if (this.enabled) {\n            this.disable();\n            createAlert('warning', ALERTS.CONNECTION_FAILED);\n        }\n    }\n\n    get cachedBlockCount() {\n        return this.blocks;\n    }\n\n    async getBlockCount() {\n        try {\n            getEventEmitter().emit('sync-status', 'start');\n            const { backend } = await (\n                await retryWrapper(fetchBlockbook, `/api/v2/api`)\n            ).json();\n            if (backend.blocks > this.blocks) {\n                console.log(\n                    'New block detected! ' +\n                        this.blocks +\n                        ' --> ' +\n                        backend.blocks\n                );\n                this.blocks = backend.blocks;\n\n                await this.getUTXOs();\n            }\n        } catch (e) {\n            this.error();\n            throw e;\n        } finally {\n            getEventEmitter().emit('sync-status', 'stop');\n        }\n    }\n\n    /**\n     * @typedef {object} BlockbookUTXO\n     * @property {string} txid - The TX hash of the output\n     * @property {number} vout - The Index Position of the output\n     * @property {string} value - The string-based satoshi value of the output\n     * @property {number} height - The block height the TX was confirmed in\n     * @property {number} confirmations - The depth of the TX in the blockchain\n     */\n\n    /**\n     * Fetch UTXOs from the current primary explorer\n     * @param {string} strAddress - Optional address, gets UTXOs without changing MPW's state\n     * @returns {Promise<Array<BlockbookUTXO>>} Resolves when it has finished fetching UTXOs\n     */\n    async getUTXOs(strAddress = '') {\n        // Don't fetch UTXOs if we're already scanning for them!\n        if (!strAddress) {\n            if (!this.wallet || !this.wallet.isLoaded()) return;\n            if (this.isSyncing) return;\n            this.isSyncing = true;\n        }\n        try {\n            let publicKey = strAddress || (await this.wallet.getKeyToExport());\n            // Fetch UTXOs for the key\n            const arrUTXOs = await (\n                await retryWrapper(fetchBlockbook, `/api/v2/utxo/${publicKey}`)\n            ).json();\n\n            // If using MPW's wallet, then sync the UTXOs in MPW's state\n            if (!strAddress) getEventEmitter().emit('utxo', arrUTXOs);\n\n            // Return the UTXOs for additional utility use\n            return arrUTXOs;\n        } catch (e) {\n            console.error(e);\n            this.error();\n        } finally {\n            this.isSyncing = false;\n        }\n    }\n    /**\n     * Fetches UTXOs full info\n     * @param {Object} cUTXO - object-formatted UTXO\n     * @returns {Promise<UTXO>} Promise that resolves with the full info of the UTXO\n     */\n    async getUTXOFullInfo(cUTXO) {\n        const cTx = await (\n            await retryWrapper(\n                fetchBlockbook,\n                `/api/v2/tx-specific/${cUTXO.txid}`\n            )\n        ).json();\n        const cVout = cTx.vout[cUTXO.vout];\n\n        let path;\n        if (cUTXO.path) {\n            path = cUTXO.path.split('/');\n            path[2] =\n                (this.wallet.isHardwareWallet()\n                    ? cChainParams.current.BIP44_TYPE_LEDGER\n                    : cChainParams.current.BIP44_TYPE) + \"'\";\n            this.lastWallet = Math.max(parseInt(path[5]), this.lastWallet);\n            path = path.join('/');\n        }\n\n        const isColdStake = cVout.scriptPubKey.type === 'coldstake';\n        const isStandard = cVout.scriptPubKey.type === 'pubkeyhash';\n        const isReward = cTx.vout[0].scriptPubKey.hex === '';\n        // We don't know what this is\n        if (!isColdStake && !isStandard) {\n            return null;\n        }\n\n        return new UTXO({\n            id: cUTXO.txid,\n            path,\n            sats: Math.round(cVout.value * COIN),\n            script: cVout.scriptPubKey.hex,\n            vin: cTx?.vin || [],\n            vout: cVout.n,\n            height: this.cachedBlockCount - (cTx.confirmations - 1),\n            status: cTx.confirmations < 1 ? Mempool.PENDING : Mempool.CONFIRMED,\n            isDelegate: isColdStake,\n            isReward,\n        });\n    }\n\n    /**\n     * Fetch an XPub's basic information\n     * @param {string} strXPUB - The xpub to fetch info for\n     * @returns {Promise<XPUBInfo>} - A JSON class of aggregated XPUB info\n     */\n    async getXPubInfo(strXPUB) {\n        return await (\n            await retryWrapper(fetchBlockbook, `/api/v2/xpub/${strXPUB}`)\n        ).json();\n    }\n\n    async sendTransaction(hex) {\n        try {\n            const data = await (\n                await retryWrapper(fetchBlockbook, '/api/v2/sendtx/', {\n                    method: 'post',\n                    body: hex,\n                })\n            ).json();\n\n            // Throw and catch if the data is not a TXID\n            if (!data.result || data.result.length !== 64) throw data;\n\n            console.log('Transaction sent! ' + data.result);\n            getEventEmitter().emit('transaction-sent', true, data.result);\n            return data.result;\n        } catch (e) {\n            getEventEmitter().emit('transaction-sent', false, e);\n            return false;\n        }\n    }\n\n    /**\n     * Synchronise a partial chunk of our TX history\n     * @param {boolean} [fNewOnly] - Whether to sync ONLY new transactions\n     */\n    async syncTxHistoryChunk(fNewOnly = false) {\n        // Do not allow multiple calls at once\n        if (this.historySyncing) {\n            return this.arrTxHistory;\n        }\n\n        try {\n            if (!this.enabled || !this.wallet || !this.wallet.isLoaded())\n                return this.arrTxHistory;\n            this.historySyncing = true;\n            const nHeight = this.arrTxHistory.length\n                ? this.arrTxHistory[this.arrTxHistory.length - 1].blockHeight\n                : 0;\n            const mapPaths = new Map();\n\n            // Form the API call using our wallet information\n            const strKey = await this.wallet.getKeyToExport();\n            const strRoot = `/api/v2/${\n                this.wallet.isHD() ? 'xpub/' : 'address/'\n            }${strKey}`;\n            const strCoreParams = `?details=txs&tokens=derived&pageSize=200`;\n            const strAPI = strRoot + strCoreParams;\n\n            // If we have a known block height, check for incoming transactions within the last 60 blocks\n            const cRecentTXs =\n                this.blocks > 0\n                    ? await (\n                          await retryWrapper(\n                              fetchBlockbook,\n                              `${strAPI}&from=${this.blocks - 60}`\n                          )\n                      ).json()\n                    : {};\n\n            // If we do not have full history, then load more historical TXs in a slice\n            const cData =\n                !fNewOnly && !this.isHistorySynced\n                    ? await (\n                          await retryWrapper(\n                              fetchBlockbook,\n                              `${strAPI}&to=${nHeight ? nHeight - 1 : 0}`\n                          )\n                      ).json()\n                    : {};\n            if (this.wallet.isHD() && (cData.tokens || cRecentTXs.tokens)) {\n                // Map all address <--> derivation paths\n                // - From historical transactions\n                if (cData.tokens) {\n                    cData.tokens.forEach((cAddrPath) =>\n                        mapPaths.set(cAddrPath.name, cAddrPath.path)\n                    );\n                }\n                // - From new transactions\n                if (cRecentTXs.tokens) {\n                    cRecentTXs.tokens.forEach((cAddrPath) =>\n                        mapPaths.set(cAddrPath.name, cAddrPath.path)\n                    );\n                }\n            } else {\n                mapPaths.set(strKey, ':)');\n            }\n\n            // Process our aggregated history data\n            if (\n                (cData && cData.transactions) ||\n                (cRecentTXs && cRecentTXs.transactions)\n            ) {\n                // Process Older (historical) TXs\n                const arrOlderTXs = this.toHistoricalTXs(\n                    cData.transactions || [],\n                    mapPaths\n                );\n\n                // Process Recent TXs, then add them manually on the basis that they are NOT already known in history\n                const arrRecentTXs = this.toHistoricalTXs(\n                    cRecentTXs.transactions || [],\n                    mapPaths\n                );\n                for (const cTx of arrRecentTXs) {\n                    if (\n                        !this.arrTxHistory.find((a) => a.id === cTx.id) &&\n                        !arrOlderTXs.find((a) => a.id === cTx.id)\n                    ) {\n                        // No identical Tx, so prepend it!\n                        this.arrTxHistory.unshift(cTx);\n                    }\n                }\n                this.arrTxHistory = this.arrTxHistory.concat(arrOlderTXs);\n\n                // If the results don't match the full 'max/requested results', then we know the history is complete\n                if (\n                    cData.transactions &&\n                    cData.transactions.length !== cData.itemsOnPage\n                ) {\n                    this.isHistorySynced = true;\n                }\n            }\n            return this.arrTxHistory;\n        } catch (e) {\n            console.error(e);\n        } finally {\n            this.historySyncing = false;\n        }\n    }\n\n    /**\n     * Convert a list of Blockbook transactions to HistoricalTxs\n     * @param {Array<object>} arrTXs - An array of the Blockbook TXs\n     * @param {Map<String, String>} mapPaths - A map of the derivation paths for involved addresses\n     * @returns {Array<HistoricalTx>} - A new array of `HistoricalTx`-formatted transactions\n     */\n    toHistoricalTXs(arrTXs, mapPaths) {\n        /**\n         * A function to sum a list of inputs (vin) or outputs (vout)\n         * @type {(v: Array<{addresses: String[], value: Number}>) => Number}\n         */\n        const txSum = (v) =>\n            v.reduce(\n                (t, s) =>\n                    t +\n                    (s.addresses &&\n                    s.addresses.some((strAddr) => mapPaths.has(strAddr))\n                        ? parseInt(s.value)\n                        : 0),\n                0\n            );\n\n        return arrTXs\n            .map((tx) => {\n                // The total 'delta' or change in balance, from the Tx's sums\n                let nAmount = (txSum(tx.vout) - txSum(tx.vin)) / COIN;\n\n                // If this Tx creates any Shield outputs\n                // Note: shielOuts typo intended, this is a Blockbook error\n                const fShieldOuts = Number.isFinite(tx.shielOuts);\n\n                // (Un)Delegated coins in this transaction, if any\n                let nDelegated = 0;\n\n                // The address(es) delegated to, if any\n                let strDelegatedAddr = '';\n\n                // The sender addresses, if any\n                const arrSenders =\n                    tx.vin?.flatMap((vin) => vin.addresses) || [];\n\n                // The receiver addresses, if any\n                let arrReceivers =\n                    tx.vout?.flatMap((vout) => vout.addresses) || [];\n                // Pretty-fy script addresses\n                arrReceivers = arrReceivers.map((addr) =>\n                    addr.startsWith('OP_') ? 'Contract' : addr\n                );\n\n                // Figure out the type, based on the Tx's properties\n                let type = HistoricalTxType.UNKNOWN;\n                if (\n                    !fShieldOuts &&\n                    tx?.vout[0]?.addresses[0]?.startsWith('CoinStake')\n                ) {\n                    type = HistoricalTxType.STAKE;\n                } else if (nAmount > 0 || (nAmount > 0 && fShieldOuts)) {\n                    type = HistoricalTxType.RECEIVED;\n                    // If this contains Shield outputs, then we received them\n                    if (fShieldOuts)\n                        nAmount = parseInt(tx.valueBalanceSat) / COIN;\n                } else if (nAmount < 0 || (nAmount < 0 && fShieldOuts)) {\n                    // Check vins for undelegations\n                    for (const vin of tx.vin) {\n                        const fDelegation = vin.addresses?.some((addr) =>\n                            addr.startsWith(cChainParams.current.STAKING_PREFIX)\n                        );\n                        if (fDelegation) {\n                            nDelegated -= parseInt(vin.value);\n                        }\n                    }\n\n                    // Check vouts for delegations\n                    for (const out of tx.vout) {\n                        strDelegatedAddr =\n                            out.addresses?.find((addr) =>\n                                addr.startsWith(\n                                    cChainParams.current.STAKING_PREFIX\n                                )\n                            ) || strDelegatedAddr;\n\n                        const fDelegation = !!strDelegatedAddr;\n                        if (fDelegation) {\n                            nDelegated += parseInt(out.value);\n                        }\n                    }\n\n                    // If a delegation was made, then display the value delegated\n                    if (nDelegated > 0) {\n                        type = HistoricalTxType.DELEGATION;\n                        nAmount = nDelegated / COIN;\n                    } else if (nDelegated < 0) {\n                        type = HistoricalTxType.UNDELEGATION;\n                        nAmount = nDelegated / COIN;\n                    } else {\n                        type = HistoricalTxType.SENT;\n                        // If this contains Shield outputs, then we sent them\n                        if (fShieldOuts)\n                            nAmount = parseInt(tx.valueBalanceSat) / COIN;\n                    }\n                }\n\n                return new HistoricalTx(\n                    type,\n                    tx.txid,\n                    arrSenders,\n                    nDelegated !== 0 ? [strDelegatedAddr] : arrReceivers,\n                    fShieldOuts,\n                    tx.blockTime,\n                    tx.blockHeight,\n                    Math.abs(nAmount)\n                );\n            })\n            .filter((tx) => tx.amount != 0);\n    }\n\n    async setWallet(wallet) {\n        // If the public Master Key (xpub, address...) is different, then wipe TX history\n        if (\n            (await this.wallet?.getKeyToExport()) !==\n            (await wallet?.getKeyToExport())\n        ) {\n            this.arrTxHistory = [];\n        }\n\n        // Set the key\n        this.wallet = wallet;\n    }\n\n    async getTxInfo(txHash) {\n        const req = await retryWrapper(fetchBlockbook, `/api/v2/tx/${txHash}`);\n        return await req.json();\n    }\n\n    // PIVX Labs Analytics: if you are a user, you can disable this FULLY via the Settings.\n    // ... if you're a developer, we ask you to keep these stats to enhance upstream development,\n    // ... but you are free to completely strip MPW of any analytics, if you wish, no hard feelings.\n    submitAnalytics(strType, cData = {}) {\n        if (!this.enabled) return;\n\n        // TODO: rebuild Labs Analytics, submitAnalytics() will be disabled at code-level until this is live again\n        /* eslint-disable */\n        return;\n\n        // Limit analytics here to prevent 'leakage' even if stats are implemented incorrectly or forced\n        let i = 0,\n            arrAllowedKeys = [];\n        for (i; i < cAnalyticsLevel.stats.length; i++) {\n            const cStat = cAnalyticsLevel.stats[i];\n            arrAllowedKeys.push(cStatKeys.find((a) => STATS[a] === cStat));\n        }\n\n        // Check if this 'stat type' was granted permissions\n        if (!arrAllowedKeys.includes(strType)) return false;\n\n        // Format\n        const cStats = { type: strType, ...cData };\n\n        // Send to Labs Analytics\n        const request = new XMLHttpRequest();\n        request.open('POST', 'https://scpscan.net/mpw/statistic', true);\n        request.setRequestHeader('Content-Type', 'application/json');\n        request.send(JSON.stringify(cStats));\n        return true;\n    }\n}\n\nlet _network = null;\n\n/**\n * Sets the network in use by MPW.\n * @param {ExplorerNetwork} network - network to use\n */\nexport function setNetwork(network) {\n    _network = network;\n}\n\n/**\n * Gets the network in use by MPW.\n * @returns {ExplorerNetwork?} Returns the network in use, may be null if MPW hasn't properly loaded yet.\n */\nexport function getNetwork() {\n    return _network;\n}\n\n/**\n * A Fetch wrapper which uses the current Blockbook Network's base URL\n * @param {string} api - The specific Blockbook api to call\n * @param {RequestInit} options - The Fetch options\n * @returns {Promise<Response>} - The unresolved Fetch promise\n */\nexport function fetchBlockbook(api, options) {\n    return fetch(_network.strUrl + api, options);\n}\n\n/**\n * A wrapper for Blockbook calls which can, in the event of an unresponsive explorer,\n * seamlessly attempt the same call on multiple other explorers until success.\n * @param {Function} func - The function to re-attempt with\n * @param  {...any} args - The arguments to pass to the function\n */\nasync function retryWrapper(func, ...args) {\n    // Track internal errors from the wrapper\n    let err;\n\n    // If allowed by the user, Max Tries is ALL MPW-supported explorers, otherwise, restrict to only the current one.\n    let nMaxTries = cChainParams.current.Explorers.length;\n    let retries = 0;\n\n    // The explorer index we started at\n    let nIndex = cChainParams.current.Explorers.findIndex(\n        (a) => a.url === getNetwork().strUrl\n    );\n\n    // Run the call until successful, or all attempts exhausted\n    while (retries < nMaxTries) {\n        try {\n            // Call the passed function with the arguments\n            const res = await func(...args);\n\n            // If the endpoint is non-OK, assume it's an error\n            if (!res.ok) throw res;\n\n            // Return the result if successful\n            return res;\n        } catch (error) {\n            err = error;\n\n            // If allowed, switch explorers\n            if (!fAutoSwitch) throw err;\n            nIndex = (nIndex + 1) % cChainParams.current.Explorers.length;\n            const cNewExplorer = cChainParams.current.Explorers[nIndex];\n\n            // Set the explorer at Network-class level, then as a hacky workaround for the current callback; we\n            // ... adjust the internal URL to the new explorer.\n            getNetwork().strUrl = cNewExplorer.url;\n            setExplorer(cNewExplorer, true);\n\n            // Bump the attempts, and re-try next loop\n            retries++;\n        }\n    }\n\n    // Throw an error so the calling code knows the operation failed\n    throw err;\n}\n","import createXpub from 'create-xpub';\nimport { ALERTS, tr } from './i18n.js';\nimport AppBtc from '@ledgerhq/hw-app-btc';\nimport TransportWebUSB from '@ledgerhq/hw-transport-webusb';\nimport { createAlert, sleep } from './misc.js';\n\nlet transport;\nexport let cHardwareWallet = null;\nexport let strHardwareName = '';\nexport async function getHardwareWalletKeys(\n    path,\n    xpub = false,\n    verify = false,\n    _attempts = 0\n) {\n    try {\n        // Check if we haven't setup a connection yet OR the previous connection disconnected\n        if (!cHardwareWallet || transport._disconnectEmitted) {\n            transport = await TransportWebUSB.create();\n            cHardwareWallet = new AppBtc({ transport, currency: 'PIVX' });\n        }\n\n        // Update device info and fetch the pubkey\n        strHardwareName =\n            transport.device.manufacturerName +\n            ' ' +\n            transport.device.productName;\n\n        // Prompt the user in both UIs\n        if (verify) createAlert('info', ALERTS.WALLET_CONFIRM_L, 3500);\n        const cPubKey = await cHardwareWallet.getWalletPublicKey(path, {\n            verify,\n            format: 'legacy',\n        });\n\n        if (xpub) {\n            return createXpub({\n                depth: 3,\n                childNumber: 2147483648,\n                chainCode: cPubKey.chainCode,\n                publicKey: cPubKey.publicKey,\n            });\n        } else {\n            return cPubKey.publicKey;\n        }\n    } catch (e) {\n        if (e.message.includes('denied by the user')) {\n            // User denied an operation\n            return false;\n        }\n\n        // If there's no device, nudge the user to plug it in.\n        if (e.message.toLowerCase().includes('no device selected')) {\n            createAlert('info', ALERTS.WALLET_NO_HARDWARE, 10000);\n            return false;\n        }\n\n        // If the device is unplugged, or connection lost through other means (such as spontanious device explosion)\n        if (e.message.includes(\"Failed to execute 'transferIn'\")) {\n            createAlert(\n                'info',\n                tr(ALERTS.WALLET_HARDWARE_CONNECTION_LOST, [\n                    {\n                        hardwareWallet: strHardwareName,\n                    },\n                ]),\n                10000\n            );\n            return false;\n        }\n        if (_attempts < 10) {\n            // This is an ugly hack :(\n            // in the event where multiple parts of the code decide to ask for an address, just\n            // Retry at most 10 times waiting 200ms each time\n            await sleep(200);\n            return await getHardwareWalletKeys(\n                path,\n                xpub,\n                verify,\n                _attempts + 1\n            );\n        }\n\n        // If the ledger is busy, just nudge the user.\n        if (e.message.includes('is busy')) {\n            createAlert(\n                'info',\n                tr(ALERTS.WALLET_HARDWARE_BUSY, [\n                    {\n                        hardwareWallet: strHardwareName,\n                    },\n                ]),\n                7500\n            );\n            return false;\n        }\n\n        // Check if this is an expected error\n        if (!e.statusCode || !LEDGER_ERRS.has(e.statusCode)) {\n            console.error(\n                'MISSING LEDGER ERROR-CODE TRANSLATION! - Please report this below error on our GitHub so we can handle it more nicely!'\n            );\n            console.error(e);\n        }\n\n        // Translate the error to a user-friendly string (if possible)\n        createAlert(\n            'warning',\n            tr(ALERTS.WALLET_HARDWARE_ERROR, [\n                {\n                    hardwareWallet: strHardwareName,\n                },\n                {\n                    error: LEDGER_ERRS.get(e.statusCode),\n                },\n            ]),\n            5500\n        );\n\n        return false;\n    }\n}\n\n// Ledger Hardware wallet constants\nexport const LEDGER_ERRS = new Map([\n    // Ledger error code <--> User-friendly string\n    [25870, 'Open the PIVX app on your device'],\n    [25873, 'Open the PIVX app on your device'],\n    [57408, 'Navigate to the PIVX app on your device'],\n    [27157, 'Wrong app! Open the PIVX app on your device'],\n    [27266, 'Wrong app! Open the PIVX app on your device'],\n    [27904, 'Wrong app! Open the PIVX app on your device'],\n    [27010, 'Unlock your Ledger, then try again!'],\n    [27404, 'Unlock your Ledger, then try again!'],\n]);\n","const buff_to_base64 = (buff) => btoa(String.fromCharCode.apply(null, buff));\n\nconst base64_to_buf = (b64) =>\n    Uint8Array.from(atob(b64), (c) => c.charCodeAt(null));\n\nconst enc = new TextEncoder();\nconst dec = new TextDecoder();\n\nexport async function encrypt(data, strPassword = '') {\n    const strPass =\n        strPassword ||\n        window.prompt('Please enter your wallet encryption password');\n    if (!strPass) return false;\n    return await encryptData(data, strPass);\n}\n\nexport async function decrypt(data, strPassword) {\n    const strPass =\n        strPassword ||\n        window.prompt('Please enter your wallet unlock password');\n    if (!strPass) return false;\n    return (await decryptData(data, strPass)) || 'decryption failed!';\n}\n\nconst getPasswordKey = (password) =>\n    window.crypto.subtle.importKey(\n        'raw',\n        enc.encode(password),\n        'PBKDF2',\n        false,\n        ['deriveKey']\n    );\n\nconst deriveKey = (passwordKey, salt, keyUsage) =>\n    window.crypto.subtle.deriveKey(\n        {\n            name: 'PBKDF2',\n            salt,\n            iterations: 250000,\n            hash: 'SHA-256',\n        },\n        passwordKey,\n        { name: 'AES-GCM', length: 256 },\n        false,\n        keyUsage\n    );\n\nasync function encryptData(secretData, password) {\n    try {\n        const salt = window.crypto.getRandomValues(new Uint8Array(16));\n        const iv = window.crypto.getRandomValues(new Uint8Array(12));\n        const passwordKey = await getPasswordKey(password);\n        const aesKey = await deriveKey(passwordKey, salt, ['encrypt']);\n        const encryptedContent = await window.crypto.subtle.encrypt(\n            {\n                name: 'AES-GCM',\n                iv: iv,\n            },\n            aesKey,\n            enc.encode(secretData)\n        );\n\n        const encryptedContentArr = new Uint8Array(encryptedContent);\n        let buff = new Uint8Array(\n            salt.byteLength + iv.byteLength + encryptedContentArr.byteLength\n        );\n        buff.set(salt, 0);\n        buff.set(iv, salt.byteLength);\n        buff.set(encryptedContentArr, salt.byteLength + iv.byteLength);\n        return buff_to_base64(buff);\n    } catch (e) {\n        console.log(`Error - ${e}`);\n        return '';\n    }\n}\n\nasync function decryptData(encryptedData, password) {\n    try {\n        const encryptedDataBuff = base64_to_buf(encryptedData);\n        const salt = encryptedDataBuff.slice(0, 16);\n        const iv = encryptedDataBuff.slice(16, 16 + 12);\n        const data = encryptedDataBuff.slice(16 + 12);\n        const passwordKey = await getPasswordKey(password);\n        const aesKey = await deriveKey(passwordKey, salt, ['decrypt']);\n        const decryptedContent = await window.crypto.subtle.decrypt(\n            {\n                name: 'AES-GCM',\n                iv: iv,\n            },\n            aesKey,\n            data\n        );\n        return dec.decode(decryptedContent);\n    } catch (e) {\n        console.log(`Error - ${e}`);\n        return '';\n    }\n}\n","import { Contact } from './contacts-book';\n\n/**\n * A local Account, containing sensitive user-data\n */\nexport class Account {\n    /**\n     * Create an Account.\n     * @param {Object} accountData - The account data.\n     * @param {String} accountData.publicKey - The public key.\n     * @param {String} [accountData.encWif] - The encrypted WIF.\n     * @param {Array<Object>} [accountData.localProposals] - The local proposals.\n     * @param {Array<Contact>} [accountData.contacts] - The Contacts saved in this account.\n     * @param {String} [account.name] - The Contact Name of the account.\n     */\n    constructor(accountData) {\n        // Keys take the Constructor as priority, but if missing, default to their \"Type\" in empty form for type-safety\n        this.publicKey = accountData?.publicKey || '';\n        this.encWif = accountData?.encWif || '';\n        this.localProposals = accountData?.localProposals || [];\n        this.contacts = accountData?.contacts || [];\n        this.name = accountData?.name || '';\n    }\n\n    /** @type {String} The public key. */\n    publicKey = '';\n\n    /** @type {String} The encrypted WIF. */\n    encWif = '';\n\n    /** @type {Array<Object>} The local proposals. */\n    localProposals = [];\n\n    /** @type {Array<Contact>} The Contacts saved in this account. */\n    contacts = [];\n\n    /** @type {String} The Contact Name of the account. */\n    name = '';\n\n    /**\n     * Search for a Contact in this account, by specific properties\n     * @param {Object} settings\n     * @param {string?} settings.name - The Name of the contact to search for\n     * @param {string?} settings.pubkey - The Pubkey of the contact to search for\n     * @returns {Contact?} - A Contact, if found\n     */\n    getContactBy({ name, pubkey }) {\n        if (!name && !pubkey)\n            throw Error(\n                'getContactBy(): At least ONE search parameter MUST be set!'\n            );\n\n        // Get by Name\n        if (name) return this.contacts.find((a) => a.label === name);\n        // Get by Pubkey\n        if (pubkey) return this.contacts.find((a) => a.pubkey === pubkey);\n\n        // Nothing found\n        return null;\n    }\n}\n","import { Buffer } from 'buffer';\nimport { Account } from './accounts';\nimport { Database } from './database';\nimport { doms, toClipboard } from './global';\nimport { ALERTS, tr, translation } from './i18n';\nimport {\n    confirmPopup,\n    createAlert,\n    createQR,\n    getImageFile,\n    isStandardAddress,\n    isXPub,\n    sanitizeHTML,\n} from './misc';\nimport { scanQRCode } from './scanner';\nimport { wallet, hasEncryptedWallet } from './wallet';\n\n/**\n * Represents an Account contact\n */\nexport class Contact {\n    /**\n     * Creates a new Account contact\n     * @param {Object} options - The contact options\n     * @param {string} options.label - The label of the contact\n     * @param {string} options.icon - The optional icon of the contact (base64)\n     * @param {string} options.pubkey - The Master public key of the contact\n     * @param {number} options.date - The date (unix timestamp) of the contact being saved\n     */\n    constructor({ label, icon, pubkey, date }) {\n        this.label = label;\n        this.icon = icon;\n        this.pubkey = pubkey;\n        this.date = date;\n    }\n\n    /** The label of the Contact\n     * @type {string}\n     */\n    label;\n\n    /** The optional icon of the Contact (base64)\n     * @type {string}\n     */\n    icon;\n\n    /** The Master public key of the Contact\n     * @type {string}\n     */\n    pubkey;\n\n    /** The date (unix timestamp) of the Contact being saved\n     * @type {number}\n     */\n    date;\n}\n\n/**\n * Add a Contact to an Account's contact list\n * @param {Account} account - The account to add the Contact to\n * @param {Contact} contact - The contact object\n */\nexport async function addContact(account, contact) {\n    // TODO: once multi-account is added, ensure this function adds the contact to the correct account (by pubkey)\n    const cDB = await Database.getInstance();\n\n    // Push contact in to the account\n    account.contacts.push(contact);\n\n    // Save to the DB\n    await cDB.updateAccount(account);\n}\n\n/**\n * Remove a Contact from an Account's contact list\n * @param {Account} account - The account to remove the Contact from\n * @param {string} pubkey - The contact pubkey\n */\nexport async function removeContact(account, pubkey) {\n    // TODO: once multi-account is added, ensure this function adds the contact to the correct account (by pubkey)\n    const cDB = await Database.getInstance();\n\n    // Find the contact by index, if it exists; splice it away\n    const nIndex = account.contacts.findIndex((a) => a.pubkey === pubkey);\n    if (nIndex > -1) {\n        // Splice out the contact, and save to DB\n        account.contacts.splice(nIndex, 1);\n        await cDB.updateAccount(account, true);\n    }\n}\n\n/**\n * Render an Account's contact list\n * @param {Account} account\n * @param {boolean} fPrompt - If this is a Contact Selection prompt\n */\nexport async function renderContacts(account, fPrompt = false) {\n    let strHTML = '';\n    let i = 0;\n\n    // For non-prompts: we allow the user to Add, Edit or Delete their contacts\n    if (!fPrompt) {\n        // Render an editable Contacts Table\n        for (const cContact of account.contacts || []) {\n            const strPubkey = isXPub(cContact.pubkey)\n                ? cContact.pubkey.slice(0, 32) + '…'\n                : cContact.pubkey;\n            strHTML += `\n            <div class=\"d-flex px-3 py-3 contactItem\">\n                <div>\n                    <img onclick=\"MPW.guiAddContactImage('${i}')\" class=\"ptr\" style=\"margin-right:20px; width: 50px; height: 50px; border-radius: 100%; background-color: white; border: 2px solid #d5adff;\" ${\n                cContact.icon ? 'src=\"' + cContact.icon + '\"' : ''\n            }>\n                </div>\n                <div style=\"width: 100%; line-height: 15px;\">\n                    <span id=\"contactsName${i}\" onclick=\"MPW.guiEditContactNamePrompt('${i}')\" style=\"word-wrap: anywhere; cursor:pointer; color: #d5adff; font-weight: 600; margin-top: 8px; display: block;\">${sanitizeHTML(\n                cContact.label\n            )}</span>\n                    <span id=\"contactsAddress${i}\" style=\"word-wrap: anywhere; font-size: 13px; position: relative; top: 3px;\">${sanitizeHTML(\n                strPubkey\n            )}</span>\n                </div>\n                <div style=\"display: flex; justify-content: flex-end; align-items: center; padding-right: 6px; padding-left: 15px;\">\n                    <i style=\"cursor:pointer;\" onclick=\"MPW.guiRemoveContact(${i})\" class=\"far fa-trash-alt\"></i>\n                </div>\n            </div>\n            `;\n            i++;\n        }\n\n        // Lastly, inject the \"Add Account\" UI to the table\n        strHTML += `\n            <div class=\"d-flex px-3 addContact\" style=\"margin-top:20px;\">\n                <div class=\"contactName\">\n                    <input id=\"contactsNameInput\" class=\"m-0\" placeholder=\"${translation.name}\" autocomplete=\"nope\">\n                </div>\n                <div class=\"contactAddr\">\n                    <input id=\"contactsAddressInput\" class=\"m-0\" placeholder=\"${translation.addressOrXPub}\" autocomplete=\"nope\">\n                </div>\n                <div class=\"d-flex\" style=\"align-items: center;\">\n                    <div onclick=\"MPW.guiAddContact()\" class=\"addContactBtn\">\n                        <i class=\"fas fa-plus\"></i>\n                    </div>\n                    <div onclick=\"MPW.guiAddContactQRPrompt()\" class=\"qrContactBtn\">\n                        <i class=\"fa-solid fa-qrcode\"></i>\n                    </div>\n                </div>\n            </div>\n        `;\n\n        doms.domContactsTable.innerHTML = strHTML;\n    } else {\n        // For prompts: the user must click an address (or cancel), and cannot add, edit or delete contacts\n        strHTML += `<div id=\"contactsList\" class=\"contactsList\">`;\n        for (const cContact of account.contacts || []) {\n            const strPubkey = isXPub(cContact.pubkey)\n                ? cContact.pubkey.slice(0, 32) + '…'\n                : cContact.pubkey;\n            strHTML += `\n            <div class=\"d-flex px-3 py-3 contactItem ptr\" id=\"contactsSelector${i}\">\n                <div id=\"contactsAvatarContainer${i}\">\n                    <img id=\"contactsAvatar${i}\" class=\"ptr\" style=\"margin-right:20px; width: 50px; height: 50px; border-radius: 100%; background-color: white; border: 2px solid #d5adff;\" ${\n                cContact.icon ? 'src=\"' + cContact.icon + '\"' : ''\n            }>\n                </div>\n                <div id=\"contactsNameContainer${i}\" style=\"width: 100%; line-height: 15px;\">\n                    <span id=\"contactsName${i}\" style=\"word-wrap: anywhere; color: #d5adff; font-weight: 600; margin-top: 8px; display: block;\">${sanitizeHTML(\n                sanitizeHTML(cContact.label)\n            )}</span>\n                    <span id=\"contactsAddress${i}\" style=\"word-wrap: anywhere; font-size: 13px; position: relative; top: 3px;\">${sanitizeHTML(\n                strPubkey\n            )}</span>\n                </div>\n            </div>\n            `;\n            i++;\n        }\n\n        // Add the final \"Back\" button\n        strHTML += `\n            <span class=\"d-flex px-3 py-3 contactItem ptr\" id=\"contactsSelector-1\">\n                ${translation.back}\n            </span>\n        `;\n\n        // Finish the display\n        strHTML += `</div>`;\n\n        // Prepare the Contact list Prompt\n        const cPrompt = getUserContactClick();\n\n        // Hook the Contact Prompt to the Popup UI, which resolves when the user has interacted with the Contact Prompt\n        return await confirmPopup({\n            title: translation.chooseAContact,\n            html: strHTML,\n            resolvePromise: cPrompt(),\n            purpleModal: true,\n            textLeft: true,\n            noPadding: true,\n            maxHeight: 450,\n        });\n    }\n}\n\n/**\n * Creates and returns a function that returns a promise for a click event.\n *\n * The promise will resolve with the Contact Name of whichever button is clicked first.\n *\n * Once a button is clicked, all remaining listeners are removed.\n */\nfunction getUserContactClick() {\n    // Specify the function to return\n    return function () {\n        // Note that the return type is a Promise, this will wait on the click\n        return new Promise((resolve, _reject) => {\n            // Wait a bit for the DOM to fully render, then setup the handler functions + attach them to the Contact Buttons via Event Listeners\n            setTimeout(() => {\n                // The function to handle the click\n                function handleClick(event) {\n                    // If this is the Exit button (a -1 index), just silently quit\n                    if (event.target.id.endsWith('-1')) return resolve('');\n\n                    // Splice the 'Contact Index' from the button clicked\n                    const nIndex = event.target.id.match(/([0-9]+)$/)[0];\n                    // Fetch the associated Contact Name from the table\n                    // TODO: maybe don't rely on the table, and just fetch the Contact Index from the DB Contacts?\n                    const strName = document.getElementById(\n                        `contactsName${nIndex}`\n                    ).innerText;\n                    // Resolve the promise with the Contact Name of the button that was clicked first\n                    resolve(strName);\n                    // Remove all the remaining click listeners\n                    removeRemainingListeners();\n                }\n\n                // The function to iterate over the buttons and remove their listeners\n                function removeRemainingListeners() {\n                    let i = -1;\n                    let button;\n                    // This iteration removes the listener from each button\n                    // eslint-disable-next-line no-cond-assign\n                    while (\n                        (button = document.getElementById(\n                            `contactsSelector${i}`\n                        ))\n                    ) {\n                        button.removeEventListener('click', handleClick);\n                        i++;\n                    }\n                }\n\n                // Attach a click listener to each `contactsSelector` button\n                let i = -1;\n                let button;\n                // eslint-disable-next-line no-cond-assign\n                while (\n                    (button = document.getElementById(`contactsSelector${i}`))\n                ) {\n                    button.addEventListener('click', handleClick, {\n                        once: true,\n                    });\n                    i++;\n                }\n            }, 500); // Waits 500ms to ensure the all the elements have been added to the DOM (yeah, not the most elegant, but cannot think of a better solution yet)\n        });\n    };\n}\n\n/**\n * A function that uses the Prompt system to ask the user for a contact\n */\nexport async function promptForContact() {\n    const cDB = await Database.getInstance();\n    const cAccount = await cDB.getAccount();\n    if (!cAccount || (cAccount.contacts && cAccount.contacts.length === 0))\n        return createAlert('warning', ALERTS.CONTACTS_YOU_HAVE_NONE, 2500);\n    return renderContacts(cAccount, true);\n}\n\n/**\n * A GUI button wrapper that fills an Input with a user-selected Contact\n * @param {HTMLInputElement} domInput - The input box to fill with a selected Contact Address\n */\nexport async function guiSelectContact(domInput) {\n    // Fill the 'Input box' with a user-chosen Contact\n    domInput.value = (await promptForContact()) || '';\n\n    // Run the validity checker for double-safety\n    await guiCheckRecipientInput({ target: domInput });\n}\n\n/**\n * A GUI wrapper that renders the current Account's contacts list\n */\nexport async function guiRenderContacts() {\n    const cDB = await Database.getInstance();\n    const cAccount = await cDB.getAccount();\n\n    if (!cAccount || !cAccount.contacts) {\n        return createAlert(\n            'warning',\n            tr(ALERTS.CONTACTS_ENCRYPT_FIRST, [\n                { button: translation.secureYourWallet },\n            ]),\n            3500\n        );\n    }\n\n    return renderContacts(cAccount);\n}\n\n/**\n * Set the current Account's Contact name\n * @param {Account} account - The account to add the new Name to\n * @param {String} name - The name to set\n */\nexport async function setAccountContactName(account, name) {\n    const cDB = await Database.getInstance();\n\n    // Set the name\n    account.name = name;\n\n    // Save name to the DB\n    await cDB.updateAccount(account);\n}\n\n/**\n * Render the Receive Modal with either our Contact or Address\n * @param {boolean} fContact - `true` to render our Contact, `false` to render our current Address\n */\nexport async function guiRenderReceiveModal(\n    cReceiveType = RECEIVE_TYPES.CONTACT\n) {\n    if (cReceiveType === RECEIVE_TYPES.CONTACT) {\n        // Fetch Contact info from the current Account\n        const cDB = await Database.getInstance();\n        const cAccount = await cDB.getAccount();\n\n        // Check that a local Contact name was set\n        if (cAccount?.name) {\n            // Derive our Public Key\n            let strPubkey = '';\n\n            // If HD: use xpub, otherwise we'll fallback to our single address\n            strPubkey = await wallet.getKeyToExport();\n\n            // Construct the Contact Share URI\n            const strContactURI = await localContactToURI(cAccount, strPubkey);\n\n            // Render Copy Button\n            doms.domModalQrLabel.innerHTML = `${translation.shareContactURL}<i onclick=\"MPW.localContactToClipboard(event)\" id=\"guiAddressCopy\" class=\"fas fa-clipboard\" style=\"cursor: pointer; width: 20px;\"></i>`;\n\n            // We'll render a short informational text, alongside a QR below for Contact scanning\n            doms.domModalQR.innerHTML = `\n                <p>${translation.onlyShareContactPrivately}</p>\n                <div id=\"receiveModalEmbeddedQR\"></div>\n            `;\n            const domQR = document.getElementById('receiveModalEmbeddedQR');\n            createQR(strContactURI, domQR, 10);\n            domQR.firstChild.style.width = '100%';\n            domQR.firstChild.style.height = 'auto';\n            domQR.firstChild.classList.add('no-antialias');\n            document.getElementById('clipboard').value = strPubkey;\n        } else {\n            // Get our current wallet address\n            const strAddress = await wallet.getCurrentAddress();\n\n            // Update the QR Label (we'll show the address here for now, user can set Contact \"Name\" optionally later)\n            doms.domModalQrLabel.innerHTML =\n                strAddress +\n                `<i onclick=\"MPW.toClipboard('${strAddress}', this)\" id=\"guiAddressCopy\" class=\"fas fa-clipboard\" style=\"cursor: pointer; width: 20px;\"></i>`;\n\n            // Update the QR section\n            if (await hasEncryptedWallet()) {\n                doms.domModalQR.innerHTML = `\n                    <center>\n                        <b>${translation.setupYourContact}</b>\n                        <p>${translation.receiveWithContact}</p>\n                        <input id=\"setContactName\" placeholder=\"${translation.username}\" style=\"text-align: center;\"></input>\n                        <button onclick=\"MPW.guiSetAccountName('setContactName')\">${translation.createContact}</button>\n                    </center>\n                `;\n            } else {\n                doms.domModalQR.innerHTML = `\n                    <center>\n                        <b>${translation.secureYourWallet}</b>\n                        <p>${tr(translation.encryptFirstForContacts, [\n                            { button: translation.secureYourWallet },\n                        ])}</p>\n                    </center>\n                `;\n            }\n        }\n    } else if (cReceiveType === RECEIVE_TYPES.ADDRESS) {\n        // Get our current wallet address\n        const strAddress = await wallet.getCurrentAddress();\n        createQR('pivx:' + strAddress, doms.domModalQR);\n        doms.domModalQrLabel.innerHTML =\n            strAddress +\n            `<i onclick=\"MPW.toClipboard('${strAddress}', this)\" id=\"guiAddressCopy\" class=\"fas fa-clipboard\" style=\"cursor: pointer; width: 20px;\"></i>`;\n        doms.domModalQR.firstChild.style.width = '100%';\n        doms.domModalQR.firstChild.style.height = 'auto';\n        doms.domModalQR.firstChild.classList.add('no-antialias');\n        document.getElementById('clipboard').value = strAddress;\n    } else {\n        // Get our current wallet XPub\n        const strXPub = await wallet.getXPub();\n\n        // Update the QR Label (we'll show the address here for now, user can set Contact \"Name\" optionally later)\n        doms.domModalQrLabel.innerHTML =\n            strXPub +\n            `<i onclick=\"MPW.toClipboard('${strXPub}', this)\" id=\"guiAddressCopy\" class=\"fas fa-clipboard\" style=\"cursor: pointer; width: 20px;\"></i>`;\n\n        // We'll render a short informational text, alongside a QR below for Contact scanning\n        doms.domModalQR.innerHTML = `\n            <p>${translation.onlyShareContactPrivately}</p>\n            <div id=\"receiveModalEmbeddedQR\"></div>\n        `;\n\n        // Update the QR section\n        const domQR = document.getElementById('receiveModalEmbeddedQR');\n        createQR(strXPub, domQR, 10);\n        domQR.firstChild.style.width = '100%';\n        domQR.firstChild.style.height = 'auto';\n        domQR.firstChild.classList.add('no-antialias');\n        document.getElementById('clipboard').value = strXPub;\n    }\n}\n\n/**\n * A GUI wrapper to re-render the current Receive Modal configuration\n */\nexport async function guiRenderCurrentReceiveModal() {\n    return guiToggleReceiveType(cReceiveType);\n}\n\n/**\n * An enum of Receive Types (i.e: receive by Contact, Address, XPub)\n */\nexport const RECEIVE_TYPES = {\n    CONTACT: 0,\n    ADDRESS: 1,\n    XPUB: 2,\n};\n\n/** The current Receive Type used by Receive UIs */\nexport let cReceiveType = RECEIVE_TYPES.CONTACT;\n\n/**\n * Cycles through the Receive Types with each run\n * @param {number?} nForceType - Optionally force the Receive Type\n */\nexport async function guiToggleReceiveType(nForceType = null) {\n    // Figure out which Types can be used with this wallet\n    const nTypeMax = wallet.isHD() ? 3 : 2;\n\n    // Loop back to the first if we hit the end\n    cReceiveType =\n        nForceType !== null ? nForceType : (cReceiveType + 1) % nTypeMax;\n\n    // Convert the *next* Type to text (also runs through i18n system)\n    const nNextType = (cReceiveType + 1) % nTypeMax;\n    let strNextType = '';\n    switch (nNextType) {\n        case RECEIVE_TYPES.CONTACT:\n            strNextType = translation.contact;\n            break;\n        case RECEIVE_TYPES.ADDRESS:\n            strNextType = translation.address;\n            break;\n        case RECEIVE_TYPES.XPUB:\n            strNextType = translation.xpub;\n            break;\n    }\n\n    // Render the new UI\n    doms.domModalQrReceiveTypeBtn.innerText =\n        translation.changeTo + ' ' + strNextType;\n    guiRenderReceiveModal(cReceiveType);\n\n    // Return the new Receive Type index\n    return cReceiveType;\n}\n\n/** A GUI wrapper that adds a contact to the current Account's contacts list */\nexport async function guiAddContact() {\n    const strName = document.getElementById('contactsNameInput').value.trim();\n    const strAddr = document\n        .getElementById('contactsAddressInput')\n        .value.trim();\n\n    // Verify the name\n    if (strName.length < 1)\n        return createAlert('warning', ALERTS.CONTACTS_NAME_REQUIRED, 2500);\n    if (strName.length > 32)\n        return createAlert('warning', ALERTS.CONTACTS_NAME_TOO_LONG, 2500);\n\n    // Verify the address\n    if (!isStandardAddress(strAddr) && !isXPub(strAddr))\n        return createAlert(\n            'warning',\n            tr(ALERTS.INVALID_ADDRESS, [{ address: strAddr }]),\n            3000\n        );\n\n    // Ensure we're not adding our own XPub\n    if (isXPub(strAddr)) {\n        if (wallet.isHD()) {\n            // Compare the XPub against our own\n            const fOurs = strAddr === (await wallet.getXPub());\n            if (fOurs) {\n                createAlert(\n                    'warning',\n                    ALERTS.CONTACTS_CANNOT_ADD_YOURSELF,\n                    3500\n                );\n                return false;\n            }\n        }\n    } else {\n        // Ensure we're not adding (one of) our own address(es)\n        if (await wallet.isOwnAddress(strAddr)) {\n            createAlert('warning', ALERTS.CONTACTS_CANNOT_ADD_YOURSELF, 3500);\n            return false;\n        }\n    }\n\n    // Fetch the current Account\n    const cDB = await Database.getInstance();\n    const cAccount = await cDB.getAccount();\n\n    // Check this Contact isn't already saved, either fully or partially\n    const cContactByName = cAccount.getContactBy({ name: strName });\n    const cContactByPubkey = cAccount.getContactBy({ pubkey: strAddr });\n\n    // If both Name and Key are saved, then they just tried re-adding the same Contact twice\n    if (cContactByName && cContactByPubkey) {\n        createAlert('warning', ALERTS.CONTACTS_ALREADY_EXISTS, 3000);\n        return true;\n    }\n\n    // If the Name is saved, but not key, then this *could* be a kind of Username-based phishing attempt\n    if (cContactByName && !cContactByPubkey) {\n        createAlert('warning', ALERTS.CONTACTS_NAME_ALREADY_EXISTS, 4000);\n        return true;\n    }\n\n    // If the Key is saved, but not the name: perhaps the Contact changed their name?\n    if (!cContactByName && cContactByPubkey) {\n        createAlert(\n            'warning',\n            tr(ALERTS.CONTACTS_KEY_ALREADY_EXISTS, [\n                { newName: strName },\n                { oldName: cContactByPubkey.label },\n            ]),\n            7500\n        );\n        return true;\n    }\n\n    // Add the Contact to it\n    await addContact(cAccount, {\n        label: strName,\n        pubkey: strAddr,\n        date: Date.now(),\n    });\n\n    // Render the new list\n    return renderContacts(cAccount);\n}\n\n/**\n * Prompt the user to add a new Contact, safely checking for duplicates\n * @param {String} strName - The Name of the Contact\n * @param {String} strPubkey - The Public Key of the Contact\n * @param {boolean} fDuplicateNotif - Notify the user if the incoming Contact is a duplicate\n * @returns {Promise<boolean>} - `true` if contact was added, `false` if not\n */\nexport async function guiAddContactPrompt(\n    strName,\n    strPubkey,\n    fDuplicateNotif = true\n) {\n    // Verify the name\n    if (strName.length < 1)\n        return createAlert('warning', ALERTS.CONTACTS_NAME_REQUIRED, 2500);\n    if (strName.length > 32)\n        return createAlert('warning', ALERTS.CONTACTS_NAME_TOO_LONG, 2500);\n\n    // Verify the address\n    if (!isStandardAddress(strPubkey) && !isXPub(strPubkey))\n        return createAlert(\n            'warning',\n            tr(ALERTS.INVALID_ADDRESS, [{ address: strPubkey }]),\n            4000\n        );\n\n    // Ensure we're not adding our own XPub\n    if (isXPub(strPubkey)) {\n        if (wallet.isHD()) {\n            // Compare the XPub against our own\n            const fOurs = strPubkey === (await wallet.getXPub());\n            if (fOurs) {\n                createAlert(\n                    'warning',\n                    ALERTS.CONTACTS_CANNOT_ADD_YOURSELF,\n                    3500\n                );\n                return false;\n            }\n        }\n    } else {\n        // Ensure we're not adding (one of) our own address(es)\n        if (await wallet.isOwnAddress(strPubkey)) {\n            createAlert('warning', ALERTS.CONTACTS_CANNOT_ADD_YOURSELF, 3500);\n            return false;\n        }\n    }\n\n    const cDB = await Database.getInstance();\n    const cAccount = await cDB.getAccount();\n\n    // Check this Contact isn't already saved, either fully or partially\n    const cContactByName = cAccount.getContactBy({ name: strName });\n    const cContactByPubkey = cAccount.getContactBy({ pubkey: strPubkey });\n\n    // If both Name and Key are saved, then they just tried re-adding the same Contact twice\n    if (cContactByName && cContactByPubkey) {\n        if (fDuplicateNotif)\n            createAlert('warning', ALERTS.CONTACTS_ALREADY_EXISTS, 3000);\n        return true;\n    }\n\n    // If the Name is saved, but not key, then this *could* be a kind of Username-based phishing attempt\n    if (cContactByName && !cContactByPubkey) {\n        if (fDuplicateNotif)\n            createAlert('warning', ALERTS.CONTACTS_NAME_ALREADY_EXISTS, 4000);\n        return true;\n    }\n\n    // If the Key is saved, but not the name: perhaps the Contact changed their name?\n    if (!cContactByName && cContactByPubkey) {\n        if (fDuplicateNotif)\n            createAlert(\n                'warning',\n                tr(ALERTS.CONTACTS_KEY_ALREADY_EXISTS, [\n                    { newName: strName },\n                    { oldName: cContactByPubkey.label },\n                ]),\n                7500\n            );\n        return true;\n    }\n\n    // Render an 'Add to Contacts' UI\n    const strHTML = `\n        <p>\n            ${tr(translation.addContactSubtext, [{ strName: strName }])}\n            <br>\n            <br>\n            <i style=\"opacity: 0.75\">${tr(translation.addContactWarning, [\n                { strName: strName },\n            ])}</i>\n        </p>\n    `;\n\n    // Hook the Contact Prompt to the Popup UI, which resolves when the user has interacted with the Contact Prompt\n    const fAdd = await confirmPopup({\n        title: tr(translation.addContactTitle, [{ strName: strName }]),\n        html: strHTML,\n    });\n\n    // If accepted, then we add to contacts!\n    if (fAdd) {\n        // Add the Contact to the current account\n        await addContact(cAccount, {\n            label: strName,\n            pubkey: strPubkey,\n            date: Date.now(),\n        });\n\n        // Notify\n        createAlert(\n            'success',\n            tr(ALERTS.CONTACTS_ADDED, [{ strName: strName }]),\n            3000\n        );\n    }\n\n    // Return if the user accepted or declined\n    return fAdd;\n}\n\n/**\n * Prompt the user to edit a contact by it's original name\n *\n * The new name will be taken from the internal prompt input\n * @param {number} nIndex - The DB index of the Contact to edit\n * @returns {Promise<boolean>} - `true` if contact was edited, `false` if not\n */\nexport async function guiEditContactNamePrompt(nIndex) {\n    // Fetch the desired Contact to edit\n    const cDB = await Database.getInstance();\n    const cAccount = await cDB.getAccount();\n    const cContact = cAccount.contacts[nIndex];\n\n    // Render an 'Add to Contacts' UI\n    const strHTML = `\n        <input type=\"text\" id=\"contactsNewNameInput\" style=\"text-align: center;\" placeholder=\"${translation.newName}\">\n    `;\n\n    // Hook the Contact Prompt to the Popup UI, which resolves when the user has interacted with the Contact Prompt\n    const fContinue = await confirmPopup({\n        title: tr(translation.editContactTitle, [\n            { strName: sanitizeHTML(cContact.label) },\n        ]),\n        html: strHTML,\n    });\n    if (!fContinue) return false;\n\n    // Verify the name\n    const strNewName = document.getElementById('contactsNewNameInput').value;\n    if (strNewName.length < 1) {\n        createAlert('warning', ALERTS.CONTACTS_NAME_REQUIRED, 2500);\n        return false;\n    }\n    if (strNewName.length > 32) {\n        createAlert('warning', ALERTS.CONTACTS_NAME_TOO_LONG, 2500);\n        return false;\n    }\n\n    // Check this new Name isn't already saved\n    const cContactByNewName = cAccount.getContactBy({ name: strNewName });\n    if (cContactByNewName) {\n        createAlert(\n            'warning',\n            tr(ALERTS.CONTACTS_EDIT_NAME_ALREADY_EXISTS, [\n                { strNewName: strNewName },\n            ]),\n            4500\n        );\n        return false;\n    }\n\n    // Edit it (since it's a pointer to the Account's Contacts)\n    cContact.label = strNewName;\n\n    // Commit to DB\n    await cDB.updateAccount(cAccount);\n\n    // Re-render the Contacts UI\n    await renderContacts(cAccount);\n\n    // Return if the user accepted or declined\n    return true;\n}\n\n/**\n * Prompt the user to add an image to a contact by it's DB index\n *\n * The new image will be taken from the internal system prompt\n * @param {number} nIndex - The DB index of the Contact to edit\n * @returns {Promise<boolean>} - `true` if contact was edited, `false` if not\n */\nexport async function guiAddContactImage(nIndex) {\n    const cDB = await Database.getInstance();\n    const cAccount = await cDB.getAccount();\n    const cContact = cAccount.contacts[nIndex];\n\n    // Prompt for the image\n    const strImage = await getImageFile();\n    if (!strImage) return false;\n\n    // Fetch the original contact, edit it (since it's a pointer to the Account's Contacts)\n    cContact.icon = strImage;\n\n    // Commit to DB\n    await cDB.updateAccount(cAccount);\n\n    // Re-render the Contacts UI\n    await renderContacts(cAccount);\n\n    // Return that the edit was successful\n    return true;\n}\n\n/**\n * A GUI wrapper to open a QR Scanner prompt for Contact imports\n * @returns {boolean} - `true` if contact was added, `false` if not\n */\nexport async function guiAddContactQRPrompt() {\n    const cScan = await scanQRCode();\n\n    // Empty (i.e: rejected or no camera) can just silently exit\n    if (!cScan) return false;\n\n    // MPW Contact Request URI\n    if (cScan?.data?.includes('addcontact=')) {\n        // Parse as URL Params\n        const cURL = new URL(cScan.data);\n        const urlParams = new URLSearchParams(cURL.search);\n        const strURI = urlParams.get('addcontact');\n\n        // Sanity check the URI\n        if (strURI?.includes(':')) {\n            // Split to 'name' and 'pubkey'\n            const arrParts = strURI.split(':');\n\n            // Convert Name from HEX to UTF-8\n            const strName = Buffer.from(arrParts[0], 'hex').toString('utf8');\n            const strPubkey = arrParts[1];\n\n            // Prompt the user to add the Contact\n            const fAdded = await guiAddContactPrompt(\n                sanitizeHTML(strName),\n                strPubkey\n            );\n\n            // Re-render the list\n            await guiRenderContacts();\n\n            // Return the status\n            return fAdded;\n        }\n    } else {\n        createAlert('warning', ALERTS.CONTACTS_NOT_A_CONTACT_QR, 2500);\n        return false;\n    }\n}\n\n/** A GUI wrapper that removes a contact from the current Account's contacts list */\nexport async function guiRemoveContact(index) {\n    // Fetch the current Account\n    const cDB = await Database.getInstance();\n    const cAccount = await cDB.getAccount();\n\n    // Fetch the Contact\n    const cContact = cAccount.contacts[index];\n\n    // Confirm the deletion\n    const fConfirmed = await confirmPopup({\n        title: tr(translation.removeContactTitle, [\n            { strName: sanitizeHTML(cContact.label) },\n        ]),\n        html: `\n            <p>\n                ${tr(translation.removeContactSubtext, [\n                    { strName: sanitizeHTML(cContact.label) },\n                ])}\n                <br>\n                <br>\n                <i style=\"opacity: 0.65\">${translation.removeContactNote}</i>\n            </p>\n        `,\n    });\n    if (!fConfirmed) return;\n\n    // Remove the Contact from it\n    await removeContact(cAccount, cAccount.contacts[index].pubkey);\n\n    // Render the new list\n    return renderContacts(cAccount);\n}\n\n/** A GUI wrapper that sets the name of the current Account */\nexport async function guiSetAccountName(strDOM) {\n    const domInput = document.getElementById(strDOM);\n\n    // Verify the name\n    const strNewName = domInput.value.trim();\n    if (strNewName.length < 1) {\n        createAlert('warning', ALERTS.CONTACTS_NAME_REQUIRED, 2500);\n        return false;\n    }\n    if (strNewName.length > 32) {\n        createAlert('warning', ALERTS.CONTACTS_NAME_TOO_LONG, 2500);\n        return false;\n    }\n\n    // Fetch the current Account\n    const cDB = await Database.getInstance();\n    const cAccount = await cDB.getAccount();\n\n    // Set the account's name\n    await setAccountContactName(cAccount, strNewName);\n\n    // Render the new Receive Modal\n    await guiRenderReceiveModal();\n}\n\n/**\n * Checks the input from the recipient field\n *\n * This function should be connected to an `input` as it's `onchange` function\n * @param {InputEvent} event - The change event from the input\n */\nexport async function guiCheckRecipientInput(event) {\n    const strInput = event.target.value.trim();\n\n    // If the value is empty, we don't do any checks and simply reset the colourcoding\n    if (!strInput) {\n        return (event.target.style.color = '');\n    }\n\n    // Fetch the current Account\n    const cDB = await Database.getInstance();\n    const cAccount = await cDB.getAccount();\n\n    // Check if this is a Contact\n    const cContact = cAccount?.getContactBy({\n        name: strInput,\n        pubkey: strInput,\n    });\n    if (cContact) {\n        // Yep, nice!\n        return (event.target.style.color = 'green');\n    }\n\n    // Not a contact: dig deeper, is this a Standard address or XPub?\n    if (isStandardAddress(strInput) || isXPub(strInput)) {\n        // Yep!\n        return (event.target.style.color = 'green');\n    } else {\n        // We give up: this appears to be nonsense\n        return (event.target.style.color = '#b20000');\n    }\n}\n\n/**\n * Search for a Name of a Contact from a given Account and Address\n * @param {Account} cAccount - The Account to search for the Contact\n * @param {string} address - The address to search for a Contact with\n * @returns {string} - The Name of the address Contact, or just the address if none is found\n */\nexport function getNameOrAddress(cAccount, address) {\n    return (\n        cAccount?.contacts?.find((a) => a.pubkey === address)?.label || address\n    );\n}\n\n/**\n * Convert the current Account's Contact to a Share URI\n * @param {Account?} account - An optional Account to construct the Contact URI from, if omitted, the current DB account is used\n * @param {string?} pubkey - An optional Master Public Key to attach to the Contact URI\n */\nexport async function localContactToURI(account, pubkey) {\n    // Fetch the current Account\n    const cDB = await Database.getInstance();\n    const cAccount = account || (await cDB.getAccount());\n\n    // Use the given pubkey; but if none is passed, we'll derive our loaded Public Key\n    let strPubkey = pubkey || '';\n\n    // If HD: use xpub, otherwise we'll fallback to our single address\n    if (!strPubkey) strPubkey = await wallet.getKeyToExport();\n\n    // Construct the Contact URI Root\n    const strURL = window.location.origin + window.location.pathname;\n\n    // Convert our Name and Pubkey to HEX\n    const strHexName = Buffer.from(cAccount.name).toString('hex');\n\n    // Encode in our URI and return\n    const strEncodedURI = encodeURIComponent(strHexName + ':' + strPubkey);\n    return `${strURL}?addcontact=${strEncodedURI}`;\n}\n\n/**\n * A GUI wrapper for the Contact URI and Clipboard functions\n * @param {InputEvent} event - The DOM element calling the copy function\n */\nexport async function localContactToClipboard(event) {\n    return toClipboard(await localContactToURI(), event.target);\n}\n","import { parseWIF } from './encoding.js';\nimport { generateMnemonic, mnemonicToSeed, validateMnemonic } from 'bip39';\nimport { doms, beforeUnloadListener } from './global.js';\nimport { getNetwork } from './network.js';\nimport { MAX_ACCOUNT_GAP } from './chain_params.js';\nimport {\n    LegacyMasterKey,\n    HdMasterKey,\n    HardwareWalletMasterKey,\n} from './masterkey';\nimport { generateOrEncodePrivkey } from './encoding.js';\nimport {\n    confirmPopup,\n    createAlert,\n    isXPub,\n    isStandardAddress,\n} from './misc.js';\nimport {\n    refreshChainData,\n    setDisplayForAllWalletOptions,\n    getBalance,\n    getStakingBalance,\n} from './global.js';\nimport { ALERTS, tr, translation } from './i18n.js';\nimport { encrypt, decrypt } from './aes-gcm.js';\nimport * as jdenticon from 'jdenticon';\nimport { Database } from './database.js';\nimport { guiRenderCurrentReceiveModal } from './contacts-book.js';\nimport { Account } from './accounts.js';\nimport { debug, fAdvancedMode } from './settings.js';\nimport { strHardwareName, getHardwareWalletKeys } from './ledger.js';\nexport let fWalletLoaded = false;\n\n/**\n * Class Wallet, at the moment it is just a \"realization\" of Masterkey with a given nAccount\n * it also remembers which addresses we generated.\n * in future PRs this class will manage balance, UTXOs, masternode etc...\n */\nexport class Wallet {\n    /**\n     * @type {import('./masterkey.js').MasterKey}\n     */\n    #masterKey;\n    /**\n     * @type {number}\n     */\n    #nAccount;\n    /**\n     * @type {number}\n     */\n    #addressIndex = 0;\n    /**\n     * Map our own address -> Path\n     * @type {Map<String, String?>}\n     */\n    #ownAddresses = new Map();\n    constructor(nAccount) {\n        this.#nAccount = nAccount;\n    }\n\n    getMasterKey() {\n        return this.#masterKey;\n    }\n\n    get nAccount() {\n        return this.#nAccount;\n    }\n\n    wipePrivateData() {\n        this.#masterKey.wipePrivateData(this.#nAccount);\n    }\n\n    isViewOnly() {\n        if (!this.#masterKey) return false;\n        return this.#masterKey.isViewOnly;\n    }\n\n    isHD() {\n        if (!this.#masterKey) return false;\n        return this.#masterKey.isHD;\n    }\n\n    async hasWalletUnlocked(fIncludeNetwork = false) {\n        if (fIncludeNetwork && !getNetwork().enabled)\n            return createAlert(\n                'warning',\n                ALERTS.WALLET_OFFLINE_AUTOMATIC,\n                5500\n            );\n        if (!this.isLoaded()) {\n            return createAlert(\n                'warning',\n                tr(ALERTS.WALLET_UNLOCK_IMPORT, [\n                    {\n                        unlock: (await hasEncryptedWallet())\n                            ? 'unlock '\n                            : 'import/create',\n                    },\n                ]),\n                3500\n            );\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Set or replace the active Master Key with a new Master Key\n     * @param {Promise<MasterKey>} mk - The new Master Key to set active\n     */\n    async setMasterKey(mk) {\n        this.#masterKey = mk;\n        // Update the network master key\n        await getNetwork().setWallet(this);\n    }\n\n    /**\n     * Derive the current address (by internal index)\n     * @return {Promise<String>} Address\n     *\n     */\n    async getCurrentAddress() {\n        return await this.getAddress(0, this.#addressIndex);\n    }\n\n    /**\n     * Derive a generic address (given nReceiving and nIndex)\n     * @return {Promise<String>} Address\n     */\n    async getAddress(nReceiving = 0, nIndex = 0) {\n        const path = this.getDerivationPath(nReceiving, nIndex);\n        return await this.#masterKey.getAddress(path);\n    }\n\n    /**\n     * Derive xpub (given nReceiving and nIndex)\n     * @return {Promise<String>} Address\n     */\n    async getXPub(nReceiving = 0, nIndex = 0) {\n        if (this.isHD()) {\n            // Get our current wallet XPub\n            const derivationPath = this.getDerivationPath(nReceiving, nIndex)\n                .split('/')\n                .slice(0, 4)\n                .join('/');\n            return await this.#masterKey.getxpub(derivationPath);\n        }\n        throw new Error('Legacy wallet does not have a xpub');\n    }\n\n    /**\n     * Derive xpub (given nReceiving and nIndex)\n     * @return {bool} Return true if a masterKey has been loaded in the wallet\n     */\n    isLoaded() {\n        return !!this.#masterKey;\n    }\n\n    async encryptWallet(strPassword = '') {\n        // Encrypt the wallet WIF with AES-GCM and a user-chosen password - suitable for browser storage\n        let strEncWIF = await encrypt(this.#masterKey.keyToBackup, strPassword);\n        if (!strEncWIF) return false;\n\n        // Hide the encryption warning\n        doms.domGenKeyWarning.style.display = 'none';\n\n        // Prepare to Add/Update an account in the DB\n        const cAccount = new Account({\n            publicKey: await this.getKeyToExport(),\n            encWif: strEncWIF,\n        });\n\n        // Incase of a \"Change Password\", we check if an Account already exists\n        const database = await Database.getInstance();\n        if (await database.getAccount()) {\n            // Update the existing Account (new encWif) in the DB\n            await database.updateAccount(cAccount);\n        } else {\n            // Add the new Account to the DB\n            await database.addAccount(cAccount);\n        }\n\n        // Remove the exit blocker, we can annoy the user less knowing the key is safe in their database!\n        removeEventListener('beforeunload', beforeUnloadListener, {\n            capture: true,\n        });\n    }\n\n    /**\n     * @return Promise<[string, string]> Address and its BIP32 derivation path\n     */\n    async getNewAddress() {\n        const last = getNetwork().lastWallet;\n        this.#addressIndex =\n            (this.#addressIndex > last ? this.#addressIndex : last) + 1;\n        if (this.#addressIndex - last > MAX_ACCOUNT_GAP) {\n            // If the user creates more than ${MAX_ACCOUNT_GAP} empty wallets we will not be able to sync them!\n            this.#addressIndex = last;\n        }\n        const path = this.getDerivationPath(0, this.#addressIndex);\n        const address = await this.getAddress(0, this.#addressIndex);\n        return [address, path];\n    }\n    // If the privateKey is null then the user connected a hardware wallet\n    isHardwareWallet() {\n        if (!this.#masterKey) return false;\n        return this.#masterKey.isHardwareWallet == true;\n    }\n\n    /**\n     * @param {string} address - address to check\n     * @return {Promise<String?>} BIP32 path or null if it's not your address\n     */\n    async isOwnAddress(address) {\n        if (this.#ownAddresses.has(address)) {\n            return this.#ownAddresses.get(address);\n        }\n        const last = getNetwork().lastWallet;\n        this.#addressIndex =\n            this.#addressIndex > last ? this.#addressIndex : last;\n        if (this.isHD()) {\n            for (let i = 0; i < this.#addressIndex; i++) {\n                const path = this.getDerivationPath(0, i);\n                const testAddress = await this.#masterKey.getAddress(path);\n                if (address === testAddress) {\n                    this.#ownAddresses.set(address, path);\n                    return path;\n                }\n            }\n        } else {\n            const value =\n                address === (await this.getKeyToExport()) ? ':)' : null;\n            this.#ownAddresses.set(address, value);\n            return value;\n        }\n\n        this.#ownAddresses.set(address, null);\n        return null;\n    }\n\n    /**\n     * @return {String} BIP32 path or null if it's not your address\n     */\n    getDerivationPath(nReceiving = 0, nIndex = 0) {\n        return this.#masterKey.getDerivationPath(\n            this.#nAccount,\n            nReceiving,\n            nIndex\n        );\n    }\n\n    async getKeyToExport() {\n        return await this.#masterKey?.getKeyToExport(this.#nAccount);\n    }\n}\n\n/**\n * @type{Wallet}\n */\nexport const wallet = new Wallet(0); // For now we are using only the 0-th account, (TODO: update once account system is done)\n\n/**\n * Import a wallet (with it's private, public or encrypted data)\n * @param {object} options\n * @param {string | Array<number>} options.newWif - The import data (if omitted, the UI input is accessed)\n * @param {boolean} options.fRaw - Whether the import data is raw bytes or encoded (WIF, xpriv, seed)\n * @param {boolean} options.isHardwareWallet - Whether the import is from a Hardware wallet or not\n * @param {boolean} options.fSavePublicKey - Whether to save the derived public key to disk (for View Only mode)\n * @param {boolean} options.fStartup - Whether the import is at Startup or at Runtime\n * @returns {Promise<void>}\n */\nexport async function importWallet({\n    newWif = false,\n    fRaw = false,\n    isHardwareWallet = false,\n    fSavePublicKey = false,\n    fStartup = false,\n} = {}) {\n    // TODO: remove `walletConfirm`, it is useless as Accounts cannot be overriden, and multi-accounts will come soon anyway\n    // ... just didn't want to add a huge whitespace change from removing the `if (walletConfirm) {` line\n    const walletConfirm = true;\n    if (walletConfirm) {\n        if (isHardwareWallet) {\n            // Firefox does NOT support WebUSB, thus cannot work with Hardware wallets out-of-the-box\n            if (navigator.userAgent.includes('Firefox')) {\n                return createAlert(\n                    'warning',\n                    ALERTS.WALLET_FIREFOX_UNSUPPORTED,\n                    7500\n                );\n            }\n            // Derive our hardware address and import!\n            await wallet.setMasterKey(new HardwareWalletMasterKey());\n            const publicKey = await getHardwareWalletKeys(\n                wallet.getDerivationPath()\n            );\n            // Errors are handled within the above function, so there's no need for an 'else' here, just silent ignore.\n            if (!publicKey) {\n                await wallet.setMasterKey(null);\n                return;\n            }\n\n            // Hide the 'export wallet' button, it's not relevant to hardware wallets\n            doms.domExportWallet.hidden = true;\n\n            createAlert(\n                'info',\n                tr(ALERTS.WALLET_HARDWARE_WALLET, [\n                    { hardwareWallet: strHardwareName },\n                ]),\n                12500\n            );\n        } else {\n            // If raw bytes: purely encode the given bytes rather than generating our own bytes\n            if (fRaw) {\n                newWif = generateOrEncodePrivkey(newWif).strWIF;\n\n                // A raw import likely means non-user owned key (i.e: created via VanityGen), thus, we assume safety first and add an exit blocking listener\n                addEventListener('beforeunload', beforeUnloadListener, {\n                    capture: true,\n                });\n            }\n\n            // Select WIF from internal source OR user input (could be: WIF, Mnemonic or xpriv)\n            const privateImportValue = newWif || doms.domPrivKey.value;\n            const passphrase = doms.domPrivKeyPassword.value;\n            doms.domPrivKey.value = '';\n            doms.domPrivKeyPassword.value = '';\n\n            // Clean and verify the Seed Phrase (if one exists)\n            const cPhraseValidator = await cleanAndVerifySeedPhrase(\n                privateImportValue,\n                true\n            );\n\n            // If Debugging is enabled, show what the validator returned\n            if (debug) {\n                const fnLog = cPhraseValidator.ok ? console.log : console.warn;\n                fnLog('Seed Import Validator: ' + cPhraseValidator.msg);\n            }\n\n            // If the Seed is OK, proceed\n            if (cPhraseValidator.ok) {\n                // Generate our HD MasterKey with the cleaned (Mnemonic) Seed Phrase\n                const seed = await mnemonicToSeed(\n                    cPhraseValidator.phrase,\n                    passphrase\n                );\n                await wallet.setMasterKey(new HdMasterKey({ seed }));\n            } else if (cPhraseValidator.phrase.includes(' ')) {\n                // The Phrase Validator failed, but the input contains at least one space; possibly a Seed Typo?\n                return createAlert('warning', cPhraseValidator.msg, 5000);\n            } else {\n                // The input definitely isn't a seed, so we'll try every other import method\n                try {\n                    // XPub import (HD view only)\n                    if (isXPub(privateImportValue)) {\n                        await wallet.setMasterKey(\n                            new HdMasterKey({\n                                xpub: privateImportValue,\n                            })\n                        );\n                        // XPrv import (HD full access)\n                    } else if (privateImportValue.startsWith('xprv')) {\n                        await wallet.setMasterKey(\n                            new HdMasterKey({\n                                xpriv: privateImportValue,\n                            })\n                        );\n                        // Pubkey import (non-HD view only)\n                    } else if (isStandardAddress(privateImportValue)) {\n                        await wallet.setMasterKey(\n                            new LegacyMasterKey({\n                                address: privateImportValue,\n                            })\n                        );\n                        // WIF import (non-HD full access)\n                    } else {\n                        // Attempt to import a raw WIF private key\n                        const pkBytes = parseWIF(privateImportValue);\n                        await wallet.setMasterKey(\n                            new LegacyMasterKey({ pkBytes })\n                        );\n                    }\n                } catch (e) {\n                    return createAlert(\n                        'warning',\n                        ALERTS.FAILED_TO_IMPORT + '<br>' + e.message,\n                        6000\n                    );\n                }\n            }\n        }\n\n        // Reaching here: the deserialisation was a full cryptographic success, so a wallet is now imported!\n        fWalletLoaded = true;\n\n        // Hide wipe wallet button if there is no private key\n        if (wallet.isViewOnly() || wallet.isHardwareWallet()) {\n            doms.domWipeWallet.hidden = true;\n            if (await hasEncryptedWallet()) {\n                doms.domRestoreWallet.hidden = false;\n            }\n        }\n\n        // For non-HD wallets: hide the 'new address' button, since these are essentially single-address MPW wallets\n        if (!wallet.isHD()) doms.domNewAddress.style.display = 'none';\n\n        // Update the loaded address in the Dashboard\n        wallet.getNewAddress({ updateGUI: true });\n\n        // Display Text\n        doms.domGuiWallet.style.display = 'block';\n        doms.domDashboard.click();\n\n        // Update identicon\n        doms.domIdenticon.dataset.jdenticonValue = await wallet.getAddress();\n        jdenticon.update('#identicon');\n\n        // Hide the encryption prompt if the user is using\n        // a hardware wallet, or is view-only mode.\n        if (!(isHardwareWallet || wallet.isViewOnly())) {\n            if (\n                // If the wallet was internally imported (not UI pasted), like via vanity, display the encryption prompt\n                (((fRaw && newWif.length) || newWif) &&\n                    !(await hasEncryptedWallet())) ||\n                // If the wallet was pasted and is an unencrypted key, then display the encryption prompt\n                !(await hasEncryptedWallet())\n            ) {\n                doms.domGenKeyWarning.style.display = 'block';\n            } else if (await hasEncryptedWallet()) {\n                // If the wallet was pasted and is an encrypted import, display the lock wallet UI\n                doms.domWipeWallet.hidden = false;\n            }\n        } else {\n            // Hide the encryption UI\n            doms.domGenKeyWarning.style.display = 'none';\n        }\n\n        // Fetch state from explorer, if this import was post-startup\n        if (getNetwork().enabled && !fStartup) {\n            refreshChainData();\n            getNetwork().getUTXOs();\n        }\n\n        // Hide all wallet starter options\n        setDisplayForAllWalletOptions('none');\n    }\n}\n\n// Wallet Generation\nexport async function generateWallet(noUI = false) {\n    // TODO: remove `walletConfirm`, it is useless as Accounts cannot be overriden, and multi-accounts will come soon anyway\n    // ... just didn't want to add a huge whitespace change from removing the `if (walletConfirm) {` line\n    const walletConfirm = true;\n    if (walletConfirm) {\n        const mnemonic = generateMnemonic();\n\n        const passphrase = !noUI\n            ? await informUserOfMnemonic(mnemonic)\n            : undefined;\n        const seed = await mnemonicToSeed(mnemonic, passphrase);\n\n        // Prompt the user to encrypt the seed\n        await wallet.setMasterKey(new HdMasterKey({ seed }));\n        fWalletLoaded = true;\n\n        doms.domGenKeyWarning.style.display = 'block';\n        // Add a listener to block page unloads until we are sure the user has saved their keys, safety first!\n        addEventListener('beforeunload', beforeUnloadListener, {\n            capture: true,\n        });\n\n        // Display the dashboard\n        doms.domGuiWallet.style.display = 'block';\n        setDisplayForAllWalletOptions('none');\n\n        // Update identicon\n        doms.domIdenticon.dataset.jdenticonValue = await wallet.getAddress();\n        jdenticon.update('#identicon');\n\n        await getNewAddress({ updateGUI: true });\n\n        // Refresh the balance UI (why? because it'll also display any 'get some funds!' alerts)\n        getBalance(true);\n        getStakingBalance(true);\n    }\n\n    return wallet;\n}\n\n/**\n * Clean a Seed Phrase string and verify it's integrity\n *\n * This returns an object of the validation status and the cleaned Seed Phrase for safe low-level usage.\n * @param {String} strPhraseInput - The Seed Phrase string\n * @param {Boolean} fPopupConfirm - Allow a warning bypass popup if the Seed Phrase is unusual\n */\nexport async function cleanAndVerifySeedPhrase(\n    strPhraseInput = '',\n    fPopupConfirm = true\n) {\n    // Clean the phrase (removing unnecessary spaces) and force to lowercase\n    const strPhrase = strPhraseInput.trim().replace(/\\s+/g, ' ').toLowerCase();\n\n    // Count the Words\n    const nWordCount = strPhrase.trim().split(' ').length;\n\n    // Ensure it's a word count that makes sense\n    if (nWordCount === 12 || nWordCount === 24) {\n        if (!validateMnemonic(strPhrase)) {\n            // If a popup is allowed and Advanced Mode is enabled, warn the user that the\n            // ... seed phrase is potentially bad, and ask for confirmation to proceed\n            if (!fPopupConfirm || !fAdvancedMode)\n                return {\n                    ok: false,\n                    msg: translation.importSeedErrorTypo,\n                    phrase: strPhrase,\n                };\n\n            // The reason we want to ask the user for confirmation is that the mnemonic\n            // could have been generated with another app that has a different dictionary\n            const fSkipWarning = await confirmPopup({\n                title: translation.popupSeedPhraseBad,\n                html: translation.popupSeedPhraseBadNote,\n            });\n\n            if (fSkipWarning) {\n                // User is probably an Arch Linux user and used `-f`\n                return {\n                    ok: true,\n                    msg: translation.importSeedErrorSkip,\n                    phrase: strPhrase,\n                };\n            } else {\n                // User heeded the warning and rejected the phrase\n                return {\n                    ok: false,\n                    msg: translation.importSeedError,\n                    phrase: strPhrase,\n                };\n            }\n        } else {\n            // Valid count and mnemonic\n            return {\n                ok: true,\n                msg: translation.importSeedValid,\n                phrase: strPhrase,\n            };\n        }\n    } else {\n        // Invalid count\n        return {\n            ok: false,\n            msg: translation.importSeedErrorSize,\n            phrase: strPhrase,\n        };\n    }\n}\n\n/**\n * Display a Seed Phrase popup to the user and optionally wait for a Seed Passphrase\n * @param {string} mnemonic - The Seed Phrase to display to the user\n * @returns {Promise<string>} - The Mnemonic Passphrase (empty string if omitted by user)\n */\nfunction informUserOfMnemonic(mnemonic) {\n    return new Promise((res, _) => {\n        // Configure the modal\n        $('#mnemonicModal').modal({ keyboard: false });\n\n        // Render the Seed Phrase and configure the button\n        doms.domMnemonicModalContent.innerText = mnemonic;\n        doms.domMnemonicModalButton.onclick = () => {\n            res(doms.domMnemonicModalPassphrase.value);\n            $('#mnemonicModal').modal('hide');\n\n            // Wipe the mnemonic displays of sensitive data\n            doms.domMnemonicModalContent.innerText = '';\n            doms.domMnemonicModalPassphrase.value = '';\n        };\n\n        // Display the modal\n        $('#mnemonicModal').modal('show');\n    });\n}\n\nexport async function decryptWallet(strPassword = '') {\n    // Check if there's any encrypted WIF available\n    const database = await Database.getInstance();\n    const { encWif: strEncWIF } = await database.getAccount();\n    if (!strEncWIF || strEncWIF.length < 1) return false;\n\n    // Prompt to decrypt it via password\n    const strDecWIF = await decrypt(strEncWIF, strPassword);\n    if (!strDecWIF || strDecWIF === 'decryption failed!') {\n        if (strDecWIF)\n            return createAlert('warning', ALERTS.INCORRECT_PASSWORD, 6000);\n    } else {\n        await importWallet({\n            newWif: strDecWIF,\n            // Save the public key to disk for View Only mode\n            fSavePublicKey: true,\n        });\n        return true;\n    }\n}\n\n/**\n * @returns {Promise<bool>} If the wallet has an encrypted database backup\n */\nexport async function hasEncryptedWallet() {\n    const database = await Database.getInstance();\n    const account = await database.getAccount();\n    return !!account?.encWif;\n}\n\nexport async function getNewAddress({\n    updateGUI = false,\n    verify = false,\n} = {}) {\n    const [address, path] = await wallet.getNewAddress();\n    if (verify && wallet.isHardwareWallet()) {\n        // Generate address to present to the user without asking to verify\n        const confAddress = await confirmPopup({\n            title: ALERTS.CONFIRM_POPUP_VERIFY_ADDR,\n            html: createAddressConfirmation(address),\n            resolvePromise: wallet.getMasterKey().getAddress(path, { verify }),\n        });\n        if (address !== confAddress) {\n            throw new Error('User did not verify address');\n        }\n    }\n\n    // If we're generating a new address manually, then render the new address in our Receive Modal\n    if (updateGUI) {\n        guiRenderCurrentReceiveModal();\n    }\n\n    return [address, path];\n}\n\nfunction createAddressConfirmation(address) {\n    return `${translation.popupHardwareAddrCheck} ${strHardwareName}.\n              <div class=\"seed-phrase\">${address}</div>`;\n}\n","import { translation_template } from '../locale/template/translation.js';\nimport { en_translation } from '../locale/en/translation.js';\nimport { pt_br_translation } from '../locale/pt-br/translation.js';\nimport { pt_pt_translation } from '../locale/pt-pt/translation.js';\nimport { es_mx_translation } from '../locale/es-mx/translation.js';\nimport { ph_translation } from '../locale/ph/translation.js';\nimport { uwu_translation } from '../locale/uwu/translation.js';\nimport { fr_translation } from '../locale/fr/translation.js';\nimport { it_translation } from '../locale/it/translation.js';\nimport { de_translation } from '../locale/de/translation.js';\nimport { Database } from './database.js';\nimport { fillAnalyticSelect, setTranslation } from './settings.js';\nimport { updateEncryptionGUI } from './global.js';\nimport { wallet } from './wallet.js';\nimport { getNetwork } from './network.js';\nimport { cReceiveType, guiToggleReceiveType } from './contacts-book.js';\nimport { reactive } from 'vue';\n\n/**\n * @type {translation_template}\n */\nexport const ALERTS = {};\n\n/**\n * @type {translation_template}\n */\nexport const translation = reactive({});\n\n// TRANSLATION\n//Create an object of objects filled with all the translations\nexport const translatableLanguages = {\n    en: en_translation,\n    uwu: uwu_translation,\n    'pt-pt': pt_pt_translation,\n    'pt-br': pt_br_translation,\n    'es-mx': es_mx_translation,\n    ph: ph_translation,\n    fr: fr_translation,\n    it: it_translation,\n    de: de_translation,\n};\n\n/**\n * Takes the language name and sets the translation settings based on the language file\n * @param {string} langName\n */\nexport function switchTranslation(langName) {\n    if (arrActiveLangs.find((lang) => lang.code === langName)) {\n        // Load every 'active' key of the language, otherwise, we'll default the key to the EN file\n        const arrNewLang = translatableLanguages[langName];\n        for (const strKey of Object.keys(arrNewLang)) {\n            // Skip empty and/or missing i18n keys, defaulting them to EN\n            if (!arrNewLang[strKey]) {\n                translation[strKey] = translatableLanguages.en[strKey];\n                continue;\n            }\n\n            // Apply the new i18n value to our runtime i18n sheet\n            translation[strKey] = arrNewLang[strKey];\n        }\n\n        // Translate static`data-i18n` tags\n        translateStaticHTML(translation);\n\n        // Translate any dynamic elements necessary\n        const cNet = getNetwork();\n        if (wallet.isLoaded() && cNet) {\n            updateEncryptionGUI();\n        }\n        loadAlerts();\n        fillAnalyticSelect();\n        if (wallet.isLoaded()) {\n            guiToggleReceiveType(cReceiveType);\n        }\n        return true;\n    } else {\n        console.log(\n            'i18n: The language (' +\n                langName +\n                \") is not supported yet, if you'd like to contribute translations (for rewards!) contact us on GitHub or Discord!\"\n        );\n        switchTranslation('en');\n        return false;\n    }\n}\n\n/**\n * Takes an i18n string that includes `{x}` and replaces that based on what is in the array of objects\n * @param {string} message\n * @param {Array<Object>} variables\n * @returns a string with the variables implemented in the string\n *\n * @example\n * //returns \"test this\"\n * tr(\"test {x}\" [x: \"this\"])\n */\nexport function tr(message, variables) {\n    variables.forEach((element) => {\n        message = message.replaceAll(\n            '{' + Object.keys(element)[0] + '}',\n            Object.values(element)[0]\n        );\n    });\n    return message;\n}\n\n/**\n * Translates all static HTML based on the `data-i18n` tag\n * @param {Array} i18nLangs\n */\nexport function translateStaticHTML(i18nLangs) {\n    if (!i18nLangs) return;\n\n    document.querySelectorAll('[data-i18n]').forEach(function (element) {\n        if (!i18nLangs[element.dataset.i18n]) return;\n\n        if (element.dataset.i18n_target) {\n            element[element.dataset.i18n_target] =\n                i18nLangs[element.dataset.i18n];\n        } else {\n            switch (element.tagName.toLowerCase()) {\n                case 'input':\n                case 'textarea':\n                    element.placeholder = i18nLangs[element.dataset.i18n];\n                    break;\n                default:\n                    element.innerHTML = i18nLangs[element.dataset.i18n];\n                    break;\n            }\n        }\n    });\n    loadAlerts();\n}\n\n/**\n * Translates the alerts by loading the data into the ALERTS object\n */\nexport function loadAlerts() {\n    // Alerts are designated by a special 'ALERTS' entry in each translation file\n    let fFoundAlerts = false;\n    for (const [alert_key, alert_translation] of Object.entries(translation)) {\n        if (fFoundAlerts) {\n            ALERTS[alert_key] = alert_translation;\n        }\n        // Skip all entries until we find the ALERTS flag\n        if (alert_key === 'ALERTS') fFoundAlerts = true;\n    }\n}\nfunction parseUserAgentLang(strUA, arrLangsWithSubset) {\n    if (arrLangsWithSubset.some((strLang) => strUA.includes(strLang))) {\n        // Split the lang in to 'primary' and 'subset', only use the primary lang\n        return strUA.substring(0, 2);\n    }\n    // Otherwise, just use the full language spec\n    return strUA;\n}\n\n// When adding a lang remember to add it to the object translatableLanguages as well as here.\nexport const arrActiveLangs = [\n    { code: 'en', emoji: '🇬🇧' },\n    { code: 'fr', emoji: '🇫🇷' },\n    { code: 'de', emoji: '🇩🇪' },\n    { code: 'it', emoji: '🇮🇹' },\n    { code: 'pt-pt', emoji: '🇵🇹' },\n    { code: 'pt-br', emoji: '🇧🇷' },\n    { code: 'es-mx', emoji: '🇲🇽' },\n    { code: 'ph', emoji: '🇵🇭' },\n    { code: 'uwu', emoji: '🐈' },\n];\n\nexport async function start() {\n    // We use this function to parse the UA lang in a safer way: for example, there's multiple `en` definitions\n    // ... but we shouldn't duplicate the language files, we can instead cut the affix (US, GB) and simply use 'en'.\n    // ... This logic may apply to other languages with such subsets as well, so take care of them here!\n    const arrLangsWithSubset = ['en', 'fr', 'de'];\n\n    const localeLang =\n        window?.navigator?.userLanguage || window?.navigator?.language;\n    const strLang = localeLang\n        ? parseUserAgentLang(localeLang.toLowerCase(), arrLangsWithSubset)\n        : undefined;\n\n    // When removing you do not have to remove from translatableLanguages\n    const database = await Database.getInstance();\n    const { translation: localTranslation } = await database.getSettings();\n\n    // Check if set in local storage\n    if (localTranslation !== '') {\n        setTranslation(localTranslation);\n    } else {\n        // Check if we support the user's browser locale\n        if (arrActiveLangs.find((lang) => lang.code === strLang)) {\n            setTranslation(strLang);\n        } else {\n            // Default to EN if the locale isn't supported yet\n            console.log(\n                'i18n: Your language (' +\n                    strLang +\n                    \") is not supported yet, if you'd like to contribute translations (for rewards!) contact us on GitHub or Discord!\"\n            );\n            setTranslation('en');\n        }\n    }\n    translateStaticHTML(translation);\n}\n","export const OP = {\n    // push value\n    0: 0x00,\n    FALSE: 0x00, // ALIAS FOR: 0\n    PUSHDATA1: 0x4c,\n    PUSHDATA2: 0x4d,\n    PUSHDATA4: 0x4e,\n    '1NEGATE': 0x4f,\n    RESERVED: 0x50,\n    1: 0x51,\n    TRUE: 0x51, // ALIAS FOR: 1\n    2: 0x52,\n    3: 0x53,\n    4: 0x54,\n    5: 0x55,\n    6: 0x56,\n    7: 0x57,\n    8: 0x58,\n    9: 0x59,\n    10: 0x5a,\n    11: 0x5b,\n    12: 0x5c,\n    13: 0x5d,\n    14: 0x5e,\n    15: 0x5f,\n    16: 0x60,\n\n    // control\n    NOP: 0x61,\n    VER: 0x62,\n    IF: 0x63,\n    NOTIF: 0x64,\n    VERIF: 0x65,\n    VERNOTIF: 0x66,\n    ELSE: 0x67,\n    ENDIF: 0x68,\n    VERIFY: 0x69,\n    RETURN: 0x6a,\n\n    // stack ops\n    TOALTSTACK: 0x6b,\n    FROMALTSTACK: 0x6c,\n    '2DROP': 0x6d,\n    '2DUP': 0x6e,\n    '3DUP': 0x6f,\n    '2OVER': 0x70,\n    '2ROT': 0x71,\n    '2SWAP': 0x72,\n    IFDUP: 0x73,\n    DEPTH: 0x74,\n    DROP: 0x75,\n    DUP: 0x76,\n    NIP: 0x77,\n    OVER: 0x78,\n    PICK: 0x79,\n    ROLL: 0x7a,\n    ROT: 0x7b,\n    SWAP: 0x7c,\n    TUCK: 0x7d,\n\n    // splice ops\n    CAT: 0x7e,\n    SUBSTR: 0x7f,\n    LEFT: 0x80,\n    RIGHT: 0x81,\n    SIZE: 0x82,\n\n    // bit logic\n    INVERT: 0x83,\n    AND: 0x84,\n    OR: 0x85,\n    XOR: 0x86,\n    EQUAL: 0x87,\n    EQUALVERIFY: 0x88,\n    RESERVED1: 0x89,\n    RESERVED2: 0x8a,\n\n    // numeric\n    '1ADD': 0x8b,\n    '1SUB': 0x8c,\n    '2MUL': 0x8d,\n    '2DIV': 0x8e,\n    NEGATE: 0x8f,\n    ABS: 0x90,\n    NOT: 0x91,\n    '0NOTEQUAL': 0x92,\n\n    ADD: 0x93,\n    SUB: 0x94,\n    MUL: 0x95,\n    DIV: 0x96,\n    MOD: 0x97,\n    LSHIFT: 0x98,\n    RSHIFT: 0x99,\n\n    BOOLAND: 0x9a,\n    BOOLOR: 0x9b,\n    NUMEQUAL: 0x9c,\n    NUMEQUALVERIFY: 0x9d,\n    NUMNOTEQUAL: 0x9e,\n    LESSTHAN: 0x9f,\n    GREATERTHAN: 0xa0,\n    LESSTHANOREQUAL: 0xa1,\n    GREATERTHANOREQUAL: 0xa2,\n    MIN: 0xa3,\n    MAX: 0xa4,\n\n    WITHIN: 0xa5,\n\n    // crypto\n    RIPEMD160: 0xa6,\n    SHA1: 0xa7,\n    SHA256: 0xa8,\n    HASH160: 0xa9,\n    HASH256: 0xaa,\n    CODESEPARATOR: 0xab,\n    CHECKSIG: 0xac,\n    CHECKSIGVERIFY: 0xad,\n    CHECKMULTISIG: 0xae,\n    CHECKMULTISIGVERIFY: 0xaf,\n\n    // expansion\n    NOP1: 0xb0,\n    NOP2: 0xb1,\n    CHECKLOCKTIMEVERIFY: 0xb1, // ALIAS FOR: NOP2\n    NOP3: 0xb2,\n    NOP4: 0xb3,\n    NOP5: 0xb4,\n    NOP6: 0xb5,\n    NOP7: 0xb6,\n    NOP8: 0xb7,\n    NOP9: 0xb8,\n    NOP10: 0xb9,\n\n    // zerocoin\n    ZEROCOINMINT: 0xc1,\n    ZEROCOINSPEND: 0xc2,\n    ZEROCOINPUBLICSPEND: 0xc3,\n\n    // cold staking\n    CHECKCOLDSTAKEVERIFY_LOF: 0xd1, // last output free for masternode/budget payments\n    CHECKCOLDSTAKEVERIFY: 0xd2,\n\n    INVALIDOPCODE: 0xff,\n};\nObject.freeze(OP);\n\nexport function getScriptForBurn(data) {\n    let cScript = [];\n    // Check if we're fitting any data into the TX\n    if (typeof data === 'string' && data.length > 0) {\n        let bData = new TextEncoder().encode(data);\n        cScript.push(OP['RETURN']);\n        cScript.push(OP['PUSHDATA1']);\n        // Append the byte array length\n        cScript.push(bData.length);\n        // Convert from uint8 to array and append the byte array\n        cScript = cScript.concat(Array.prototype.slice.call(bData));\n    } else {\n        // Empty data, create a simple RETURN script\n        cScript.push(OP['RETURN']);\n    }\n    // Return the burn script\n    return cScript;\n}\n","import { getBalance } from './global';\nimport { isEmpty } from './misc';\nimport { cMarket, fillCurrencySelect } from './settings';\n\n/**\n * CoinGecko's endpoint for PIVX data, optimised for least bandwidth\n * - No localisation, tickers, community data, developer data or sparklines\n */\nexport const COINGECKO_ENDPOINT =\n    'https://api.coingecko.com/api/v3/coins/pivx?localization=false&tickers=false&market_data=true&community_data=false&developer_data=false&sparkline=false';\n\n/**\n * The generic market data source template, used to build site-specific classes\n */\nexport class MarketSource {\n    /** The storage object for raw market data */\n    cData = {};\n\n    /** The name of the market source */\n    strName = '';\n\n    /** The customised API endpoint of the market source */\n    strEndpoint = '';\n\n    /**\n     * Ensure a market data cache exists, if not, fetch it and resume\n     */\n    async ensureCacheExists() {\n        if (!this.cData || !Object.keys(this.cData).length) await this.fetch();\n    }\n\n    /**\n     * Fetches the raw market source data\n     * @returns {Promise<object>}\n     */\n    async fetch() {\n        try {\n            return (this.cData = await (await fetch(this.strEndpoint)).json());\n        } catch (e) {\n            console.warn('CoinGecko: Failed to fetch prices!');\n            console.warn(e);\n            return null;\n        }\n    }\n}\n\n/**\n * The CoinGecko market data source\n */\nexport class CoinGecko extends MarketSource {\n    constructor() {\n        super();\n        this.strName = 'CoinGecko';\n        this.strEndpoint = COINGECKO_ENDPOINT;\n    }\n\n    /**\n     * Get the price in a specific display currency\n     * @param {string} strCurrency - The CoinGecko-supported display currency\n     * @return {Promise<number>}\n     */\n    async getPrice(strCurrency) {\n        await this.ensureCacheExists();\n        return this.cData?.market_data?.current_price[strCurrency] || 0;\n    }\n\n    /**\n     * Get a list of the supported display currencies\n     * @returns {Promise<Array<string>>} - A list of CoinGecko-supported display currencies\n     */\n    async getCurrencies() {\n        await this.ensureCacheExists();\n        return !isEmpty(this.cData)\n            ? Object.keys(this.cData.market_data.current_price)\n            : [];\n    }\n}\n\n/**\n * Refreshes market data from the user's data source, then re-renders currency options and price displays\n */\nexport async function refreshPriceDisplay() {\n    // Refresh our price data, and if successful, update the UI\n    if (!isEmpty(await cMarket.fetch())) {\n        // Update the currency customisation menu from the selected data source\n        await fillCurrencySelect();\n\n        // Update price values\n        getBalance(true);\n    }\n}\n","import script from \"./Activity.vue?vue&type=script&setup=true&lang=js\"\nexport * from \"./Activity.vue?vue&type=script&setup=true&lang=js\"\n\nconst __exports__ = script;\n\nexport default __exports__","<script setup>\nimport { ref, computed, watch } from 'vue';\nimport { getNetwork, HistoricalTxType } from './network.js';\nimport { wallet } from './wallet.js';\nimport { cChainParams } from './chain_params.js';\nimport { translation } from './i18n.js';\nimport { Database } from './database.js';\nimport { getNameOrAddress } from './contacts-book.js';\n\nconst props = defineProps({\n    title: String,\n    rewards: Boolean,\n});\n\nconst txs = ref([]);\nlet txCount = 0;\nconst updating = ref(false);\nconst isHistorySynced = ref(false);\nconst rewardsText = ref('-');\nconst ticker = computed(() => cChainParams.current.TICKER);\nconst explorerUrl = computed(() => getNetwork().strUrl);\nconst txMap = computed(() => {\n    return {\n        [HistoricalTxType.STAKE]: {\n            icon: 'fa-gift',\n            colour: 'white',\n            content: translation.activityBlockReward,\n        },\n        [HistoricalTxType.SENT]: {\n            icon: 'fa-minus',\n            colour: '#f93c4c',\n            content: translation.activitySentTo,\n        },\n        [HistoricalTxType.RECEIVED]: {\n            icon: 'fa-plus',\n            colour: '#5cff5c',\n            content: translation.activityReceivedFrom,\n        },\n        [HistoricalTxType.DELEGATION]: {\n            icon: 'fa-snowflake',\n            colour: 'white',\n            content: translation.activityDelegatedTo,\n        },\n        [HistoricalTxType.UNDELEGATION]: {\n            icon: 'fa-fire',\n            colour: 'white',\n            content: translation.activityUndelegated,\n        },\n        [HistoricalTxType.UNKNOWN]: {\n            icon: 'fa-question',\n            colour: 'white',\n            content: translation.activityUnknown,\n        },\n    };\n});\n\nasync function update(fNewOnly = false, sync = true) {\n    const cNet = getNetwork();\n\n    if (!cNet) return;\n\n    // Prevent the user from spamming refreshes\n    if (updating.value) return;\n\n    let arrTXs;\n    try {\n        // Set the updating animation\n        updating.value = true;\n\n        // If our txCount is lower than the tx history loaded\n        // Use the txhistory array, otherwise sync more\n        if (txCount !== cNet.arrTxHistory.length || !sync) {\n            arrTXs = cNet.arrTxHistory;\n        } else {\n            arrTXs = await cNet.syncTxHistoryChunk(fNewOnly);\n        }\n        // If the network has changed, or the sync has failed\n        // Ignore the array\n        if (!arrTXs || cNet !== getNetwork()) return;\n\n        txCount = arrTXs.length;\n    } finally {\n        updating.value = false;\n    }\n\n    // Check if all transactions are loaded\n    isHistorySynced.value = cNet.isHistorySynced;\n\n    // For Staking: Filter the list for only Stakes, display total rewards from known history\n    if (props.rewards) {\n        const arrStakes = arrTXs.filter(\n            (a) => a.type === HistoricalTxType.STAKE\n        );\n\n        if (arrStakes.length !== txs.length) {\n            const nRewards = arrStakes.reduce((a, b) => a + b.amount, 0);\n            rewardsText.value = `${cNet.isHistorySynced ? '' : '≥'}${nRewards}`;\n            parseTXs(arrStakes);\n            return;\n        }\n    }\n    if (txs.length !== arrTXs.length) parseTXs(arrTXs);\n}\n\nwatch(translation, async () => await update(false, false));\n\n/**\n * Parse tx to list syntax\n */\nasync function parseTXs(arrTXs) {\n    const newTxs = [];\n    const cNet = getNetwork();\n\n    // Prepare time formatting\n    const dateOptions = {\n        year: '2-digit',\n        month: '2-digit',\n        day: '2-digit',\n    };\n    const timeOptions = {\n        hour: '2-digit',\n        minute: '2-digit',\n        hour12: true,\n    };\n    // And also keep track of our last Tx's timestamp, to re-use a cache, which is much faster than the slow `.toLocaleDateString`\n    let prevDateString = '';\n    let prevTimestamp = 0;\n    const cDB = await Database.getInstance();\n    const cAccount = await cDB.getAccount();\n\n    for (const cTx of arrTXs) {\n        const dateTime = new Date(cTx.time * 1000);\n        // If this Tx is older than 24h, then hit the `Date` cache logic, otherwise, use a `Time` and skip it\n        let strDate =\n            Date.now() / 1000 - cTx.time > 86400\n                ? ''\n                : dateTime.toLocaleTimeString(undefined, timeOptions);\n        if (!strDate) {\n            if (\n                prevDateString &&\n                prevTimestamp - cTx.time * 1000 < 12 * 60 * 60 * 1000\n            ) {\n                // Use our date cache\n                strDate = prevDateString;\n            } else {\n                // Create a new date, this Tx is too old to use the cache\n                prevDateString = dateTime.toLocaleDateString(\n                    undefined,\n                    dateOptions\n                );\n                strDate = prevDateString;\n            }\n        }\n        // Update the time cache\n        prevTimestamp = cTx.time * 1000;\n\n        // Coinbase Transactions (rewards) require 100 confs\n        const fConfirmed =\n            cNet.cachedBlockCount - cTx.blockHeight >= props.rewards ? 100 : 6;\n\n        // Choose the content type, for the Dashboard; use a generative description, otherwise, a TX-ID\n        // let txContent = props.rewards ? cTx.id : 'Block Reward';\n\n        // Format the amount to reduce text size\n        let formattedAmt = '';\n        if (cTx.amount < 0.01) {\n            formattedAmt = '<0.01';\n        } else if (cTx.amount >= 100) {\n            formattedAmt = Math.round(cTx.amount).toString();\n        } else {\n            formattedAmt = cTx.amount.toFixed(2);\n        }\n\n        // For 'Send' or 'Receive' TXs: Check if this is a send-to-self transaction\n        let fSendToSelf = false;\n        if (\n            cTx.type === HistoricalTxType.SENT ||\n            cTx.type === HistoricalTxType.RECEIVED\n        ) {\n            fSendToSelf = true;\n            // Check all addresses to find our own, caching them for performance\n            for (const strAddr of cTx.receivers.concat(cTx.senders)) {\n                // If a previous Tx checked this address, skip it, otherwise, check it against our own address(es)\n                if (!(await wallet.isOwnAddress(strAddr))) {\n                    // External address, this is not a self-only Tx\n                    fSendToSelf = false;\n                }\n            }\n        }\n\n        // Take the icon, colour and content based on the type of the transaction\n        let { icon, colour, content } = txMap.value[cTx.type];\n        const match = content.match(/{(.)}/);\n        if (match) {\n            // Use the senders array if `s` was provided in the template\n            // Use the receivers array if `r` was provided\n            const where = {\n                r: 'receivers',\n                s: 'senders',\n            }[match[1]];\n\n            let who = '';\n            if (fSendToSelf) {\n                who = translation.activitySelf;\n            } else if (cTx.shieldedOutputs) {\n                who = translation.activityShieldedAddress;\n            } else {\n                const arrExternalAddresses = (\n                    await Promise.all(\n                        cTx[where].map(async (addr) => [\n                            await wallet.isOwnAddress(addr),\n                            addr,\n                        ])\n                    )\n                )\n                    .filter(([isOwnAddress, _]) => {\n                        return !isOwnAddress;\n                    })\n                    .map(([_, addr]) => getNameOrAddress(cAccount, addr));\n                who =\n                    [\n                        ...new Set(\n                            arrExternalAddresses.map((addr) =>\n                                addr?.length >= 32\n                                    ? addr?.substring(0, 6)\n                                    : addr\n                            )\n                        ),\n                    ].join(', ') + '...';\n            }\n            content = content.replace(/{.}/, who);\n        }\n\n        newTxs.push({\n            date: strDate,\n            id: cTx.id,\n            content: props.rewards ? cTx.id : content,\n            formattedAmt,\n            confirmed: fConfirmed,\n            icon,\n            colour,\n        });\n    }\n\n    txs.value = newTxs;\n}\n\nfunction reset() {\n    txs.value = [];\n    txCount = 0;\n    update(false);\n}\n\nfunction getTxCount() {\n    return txCount;\n}\n\ndefineExpose({ update, reset, getTxCount });\n</script>\n\n<template>\n    <center>\n        <span class=\"dcWallet-activityLbl\"\n            >{{ title }}\n            <span v-if=\"rewards\"> ({{ rewardsText }} {{ ticker }}) </span>\n        </span>\n    </center>\n    <div class=\"dcWallet-activity\">\n        <div class=\"scrollTable\">\n            <div>\n                <table\n                    class=\"table table-responsive table-sm stakingTx table-mobile-scroll\"\n                >\n                    <thead>\n                        <tr>\n                            <th scope=\"col\" class=\"tx1\">\n                                {{ translation.time }}\n                            </th>\n                            <th scope=\"col\" class=\"tx2\">\n                                {{\n                                    rewards\n                                        ? translation.ID\n                                        : translation.description\n                                }}\n                            </th>\n                            <th scope=\"col\" class=\"tx3\">Amount</th>\n                            <th scope=\"col\" class=\"tx4 text-right\"></th>\n                        </tr>\n                    </thead>\n                    <tbody>\n                        <tr v-for=\"tx in txs\">\n                            <td\n                                class=\"align-middle pr-10px\"\n                                style=\"font-size: 12px\"\n                            >\n                                <i style=\"opacity: 0.75\">{{ tx.date }}</i>\n                            </td>\n                            <td class=\"align-middle pr-10px txcode\">\n                                <a\n                                    :href=\"explorerUrl + '/tx/' + tx.id\"\n                                    target=\"_blank\"\n                                    rel=\"noopener noreferrer\"\n                                >\n                                    <code\n                                        class=\"wallet-code text-center active ptr\"\n                                        style=\"padding: 4px 9px\"\n                                        >{{ tx.content }}</code\n                                    >\n                                </a>\n                            </td>\n                            <td class=\"align-middle pr-10px\">\n                                <b style=\"font-family: monospace\"\n                                    ><i\n                                        class=\"fa-solid\"\n                                        style=\"padding-right: 3px\"\n                                        :class=\"[tx.icon]\"\n                                        :style=\"{ color: tx.colour }\"\n                                    ></i>\n                                    {{ tx.formattedAmt }} {{ ticker }}</b\n                                >\n                            </td>\n                            <td class=\"text-right pr-10px align-middle\">\n                                <span\n                                    class=\"badge mb-0\"\n                                    :class=\"{\n                                        'badge-purple': tx.confirmed,\n                                        'bg-danger': !tx.confirmed,\n                                    }\"\n                                >\n                                    <i\n                                        v-if=\"tx.confirmed\"\n                                        class=\"fas fa-check\"\n                                    ></i>\n                                    <i v-else class=\"fas fa-hourglass-end\"></i>\n                                </span>\n                            </td>\n                        </tr>\n                    </tbody>\n                </table>\n            </div>\n            <center>\n                <button\n                    v-if=\"!isHistorySynced\"\n                    class=\"pivx-button-medium\"\n                    @click=\"update()\"\n                >\n                    <span class=\"buttoni-icon\"\n                        ><i\n                            class=\"fas fa-sync fa-tiny-margin\"\n                            :class=\"{ 'fa-spin': updating }\"\n                        ></i\n                    ></span>\n                    <span class=\"buttoni-text\">{{ translation.loadMore }}</span>\n                </button>\n            </center>\n        </div>\n    </div>\n</template>\n","import {\n    doms,\n    getBalance,\n    getStakingBalance,\n    guiUpdateImportInput,\n    mempool,\n    refreshChainData,\n    setDisplayForAllWalletOptions,\n    updateEncryptionGUI,\n    updateGovernanceTab,\n    activityDashboard,\n    stakingDashboard,\n} from './global.js';\nimport { wallet, hasEncryptedWallet, importWallet } from './wallet.js';\nimport { cChainParams } from './chain_params.js';\nimport { setNetwork, ExplorerNetwork, getNetwork } from './network.js';\nimport { confirmPopup, createAlert, isEmpty } from './misc.js';\nimport {\n    switchTranslation,\n    ALERTS,\n    translation,\n    arrActiveLangs,\n    tr,\n} from './i18n.js';\nimport { CoinGecko, refreshPriceDisplay } from './prices.js';\nimport { Database } from './database.js';\n\n// --- Default Settings\n/** A mode that emits verbose console info for internal MPW operations */\nexport let debug = false;\n/**\n * The user-selected display currency from market-aggregator sites\n * @type {string}\n */\nexport let strCurrency = 'usd';\n/**\n * The global market data source\n * @type {CoinGecko}\n */\nexport let cMarket = new CoinGecko();\n/** The user-selected explorer, used for most of MPW's data synchronisation */\nexport let cExplorer = cChainParams.current.Explorers[0];\n/** The user-selected MPW node, used for alternative blockchain data */\nexport let cNode = cChainParams.current.Nodes[0];\n/** A mode which allows MPW to automatically select it's data sources */\nexport let fAutoSwitch = true;\n/** The active Cold Staking address: default is the PIVX Labs address */\nexport let strColdStakingAddress = 'SdgQDpS8jDRJDX8yK8m9KnTMarsE84zdsy';\n/** The decimals to display for the wallet balance */\nexport let nDisplayDecimals = 2;\n/** A mode which configures MPW towards Advanced users, with low-level feature access and less restrictions (Potentially dangerous) */\nexport let fAdvancedMode = false;\n\nlet transparencyReport;\n\nexport class Settings {\n    /**\n     * @type {String} analytics level\n     */\n    analytics;\n    /**\n     * @type {String} Explorer url to use\n     */\n    explorer;\n    /**\n     * @type {String} Node url to use\n     */\n    node;\n    /**\n     * @type {Boolean} The Auto-Switch mode state\n     */\n    autoswitch;\n    /**\n     * @type {String} The user's active Cold Staking address\n     */\n    coldAddress;\n    /**\n     * @type {String} translation to use\n     */\n    translation;\n    /**\n     * @type {String} Currency to display\n     */\n    displayCurrency;\n    /**\n     * @type {number} The decimals to display for the wallet balance\n     */\n    displayDecimals;\n    /**\n     * @type {boolean} Whether Advanced Mode is enabled or disabled\n     */\n    advancedMode;\n    constructor({\n        analytics,\n        explorer,\n        node,\n        autoswitch = true,\n        coldAddress = strColdStakingAddress,\n        translation = '',\n        displayCurrency = 'usd',\n        displayDecimals = nDisplayDecimals,\n        advancedMode = false,\n    } = {}) {\n        this.analytics = analytics;\n        this.explorer = explorer;\n        this.node = node;\n        this.autoswitch = autoswitch;\n        this.coldAddress = coldAddress;\n        this.translation = translation;\n        this.displayCurrency = displayCurrency;\n        this.displayDecimals = displayDecimals;\n        this.advancedMode = advancedMode;\n    }\n}\n\n// A list of statistic keys and their descriptions\nexport let STATS = {\n    // Stat key   // Description of the stat, it's data, and it's purpose\n    hit: 'A ping indicating an app load, no unique data is sent.',\n    time_to_sync: 'The time in seconds it took for MPW to last synchronise.',\n    transaction:\n        'A ping indicating a Tx, no unique data is sent, but may be inferred from on-chain time.',\n};\n\nexport const cStatKeys = Object.keys(STATS);\n\n// A list of Analytics 'levels' at which the user may set depending on their privacy preferences\n// NOTE: When changing Level Names, ensure the i18n system is updated to support them too\nlet arrAnalytics = [\n    // Statistic level  // Allowed statistics\n    { name: 'Disabled', stats: [] },\n    { name: 'Minimal', stats: [STATS.hit, STATS.time_to_sync] },\n    {\n        name: 'Balanced',\n        stats: [STATS.hit, STATS.time_to_sync, STATS.transaction],\n    },\n];\n\nexport let cAnalyticsLevel = arrAnalytics[2];\n\n// Users need not look below here.\n// ------------------------------\n// Global Keystore / Wallet Information\n\n// --- DOM Cache\nexport async function start() {\n    //TRANSLATIONS\n    //to make translations work we need to change it so that we just enable or disable the visibility of the text\n    doms.domTestnet.style.display = cChainParams.current.isTestnet\n        ? ''\n        : 'none';\n    doms.domDebug.style.display = debug ? '' : 'none';\n\n    // Hook up the 'currency' select UI\n    document.getElementById('currency').onchange = function (evt) {\n        setCurrency(evt.target.value);\n    };\n\n    // Hook up the 'display decimals' slider UI\n    doms.domDisplayDecimalsSlider.onchange = function (evt) {\n        setDecimals(Number(evt.target.value));\n    };\n\n    // Hook up the 'explorer' select UI\n    document.getElementById('explorer').onchange = function (evt) {\n        setExplorer(\n            cChainParams.current.Explorers.find(\n                (a) => a.url === evt.target.value\n            )\n        );\n    };\n\n    // Hook up the 'translation' select UI\n    document.getElementById('translation').onchange = function (evt) {\n        setTranslation(evt.target.value);\n    };\n\n    // Hook up the 'analytics' select UI\n    document.getElementById('analytics').onchange = function (evt) {\n        setAnalytics(arrAnalytics.find((a) => a.name === evt.target.value));\n    };\n\n    await Promise.all([\n        fillExplorerSelect(),\n        fillNodeSelect(),\n        fillTranslationSelect(),\n    ]);\n\n    // Fetch price data, then fetch chain data\n    if (getNetwork().enabled) {\n        refreshPriceDisplay().finally(refreshChainData);\n    }\n\n    const database = await Database.getInstance();\n\n    // Fetch settings from Database\n    const {\n        analytics: strSettingAnalytics,\n        autoswitch,\n        coldAddress,\n        displayCurrency,\n        displayDecimals,\n        advancedMode,\n    } = await database.getSettings();\n\n    // Set the Cold Staking address\n    strColdStakingAddress = coldAddress;\n\n    // Set any Toggles to their default or DB state\n    // Network Auto-Switch\n    fAutoSwitch = autoswitch;\n    doms.domAutoSwitchToggle.checked = fAutoSwitch;\n\n    // Advanced Mode\n    fAdvancedMode = advancedMode;\n    doms.domAdvancedModeToggler.checked = fAdvancedMode;\n    await configureAdvancedMode();\n\n    // Set the display currency\n    strCurrency = doms.domCurrencySelect.value = displayCurrency;\n\n    // Set the display decimals\n    nDisplayDecimals = displayDecimals;\n    doms.domDisplayDecimalsSlider.value = nDisplayDecimals;\n\n    // Apply translations to the transparency report\n    STATS = {\n        // Stat key   // Description of the stat, it's data, and it's purpose\n        hit: translation.hit,\n        time_to_sync: translation.time_to_sync,\n        transaction: translation.transaction,\n    };\n    transparencyReport = translation.transparencyReport;\n    arrAnalytics = [\n        // Statistic level  // Allowed statistics\n        { name: 'Disabled', stats: [] },\n        { name: 'Minimal', stats: [STATS.hit, STATS.time_to_sync] },\n        {\n            name: 'Balanced',\n            stats: [STATS.hit, STATS.time_to_sync, STATS.transaction],\n        },\n    ];\n\n    // Initialise status icons as their default variables\n    doms.domNetwork.innerHTML =\n        '<i class=\"fa-solid fa-' +\n        (getNetwork().enabled ? 'wifi' : 'ban') +\n        '\"></i>';\n\n    // Honour the \"Do Not Track\" header by default\n    if (!strSettingAnalytics && navigator.doNotTrack === '1') {\n        // Disabled\n        setAnalytics(arrAnalytics[0], true);\n        doms.domAnalyticsDescriptor.innerHTML =\n            '<h6 style=\"color:#dcdf6b;font-family:mono !important;\"><pre style=\"color: inherit;\">Analytics disabled to honour \"Do Not Track\" browser setting, you may manually enable if desired, though!</pre></h6>';\n    } else {\n        // Load from storage, or use defaults\n        setAnalytics(\n            (cAnalyticsLevel =\n                arrAnalytics.find((a) => a.name === strSettingAnalytics) ||\n                cAnalyticsLevel),\n            true\n        );\n    }\n\n    // Add each analytics level into the UI selector\n    fillAnalyticSelect();\n}\n// --- Settings Functions\nexport async function setExplorer(explorer, fSilent = false) {\n    const database = await Database.getInstance();\n    database.setSettings({ explorer: explorer.url });\n    cExplorer = explorer;\n\n    // Enable networking + notify if allowed\n    const network = new ExplorerNetwork(cExplorer.url, wallet);\n    setNetwork(network);\n\n    activityDashboard.reset();\n    stakingDashboard.reset();\n\n    // Update the selector UI\n    doms.domExplorerSelect.value = cExplorer.url;\n\n    if (!fSilent)\n        createAlert(\n            'success',\n            tr(ALERTS.SWITCHED_EXPLORERS, [{ explorerName: cExplorer.name }]),\n            2250\n        );\n}\n\nasync function setNode(node, fSilent = false) {\n    cNode = node;\n    const database = await Database.getInstance();\n    database.setSettings({ node: node.url });\n\n    // Enable networking + notify if allowed\n    getNetwork().enable();\n    if (!fSilent)\n        createAlert(\n            'success',\n            tr(ALERTS.SWITCHED_NODE, [{ node: cNode.name }]),\n            2250\n        );\n}\n\n//TRANSLATION\n/**\n * Switches the translation and sets the translation preference to database\n * @param {string} strLang\n */\nexport async function setTranslation(strLang) {\n    switchTranslation(strLang);\n    const database = await Database.getInstance();\n    database.setSettings({ translation: strLang });\n    doms.domTranslationSelect.value = strLang;\n}\n\n/**\n * Sets and saves the display currency setting in runtime and database\n * @param {string} currency - The currency string name\n */\nasync function setCurrency(currency) {\n    strCurrency = currency;\n    const database = await Database.getInstance();\n    database.setSettings({ displayCurrency: strCurrency });\n    // Update the UI to reflect the new currency\n    getBalance(true);\n    getStakingBalance(true);\n}\n\n/**\n * Sets and saves the display decimals setting in runtime and database\n * @param {number} decimals - The decimals to set for the display\n */\nasync function setDecimals(decimals) {\n    nDisplayDecimals = decimals;\n    const database = await Database.getInstance();\n    database.setSettings({ displayDecimals: nDisplayDecimals });\n    // Update the UI to reflect the new decimals\n    getBalance(true);\n    getStakingBalance(true);\n}\n\n/**\n * Sets and saves the active Cold Staking address\n * @param {string} strColdAddress - The Cold Staking address\n */\nexport async function setColdStakingAddress(strColdAddress) {\n    strColdStakingAddress = strColdAddress;\n    const database = await Database.getInstance();\n    database.setSettings({ coldAddress: strColdAddress });\n}\n\n/**\n * Fills the translation dropbox on the settings page\n */\nasync function fillTranslationSelect() {\n    while (doms.domTranslationSelect.options.length > 0) {\n        doms.domTranslationSelect.remove(0);\n    }\n\n    // Add each language into the UI selector\n    for (const cLang of arrActiveLangs) {\n        const opt = document.createElement('option');\n        opt.innerHTML = `${cLang.emoji} ${cLang.code.toUpperCase()}`;\n        opt.value = cLang.code;\n        doms.domTranslationSelect.appendChild(opt);\n    }\n\n    const database = await Database.getInstance();\n    const { translation: strLang } = await database.getSettings();\n    // And update the UI to reflect them (default to English if none)\n    doms.domTranslationSelect.value = strLang;\n}\n\n/**\n * Fills the display currency dropbox on the settings page\n */\nexport async function fillCurrencySelect() {\n    const arrCurrencies = await cMarket.getCurrencies();\n\n    // Only update if we have a currency list\n    if (!isEmpty(arrCurrencies)) {\n        while (doms.domCurrencySelect.options.length > 0) {\n            doms.domCurrencySelect.remove(0);\n        }\n\n        // Add each data source currency into the UI selector\n        for (const currency of arrCurrencies) {\n            const opt = document.createElement('option');\n            opt.innerHTML = currency.toUpperCase();\n            opt.value = currency;\n            doms.domCurrencySelect.appendChild(opt);\n        }\n    }\n\n    const database = await Database.getInstance();\n    const { displayCurrency } = await database.getSettings();\n\n    // And update the UI to reflect them\n    strCurrency = doms.domCurrencySelect.value = displayCurrency;\n}\n\n/**\n * Fills the Analytics Settings UI\n */\nexport function fillAnalyticSelect() {\n    const domAnalyticsSelect = document.getElementById('analytics');\n    domAnalyticsSelect.innerHTML = '';\n    for (const analLevel of arrAnalytics) {\n        const opt = document.createElement('option');\n        // Apply translation to the display HTML\n        opt.value = analLevel.name;\n        opt.innerHTML = translation['analytic' + analLevel.name];\n        domAnalyticsSelect.appendChild(opt);\n    }\n}\n\nasync function setAnalytics(level, fSilent = false) {\n    cAnalyticsLevel = level;\n    const database = await Database.getInstance();\n    await database.setSettings({ analytics: level.name });\n\n    // For total transparency, we'll 'describe' the various analytic keys of this chosen level\n    let strDesc = '<center>--- ' + transparencyReport + ' ---</center><br>',\n        i = 0;\n    const nLongestKeyLen = cStatKeys.reduce((prev, e) =>\n        prev.length >= e.length ? prev : e\n    ).length;\n    for (i; i < cAnalyticsLevel.stats.length; i++) {\n        const cStat = cAnalyticsLevel.stats[i];\n        // This formats Stat keys into { $key $(padding) $description }\n        strDesc +=\n            cStatKeys\n                .find((a) => STATS[a] === cStat)\n                .padEnd(nLongestKeyLen, ' ') +\n            ': ' +\n            cStat +\n            '<br>';\n    }\n\n    // Set display + notify if allowed\n    doms.domAnalyticsDescriptor.innerHTML =\n        cAnalyticsLevel.name === arrAnalytics[0].name\n            ? ''\n            : '<h6 style=\"color:#dcdf6b;font-family:mono !important;\"><pre style=\"color: inherit;\">' +\n              strDesc +\n              '</pre></h6>';\n    if (!fSilent)\n        createAlert(\n            'success',\n            tr(ALERTS.SWITCHED_ANALYTICS, [\n                { level: translation['analytic' + cAnalyticsLevel.name] },\n            ]),\n            2250\n        );\n}\n\n/**\n * Toggle between Mainnet and Testnet\n */\nexport async function toggleTestnet() {\n    const cNextNetwork = cChainParams.current.isTestnet\n        ? cChainParams.main\n        : cChainParams.testnet;\n\n    // If the current wallet is not saved, we'll ask the user for confirmation, since they'll lose their wallet if they switch with an unsaved wallet!\n    if (wallet.isLoaded() && !(await hasEncryptedWallet())) {\n        const fContinue = await confirmPopup({\n            title: tr(translation.netSwitchUnsavedWarningTitle, [\n                { network: cChainParams.current.name },\n            ]),\n            html: `\n            <b>${tr(translation.netSwitchUnsavedWarningSubtitle, [\n                { network: cChainParams.current.name },\n            ])}</b>\n            <br>\n            ${tr(translation.netSwitchUnsavedWarningSubtext, [\n                { network: cNextNetwork.name },\n            ])}\n            <br>\n            <br>\n            <i style=\"opacity:0.65\">${\n                translation.netSwitchUnsavedWarningConfirmation\n            }</i>\n        `,\n        });\n\n        if (!fContinue) {\n            // Kick back the \"toggle\" switch\n            doms.domTestnetToggler.checked = cChainParams.current.isTestnet;\n            return;\n        }\n    }\n\n    // Update current chain config\n    cChainParams.current = cNextNetwork;\n\n    // Update UI and static tickers\n    doms.domTestnet.style.display = cChainParams.current.isTestnet\n        ? ''\n        : 'none';\n    doms.domGuiBalanceTicker.innerText = cChainParams.current.TICKER;\n    doms.domGuiBalanceStakingTicker.innerText = cChainParams.current.TICKER;\n    doms.domPrefixNetwork.innerText =\n        cChainParams.current.PUBKEY_PREFIX.join(' or ');\n\n    // Update testnet toggle in settings\n    doms.domTestnetToggler.checked = cChainParams.current.isTestnet;\n\n    // Check if the new network has an Account\n    const cNewDB = await Database.getInstance();\n    const cNewAccount = await cNewDB.getAccount();\n    if (cNewAccount?.publicKey) {\n        // Import the new wallet (overwriting the existing in-memory wallet)\n        await importWallet({ newWif: cNewAccount.publicKey });\n    } else {\n        // Nuke the Master Key\n        wallet.setMasterKey(null);\n\n        // Hide all Dashboard info, kick the user back to the \"Getting Started\" area\n        doms.domGenKeyWarning.style.display = 'none';\n        doms.domGuiWallet.style.display = 'none';\n        doms.domWipeWallet.hidden = true;\n        doms.domRestoreWallet.hidden = true;\n\n        // Set the \"Wallet Options\" display CSS to it's Default\n        setDisplayForAllWalletOptions('');\n\n        // Reset the \"Vanity\" and \"Import\" flows\n        doms.domPrefix.value = '';\n        doms.domPrefix.style.display = 'none';\n\n        // Show \"Access Wallet\" button\n        doms.domImportWallet.style.display = 'none';\n        doms.domPrivKey.style.opacity = '0';\n        doms.domAccessWallet.style.display = '';\n        doms.domAccessWalletBtn.style.display = '';\n\n        // Hide \"Import Wallet\" so the user has to follow the `accessOrImportWallet()` flow\n        doms.domImportWallet.style.display = 'none';\n    }\n\n    mempool.UTXOs = [];\n    getBalance(true);\n    getStakingBalance(true);\n    await updateEncryptionGUI(wallet.isLoaded());\n    await fillExplorerSelect();\n    await fillNodeSelect();\n    await updateGovernanceTab();\n    activityDashboard.reset();\n    stakingDashboard.reset();\n}\n\nexport function toggleDebug() {\n    debug = !debug;\n    doms.domDebug.style.display = debug ? '' : 'none';\n}\n\n/**\n * Toggle the Auto-Switch mode at runtime and in DB\n */\nexport async function toggleAutoSwitch() {\n    fAutoSwitch = !fAutoSwitch;\n\n    // Update the setting in the DB\n    const database = await Database.getInstance();\n    await database.setSettings({ autoswitch: fAutoSwitch });\n}\n\nasync function fillExplorerSelect() {\n    cExplorer = cChainParams.current.Explorers[0];\n\n    while (doms.domExplorerSelect.options.length > 0) {\n        doms.domExplorerSelect.remove(0);\n    }\n\n    // Add each trusted explorer into the UI selector\n    for (const explorer of cChainParams.current.Explorers) {\n        const opt = document.createElement('option');\n        opt.value = explorer.url;\n        opt.innerHTML =\n            explorer.name + ' (' + explorer.url.replace('https://', '') + ')';\n        doms.domExplorerSelect.appendChild(opt);\n    }\n\n    // Fetch settings from Database\n    const database = await Database.getInstance();\n    const { explorer: strSettingExplorer } = await database.getSettings();\n\n    // For any that exist: load them, or use the defaults\n    await setExplorer(\n        cChainParams.current.Explorers.find(\n            (a) => a.url === strSettingExplorer\n        ) || cExplorer,\n        true\n    );\n\n    // And update the UI to reflect them\n    doms.domExplorerSelect.value = cExplorer.url;\n}\n\nasync function fillNodeSelect() {\n    cNode = cChainParams.current.Nodes[0];\n\n    while (doms.domNodeSelect.options.length > 0) {\n        doms.domNodeSelect.remove(0);\n    }\n\n    // Add each trusted node into the UI selector\n    for (const node of cChainParams.current.Nodes) {\n        const opt = document.createElement('option');\n        opt.value = node.url;\n        opt.innerHTML =\n            node.name + ' (' + node.url.replace('https://', '') + ')';\n        doms.domNodeSelect.appendChild(opt);\n    }\n\n    // Fetch settings from Database\n    const database = await Database.getInstance();\n    const { node: strSettingNode } = await database.getSettings();\n\n    // For any that exist: load them, or use the defaults\n    setNode(\n        cChainParams.current.Nodes.find((a) => a.url === strSettingNode) ||\n            cNode,\n        true\n    );\n\n    // And update the UI to reflect them\n    doms.domNodeSelect.value = cNode.url;\n}\n\n/**\n * Toggle Advanced Mode at runtime and in DB\n */\nexport async function toggleAdvancedMode() {\n    fAdvancedMode = !fAdvancedMode;\n\n    // Configure the app accordingly\n    await configureAdvancedMode();\n\n    // Update the setting in the DB\n    const database = await Database.getInstance();\n    await database.setSettings({ advancedMode: fAdvancedMode });\n}\n\n/**\n * Configure the app functionality and UI for the current mode\n */\nasync function configureAdvancedMode() {\n    // Re-render the Import Input UI\n    await guiUpdateImportInput();\n\n    // Hide or Show the \"Mnemonic Passphrase\" in the Seed Creation modal, and reset it's input\n    doms.domMnemonicModalPassphrase.value = '';\n    doms.domMnemonicModalPassphrase.hidden = !fAdvancedMode;\n}\n","import { cNode, cExplorer } from './settings.js';\nimport { cChainParams, COIN } from './chain_params.js';\nimport { wallet } from './wallet.js';\nimport { parseWIF, deriveAddress } from './encoding.js';\nimport { cHardwareWallet } from './ledger.js';\nimport { dSHA256, bytesToHex, hexToBytes } from './utils.js';\nimport { Buffer } from 'buffer';\nimport { Address6 } from 'ip-address';\nimport * as nobleSecp256k1 from '@noble/secp256k1';\nimport { OP } from './script.js';\nimport bs58 from 'bs58';\nimport base32 from 'base32';\nimport { isStandardAddress } from './misc.js';\n\n/**\n * Construct a Masternode\n * @param {string} [masternode.walletPrivateKeyPath] - BIP39 path pointing to the private key holding the collateral. Optional if not HD\n * @param {string} masternode.mnPrivateKey - Masternode private key. Must be uncompressed WIF\n * @param {string} masternode.collateralTxId - Must be a UTXO pointing to the collateral\n * @param {number} masternode.outidx - The output id of the collateral starting from 0\n * @param {string} masternode.addr - IPV4 address in the form `ip:port`\n */\nexport default class Masternode {\n    constructor({\n        walletPrivateKeyPath,\n        mnPrivateKey,\n        collateralTxId,\n        outidx,\n        addr,\n    } = {}) {\n        this.walletPrivateKeyPath = walletPrivateKeyPath;\n        this.mnPrivateKey = mnPrivateKey;\n        this.collateralTxId = collateralTxId;\n        this.outidx = outidx;\n        this.addr = addr;\n    }\n    /**\n     * @type {[string, number]} array of vote hash and corresponding vote for the current session\n     */\n    static sessionVotes = [];\n\n    async _getWalletPrivateKey() {\n        return await wallet\n            .getMasterKey()\n            .getPrivateKey(this.walletPrivateKeyPath);\n    }\n\n    /**\n       @return {Promise<Object>} The object containing masternode information for this masternode\n     */\n    async getFullData() {\n        const strURL = `${cNode.url}/listmasternodes?params=${this.collateralTxId}`;\n        try {\n            const cMasternodes = (await (await fetch(strURL)).json()).filter(\n                (m) => m.outidx === this.outidx\n            );\n            if (cMasternodes.length > 0) {\n                return cMasternodes[0];\n            } else {\n                return { status: 'MISSING' };\n            }\n        } catch (e) {\n            //this is the unfortunate state in which the node is not reachable\n            console.error(e);\n            return 'EXPLORER_DOWN';\n        }\n    }\n\n    /**\n       @return {Promise<string>} The status of this masternode.\n     */\n    async getStatus() {\n        const cMasternode = await this.getFullData();\n        return cMasternode ? cMasternode.status : 'MISSING';\n    }\n\n    /**\n     * @param {string} ip\n     * @param {number} port\n     * @returns {string} hex representation of the IP + port pair\n     */\n    static _decodeIpAddress(ip, port) {\n        /**\n         * @type {Array<Number>?}\n         */\n        let bytes;\n        if (ip.endsWith('.onion')) {\n            const onionBytes = base32\n                .decode(ip.slice(0, -6))\n                .split('')\n                .map((c) => c.charCodeAt(0));\n            switch (onionBytes.length) {\n                case 10:\n                    bytes = [0xfd, 0x87, 0xd8, 0x7e, 0xeb, 0x43, ...onionBytes];\n                    break;\n                case 35:\n                    bytes = [0x04, 32, ...onionBytes.slice(0, 32)];\n                    break;\n                default:\n                    throw new Error('Invalid onion address');\n            }\n        } else {\n            const address = ip.includes('.')\n                ? Address6.fromAddress4(ip)\n                : new Address6(ip);\n            bytes = address.toUnsignedByteArray();\n        }\n        const res =\n            bytesToHex([\n                ...new Array(Math.max(16 - bytes.length, 0)).fill(0),\n                ...bytes,\n            ]) + bytesToHex(Masternode._numToBytes(port, 2, false));\n        return res;\n    }\n\n    static _numToBytes(number, numBytes = 8, littleEndian = true) {\n        const bytes = [];\n        for (let i = 0; i < numBytes; i++) {\n            bytes.push((number / 2 ** (8 * i)) & 0xff);\n        }\n        return littleEndian ? bytes : bytes.reverse();\n    }\n\n    /**\n     * @param {Object} message - message to encode\n     * @param {string} message.vin.txid - transaction id of the collateral\n     * @param {number} message.vin.idx - output id of the collateral starting from 0\n     * @param {string} message.blockHash - latest blockhash\n     * @param {number} message.sigTime - current time in seconds since UNIX epoch\n     * @return {Array} Returns the unsigned ping message. It needs to be signed with the MN private key\n     */\n    static getPingSignature({ vin, blockHash, sigTime }) {\n        const ping = [\n            ...hexToBytes(vin.txid).reverse(),\n            ...Masternode._numToBytes(vin.idx, 4, true),\n            // Should be tx sequence, but 0xffffff is fine\n            ...[0, 255, 255, 255, 255],\n            ...hexToBytes(blockHash).reverse(),\n            ...Masternode._numToBytes(sigTime, 8, true),\n        ];\n        return dSHA256(ping);\n    }\n\n    /**\n     * @param {Object} message - Message to encode\n     * @param {string} message.walletPrivateKey - private key of the collateral\n     * @param {string} message.addr - Masternode ipv4 with port\n     * @param {string} message.mnPrivateKey - private key of masternode\n     * @param {number} message.sigTime - current time in seconds since UNIX epoch\n     * @return {string} The message to be signed with the collateral private key.\n     * it needs to be padded with \"\\x18DarkNet Signed Message:\\n\" + Message length + Message\n     * Then hashed two times with SHA256\n     */\n    static getToSign({ publicKey, addr, mnPrivateKey, sigTime }) {\n        let ip, port;\n        if (addr.includes('.')) {\n            // IPv4\n            [ip, port] = addr.split(':');\n        } else {\n            // IPv6\n            [ip, port] = addr.slice(1).split(']');\n            port = port.slice(1);\n        }\n\n        const mnPublicKey = hexToBytes(\n            deriveAddress({\n                pkBytes: parseWIF(mnPrivateKey, true),\n                output: 'UNCOMPRESSED_HEX',\n            })\n        );\n\n        const pkt = [\n            ...Masternode._numToBytes(1, 4, true), // Message version\n            ...hexToBytes(Masternode._decodeIpAddress(ip, port)), // Encoded ip + port\n            ...Masternode._numToBytes(sigTime, 8, true),\n            ...Masternode._numToBytes(publicKey.length, 1, true), // Collateral public key length\n            ...publicKey,\n            ...Masternode._numToBytes(mnPublicKey.length, 1, true), // Masternode public key length\n            ...mnPublicKey,\n            ...Masternode._numToBytes(\n                cChainParams.current.PROTOCOL_VERSION,\n                4,\n                true\n            ), // Protocol version\n        ];\n        return bytesToHex(dSHA256(pkt).reverse());\n    }\n\n    /**\n     * @return {Promise<string>} The last block hash\n     */\n    static async getLastBlockHash() {\n        const status = await (await fetch(`${cExplorer.url}/api/`)).json();\n        return status.backend.bestBlockHash;\n    }\n\n    /**\n     * @return {Promise<string>} The signed message signed with the collateral private key\n     */\n    async getSignedMessage(sigTime) {\n        const toSign = Masternode.getToSign({\n            addr: this.addr,\n            publicKey: await this.getWalletPublicKey(),\n            mnPrivateKey: this.mnPrivateKey,\n            sigTime,\n        });\n\n        if (wallet.isHardwareWallet()) {\n            const { r, s, v } = await cHardwareWallet.signMessage(\n                this.walletPrivateKeyPath,\n                bytesToHex(toSign)\n            );\n            return [v + 31, ...hexToBytes(r), ...hexToBytes(s)];\n        } else {\n            const padding = '\\x18DarkNet Signed Message:\\n'\n                .split('')\n                .map((c) => c.charCodeAt(0));\n            const walletPrivateKey = await this._getWalletPrivateKey();\n\n            const message = toSign.split('').map((c) => c.charCodeAt(0));\n            const hash = dSHA256(\n                padding.concat(message.length).concat(message)\n            );\n            const [signature, v] = await nobleSecp256k1.sign(\n                hash,\n                parseWIF(walletPrivateKey, true),\n                { der: false, recovered: true }\n            );\n            return [v + 31, ...signature];\n        }\n    }\n    /**\n     * @return {Promise<string>} The signed ping message signed with the masternode private key\n     */\n    async getSignedPingMessage(sigTime, blockHash) {\n        const toSign = Masternode.getPingSignature({\n            vin: {\n                txid: this.collateralTxId,\n                idx: this.outidx,\n            },\n            blockHash,\n            sigTime,\n        });\n        const [signature, v] = await nobleSecp256k1.sign(\n            toSign,\n            parseWIF(this.mnPrivateKey, true),\n            { der: false, recovered: true }\n        );\n        return [v + 27, ...signature];\n    }\n\n    async getWalletPublicKey() {\n        if (wallet.isHardwareWallet()) {\n            return hexToBytes(\n                await wallet\n                    .getMasterKey()\n                    .getPublicKey(this.walletPrivateKeyPath)\n            );\n        } else {\n            const walletPrivateKey = await this._getWalletPrivateKey();\n            return hexToBytes(\n                deriveAddress({\n                    pkBytes: parseWIF(walletPrivateKey, true),\n                    output: 'COMPRESSED_HEX',\n                })\n            );\n        }\n    }\n\n    /**\n     * Get the message encoded to hex used to start a masternode\n     * It uses to two signatures: `getPingSignature()` which is signed\n     * With the masternode private key, and `getToSign()` which is signed with\n     * The collateral private key\n     * @return {Promise<string>} The message used to start a masternode.\n     */\n    async broadcastMessageToHex() {\n        const sigTime = Math.round(Date.now() / 1000);\n        const blockHash = await Masternode.getLastBlockHash();\n        let ip, port;\n        if (this.addr.includes('.')) {\n            // IPv4\n            [ip, port] = this.addr.split(':');\n        } else {\n            // IPv6\n            [ip, port] = this.addr.slice(1).split(']');\n            port = port.slice(1);\n        }\n        const walletPublicKey = await this.getWalletPublicKey();\n\n        const mnPublicKey = hexToBytes(\n            deriveAddress({\n                pkBytes: parseWIF(this.mnPrivateKey, true),\n                output: 'UNCOMPRESSED_HEX',\n                compress: false,\n            })\n        );\n\n        const sigBytes = await this.getSignedMessage(sigTime);\n        const sigPingBytes = await this.getSignedPingMessage(\n            sigTime,\n            blockHash\n        );\n\n        const message = [\n            ...hexToBytes(this.collateralTxId).reverse(),\n            ...Masternode._numToBytes(this.outidx, 4, true),\n            ...Masternode._numToBytes(0, 1, true), // Message version\n            ...Masternode._numToBytes(0xffffffff, 4, true),\n            ...hexToBytes(Masternode._decodeIpAddress(ip, port)),\n            ...Masternode._numToBytes(walletPublicKey.length, 1, true),\n            ...walletPublicKey,\n            ...Masternode._numToBytes(mnPublicKey.length, 1, true),\n            ...mnPublicKey,\n            ...Masternode._numToBytes(sigBytes.length, 1, true),\n            ...sigBytes,\n            ...Masternode._numToBytes(sigTime, 8, true),\n            ...Masternode._numToBytes(\n                cChainParams.current.PROTOCOL_VERSION,\n                4,\n                true\n            ),\n            ...hexToBytes(this.collateralTxId).reverse(),\n            ...Masternode._numToBytes(this.outidx, 4, true),\n            ...Masternode._numToBytes(0, 1, true),\n            ...Masternode._numToBytes(0xffffffff, 4, true),\n            ...hexToBytes(blockHash).reverse(),\n            ...Masternode._numToBytes(sigTime, 8, true),\n            ...Masternode._numToBytes(sigPingBytes.length, 1, true),\n            ...sigPingBytes,\n            ...Masternode._numToBytes(1, 4, true),\n            ...Masternode._numToBytes(1, 4, true),\n        ];\n        return bytesToHex(message);\n    }\n\n    /**\n     * Start the masternode\n     * @return {Promise<bool>} Whether or not the message was relayed successfully. This does not necessarely mean\n     * starting was successful, but only that the node was able to decode the broadcast.\n     */\n    async start() {\n        const message = await this.broadcastMessageToHex();\n        const url = `${cNode.url}/relaymasternodebroadcast?params=${message}`;\n        const response = await (await fetch(url)).text();\n        return response.includes('Masternode broadcast sent');\n    }\n\n    /**\n     *\n     * @param {object} options\n     * @param {bool} options.fAllowFinished - Pass `true` to stop filtering proposals if finished\n     * @return {Promise<Array<object>} A list of currently active proposal\n     */\n    static async getProposals({ fAllowFinished = false } = {}) {\n        const url = `${cNode.url}/getbudgetinfo`;\n        let arrProposals = await (await fetch(url)).json();\n\n        // Apply optional filters\n        if (!fAllowFinished) {\n            arrProposals = arrProposals.filter(\n                (a) => a.RemainingPaymentCount > 0\n            );\n        }\n        return arrProposals;\n    }\n\n    /**\n     * @param {string} hash - the hash of the proposal to vote\n     * @param {number} voteCode - the vote code. \"Yes\" is 1, \"No\" is 2\n     * @param {number} sigTime - The current time in seconds since UNIX epoch\n     * @return {Promise<string>} The signed message used to vote\n     */\n    async getSignedVoteMessage(hash, voteCode, sigTime) {\n        const msg = [\n            ...hexToBytes(this.collateralTxId).reverse(),\n            ...Masternode._numToBytes(this.outidx, 4, true),\n            // Should be tx sequence, but 0xffffff is fine\n            ...[0, 255, 255, 255, 255],\n            ...hexToBytes(hash).reverse(),\n            ...Masternode._numToBytes(voteCode, 4, true),\n            ...Masternode._numToBytes(sigTime, 8, true),\n        ];\n\n        const [signature, v] = await nobleSecp256k1.sign(\n            dSHA256(msg),\n            parseWIF(this.mnPrivateKey, true),\n            { der: false, recovered: true }\n        );\n        return Buffer.from([v + 27, ...signature]).toString('base64');\n    }\n    /**\n     * @param {string} proposalName - the name of the proposal you want to get the vote of\n     * @param {string} hash - the hash of the proposal you want to get the vote of\n     * @return {Promise<number>} Vote code \"Yes\" is 1, \"No\" is 2\n     */\n    async getVote(proposalName, hash) {\n        //See if you already voted the proposal in the current session\n        const index = Masternode.sessionVotes.findIndex(\n            ([vHash]) => vHash === hash\n        );\n        if (index !== -1) {\n            //Found it! return the vote\n            return Masternode.sessionVotes[index][1];\n        }\n        //Haven't voted yet, fetch the result from Duddino's node\n        const filterString = `.[] | select(.mnId==\"`;\n        const filter =\n            `${encodeURI(filterString)}` +\n            `${this.collateralTxId}-${this.outidx}\")`;\n        const url = `${cNode.url}/getbudgetvotes?params=${proposalName}&filter=${filter}`;\n        try {\n            const { Vote: vote } = await (await fetch(url)).json();\n            return vote === 'YES' ? 1 : 2;\n        } catch (e) {\n            //Cannot parse JSON! This means that you did not vote hence return null\n            return null;\n        }\n    }\n    /**\n     * Stores a vote for the current session\n     * @param {string} hash - the hash of the proposal to vote\n     * @param {number} voteCode - the vote code. \"Yes\" is 1, \"No\" is 2\n     */\n    storeVote(hash, voteCode) {\n        const newVote = [hash, voteCode];\n        const index = Masternode.sessionVotes.findIndex(\n            ([vHash]) => vHash === hash\n        );\n        if (index !== -1) {\n            Masternode.sessionVotes[index] = newVote;\n        } else {\n            Masternode.sessionVotes.push(newVote);\n        }\n    }\n    /**\n     * @param {string} hash - the hash of the proposal to vote\n     * @param {number} voteCode - the vote code. \"Yes\" is 1, \"No\" is 2\n     * @return {Promise<string>} The response from the node\n     */\n    async vote(hash, voteCode) {\n        const sigTime = Math.round(Date.now() / 1000);\n        const signature = await this.getSignedVoteMessage(\n            hash,\n            voteCode,\n            sigTime\n        );\n        const url = `${cNode.url}/mnbudgetrawvote?params=${\n            this.collateralTxId\n        },${this.outidx},${hash},${\n            voteCode === 1 ? 'yes' : 'no'\n        },${sigTime},${encodeURI(signature).replaceAll('+', '%2b')}`;\n        const text = await (await fetch(url)).text();\n        return text;\n    }\n\n    /**\n     * Create proposal hash\n     * @param {Object} options\n     * @param {String} options.name - Name of the proposal\n     * @param {String} options.url - Url of the proposal\n     * @param {Number} options.nPayments - Number of cycles this proposal is gonna last\n     * @param {Number} options.start - Superblock of when the proposal is going to start\n     * @param {String} options.address - Base58 encoded PIVX address\n     * @param {Number} options.monthlyPayment - Payment amount per cycle in satoshi\n     * @returns {String} hex hash of the proposal\n     */\n    static createProposalHash({\n        name,\n        url,\n        nPayments,\n        start,\n        address,\n        monthlyPayment,\n    }) {\n        const end =\n            start + (cChainParams.current.budgetCycleBlocks + 1) * nPayments;\n        const addressBytes = bs58.decode(address);\n        const scriptBytes = [\n            OP.DUP,\n            OP.HASH160,\n            addressBytes.length - 5,\n            ...addressBytes.slice(1, addressBytes.length - 4),\n            OP.EQUALVERIFY,\n            OP.CHECKSIG,\n        ];\n        const msg = [\n            name.length,\n            ...name.split('').map((c) => c.charCodeAt(0)),\n            url.length,\n            ...url.split('').map((c) => c.charCodeAt(0)),\n            ...Masternode._numToBytes(start, 4, true),\n            ...Masternode._numToBytes(end, 4, true),\n            ...Masternode._numToBytes(monthlyPayment, 8, true),\n            scriptBytes.length,\n            ...scriptBytes,\n        ];\n        return bytesToHex(dSHA256(new Uint8Array(msg)));\n    }\n\n    /**\n     * Finalize the proposal\n     * @param {Object} options\n     * @param {String} options.name - Name of the proposal\n     * @param {String} options.url - Url of the proposal\n     * @param {Number} options.nPayments - Number of cycles this proposal is gonna last\n     * @param {Number} options.start - Superblock of when the proposal is going to start\n     * @param {String} options.address - Base58 encoded PIVX address\n     * @param {Number} options.monthlyPayment - Payment amount per cycle in satoshi\n     * @param {String} options.txid - Transaction id of the proposal fee\n     * @returns {Promise<{ ok: boolean, err: string | undefined, hash: string | undefined }>} The Vote Hash, if the finalization happened without errors\n     */\n    static async finalizeProposal({\n        name,\n        url,\n        nPayments,\n        start,\n        address,\n        monthlyPayment,\n        txid,\n    }) {\n        try {\n            const res = await (\n                await fetch(\n                    `${cNode.url}/submitbudget?params=${encodeURI(\n                        name\n                    )},${encodeURI(url)},${nPayments},${start},${encodeURI(\n                        address\n                    )},${monthlyPayment / COIN},${txid}`\n                )\n            ).text();\n\n            if (/^\"[a-f0-9]\"$/ && res.length == 64 + 2) {\n                return { ok: true, hash: res };\n            } else if (\n                res.includes('is unconfirmed') ||\n                res.includes('requires at least')\n            ) {\n                return { ok: false, err: 'unconfirmed' };\n            } else if (\n                res.includes('invalid budget proposal') ||\n                res.includes('Invalid block start')\n            ) {\n                return { ok: false, err: 'invalid' };\n            } else {\n                return { ok: false, err: 'other' };\n            }\n        } catch (e) {\n            console.error(e);\n            return { ok: false, err: e };\n        }\n    }\n\n    static async getNextSuperblock() {\n        return parseInt(\n            await (await fetch(`${cNode.url}/getnextsuperblock`)).text()\n        );\n    }\n\n    /**\n     * Fetches the masternode count object, containing each status and network.\n     * @returns {Promise<{total:number, stable:number, enabled:number, inqueue:number, ipv4:number, ipv6:number, onion:number}>} - The masternode count object\n     */\n    static async getMasternodeCount() {\n        return await (await fetch(`${cNode.url}/getmasternodecount`)).json();\n    }\n\n    /**\n     * @param {Object} options\n     * @param {String} options.name - Name of the proposal\n     * @param {String} options.url - Url of the proposal\n     * @param {Number} options.nPayments - Number of cycles this proposal is gonna last\n     * @param {Number} options.start - Superblock of when the proposal is going to start\n     * @param {String} options.address - Base58 encoded PIVX address\n     * @param {Number} options.monthlyPayment - Payment amount per cycle in satoshi\n     * @returns {boolean} If the proposal is valid\n     */\n    static isValidProposal({\n        name,\n        url,\n        nPayments,\n        _start,\n        address,\n        monthlyPayment,\n    }) {\n        const isSafeStr = /^[a-z0-9 .,;\\-_/:?@()]+$/i;\n        if (name.length > 20) {\n            return { ok: false, err: 'name_length' };\n        }\n\n        if (!isSafeStr.test(name)) {\n            return { ok: false, err: 'invalid_name' };\n        }\n\n        if (url.length > 64) {\n            return { ok: false, err: 'url_length' };\n        }\n\n        if (!isSafeStr.test(url)) {\n            return { ok: false, err: 'invalid_url' };\n        }\n\n        if (\n            !/^(https?):\\/\\/[^\\s/$.?#][^\\s]*[^\\s/.]\\.[^\\s/.][^\\s]*[^\\s.]$/.test(\n                url\n            )\n        ) {\n            return { ok: false, err: 'invalid_url' };\n        }\n\n        if (\n            nPayments < 1 ||\n            nPayments > cChainParams.current.maxPaymentCycles\n        ) {\n            return { ok: false, err: 'invalid_payment_count' };\n        }\n\n        if (\n            monthlyPayment < 10 * COIN ||\n            monthlyPayment * nPayments > cChainParams.current.maxPayment\n        ) {\n            return { ok: false, err: 'invalid_monthly_payment' };\n        }\n        if (!isStandardAddress(address)) {\n            return { ok: false, err: 'invalid_address' };\n        }\n\n        return { ok: true };\n    }\n}\n","import { cChainParams, COIN } from './chain_params';\nimport { Database } from './database';\nimport { doms, getBalance, restoreWallet, sweepAddress } from './global';\nimport {\n    arrayToCSV,\n    createAlert,\n    downloadBlob,\n    getAlphaNumericRand,\n} from './misc';\nimport { ALERTS, translation, tr } from './i18n';\nimport { getNetwork } from './network';\nimport { scanQRCode } from './scanner';\nimport { createAndSendTransaction } from './transactions';\nimport { wallet } from './wallet';\nimport { LegacyMasterKey } from './masterkey';\nimport { deriveAddress } from './encoding';\n\n/** The fee in Sats to use for Creating or Redeeming PIVX Promos */\nexport const PROMO_FEE = 10000;\n\n/**\n * The global storage for temporary Promo Code wallets, this is used for sweeping funds\n * @type {PromoWallet}\n */\nexport let cPromoWallet = null;\n\nexport class PromoWallet {\n    /**\n     * @param {object} data - An object containing the PromoWallet data\n     * @param {string} data.code - The human-readable Promo Code\n     * @param {string} data.address - The public key associated with the Promo Code\n     * @param {Uint8Array} data.pkBytes - The private key bytes derived from the Promo Code\n     * @param {Date|number} data.time - The Date or timestamp the code was created\n     * @param {Array<object>} data.utxos - UTXOs associated with the Promo Code\n     */\n    constructor({ code, address, pkBytes, utxos, time }) {\n        /** @type {string} The human-readable Promo Code */\n        this.code = code;\n        /** @type {string} The public key associated with the Promo Code */\n        this.address = address;\n        /** @type {Uint8Array} The private key bytes derived from the Promo Code */\n        this.pkBytes = pkBytes;\n        /** @type {Array<object>} UTXOs associated with the Promo Code */\n        this.utxos = utxos;\n        /** @type {Date|number} The Date or timestamp the code was created */\n        this.time = time instanceof Date ? time : new Date(time);\n    }\n\n    /** A flag to show if this UTXO has successfully synced UTXOs previously */\n    fSynced = false;\n\n    /** A lock to prevent this Promo from synchronisation races */\n    fLock = false;\n\n    /**\n     * Synchronise UTXOs and return the balance of the Promo Code\n     * @param {boolean} - Whether to use UTXO Cache, or sync from network\n     * @returns {Promise<number>} - The Promo Wallet balance in sats\n     */\n    async getBalance(fCacheOnly = false) {\n        // Refresh our UTXO set\n        if (!fCacheOnly) {\n            await this.getUTXOs();\n        }\n\n        // Return the sum of the set\n        return this.utxos.reduce((a, b) => a + b.sats, 0);\n    }\n\n    /**\n     * Synchronise UTXOs and return them\n     * @param {boolean} - Whether to sync simple UTXOs or full UTXOs\n     * @returns {Promise<Array<object>>}\n     */\n    async getUTXOs(fFull = false) {\n        // For shallow syncs, don't allow racing: but Full syncs are allowed to bypass for Tx creation\n        if (!fFull && this.fLock) return this.utxos;\n        this.fLock = true;\n\n        // If we don't have it, derive the public key from the promo code's WIF\n        if (!this.address) {\n            this.address = deriveAddress({ pkBytes: this.pkBytes });\n        }\n\n        // Check for UTXOs on the explorer\n        const arrSimpleUTXOs = await getNetwork().getUTXOs(this.address);\n\n        // Either format the simple UTXOs, or additionally sync the full UTXOs with scripts\n        this.utxos = [];\n        for (const cUTXO of arrSimpleUTXOs) {\n            if (fFull) {\n                this.utxos.push(await getNetwork().getUTXOFullInfo(cUTXO));\n            } else {\n                this.utxos.push({\n                    id: cUTXO.txid,\n                    sats: parseInt(cUTXO.value),\n                    vout: cUTXO.vout,\n                });\n            }\n        }\n\n        // Unlock, mark as synced and return the UTXO set\n        this.fLock = false;\n        this.fSynced = true;\n        return this.utxos;\n    }\n}\n\n/**\n *  The mode of the Promo system: Redeem when true - Create when false.\n */\nlet fPromoRedeem = true;\n\n/**\n * Sets the mode of the PIVX Promos UI\n * @param {boolean} fMode - `true` to redeem, `false` to create\n */\nexport async function setPromoMode(fMode) {\n    fPromoRedeem = fMode;\n\n    // Modify the UI to match the mode\n    if (fPromoRedeem) {\n        // Swap the buttons\n        doms.domRedeemCodeModeRedeemBtn.style.opacity = '0.5';\n        doms.domRedeemCodeModeRedeemBtn.style.cursor = 'default';\n        doms.domRedeemCodeModeCreateBtn.style.opacity = '0.8';\n        doms.domRedeemCodeModeCreateBtn.style.cursor = 'pointer';\n\n        // Show the redeem box, hide create box\n        doms.domRedeemCodeUse.style.display = '';\n        doms.domRedeemCodeCreate.style.display = 'none';\n\n        // Set the title and confirm button\n        doms.domRedeemTitle.innerText = 'Redeem Code';\n        doms.domRedeemCodeConfirmBtn.innerText = 'Redeem';\n\n        // Hide table\n        doms.domPromoTable.classList.add('d-none');\n\n        // Show smooth table animation\n        setTimeout(() => {\n            doms.domPromoTable.style.maxHeight = '0px';\n        }, 100);\n    } else {\n        // Swap the buttons\n        doms.domRedeemCodeModeRedeemBtn.style.opacity = '0.8';\n        doms.domRedeemCodeModeRedeemBtn.style.cursor = 'pointer';\n        doms.domRedeemCodeModeCreateBtn.style.opacity = '0.5';\n        doms.domRedeemCodeModeCreateBtn.style.cursor = 'default';\n\n        // Show the redeem box, hide create box\n        doms.domRedeemCodeUse.style.display = 'none';\n        doms.domRedeemCodeCreate.style.display = '';\n\n        // Set the title and confirm button\n        doms.domRedeemTitle.innerText = 'Create Code';\n        doms.domRedeemCodeConfirmBtn.innerText = 'Create';\n\n        // Render saved codes\n        const cCodes = await renderSavedPromos();\n\n        // Show animation when promo creation thread has 1 or more items\n        if (arrPromoCreationThreads.length || cCodes.codes) {\n            // Refresh the Promo UI\n            await updatePromoCreationTick();\n\n            // Show table\n            doms.domRedeemCodeCreatePendingList.innerHTML = cCodes.html;\n            doms.domPromoTable.classList.remove('d-none');\n\n            // Show smooth table animation\n            setTimeout(() => {\n                doms.domPromoTable.style.maxHeight = 'min-content';\n            }, 100);\n        }\n    }\n}\n\n/**\n * The GUI handler function for hitting the promo modal 'Confirm' button\n */\nexport function promoConfirm() {\n    if (fPromoRedeem) {\n        redeemPromoCode(doms.domRedeemCodeInput.value);\n    } else {\n        // Show table\n        doms.domPromoTable.classList.remove('d-none');\n\n        // Show smooth table animation\n        setTimeout(() => {\n            doms.domPromoTable.style.maxHeight = 'min-content';\n        }, 100);\n\n        createPromoCode(\n            doms.domRedeemCodeCreateInput.value,\n            Number(doms.domRedeemCodeCreateAmountInput.value)\n        );\n    }\n}\n\n/**\n * A list of promo creation threads, each thread works on a unique code\n * @type {Array<Worker>}\n */\nconst arrPromoCreationThreads = [];\n\n/**\n * A lock for updating promo-creation related UI and threads\n */\nlet fPromoIntervalStarted = false;\n\n/**\n * Create a new 'PIVX Promos' code with a webworker\n * @param {string} strCode - The Promo Code to create\n * @param {number} nAmount - The Promo Code amount in coins\n * @param {boolean} fAddRandomness - Whether to append Randomness to the code\n */\nexport async function createPromoCode(strCode, nAmount, fAddRandomness = true) {\n    // Determine if we're adding randomness - and if so, if it's appended entropy or full randomness\n    const strFinalCode = fAddRandomness\n        ? strCode\n            ? strCode + '-' + getAlphaNumericRand(5).toUpperCase()\n            : getAlphaNumericRand(10).toUpperCase()\n        : strCode;\n\n    // Ensure the amount is sane\n    const min = 0.01;\n    if (nAmount < min) {\n        return createAlert(\n            'warning',\n            tr(ALERTS.PROMO_MIN, [\n                { min },\n                { ticker: cChainParams.current.TICKER },\n            ])\n        );\n    }\n\n    // Ensure there's no more than half the device's cores used\n    if (arrPromoCreationThreads.length >= navigator.hardwareConcurrency)\n        return createAlert(\n            'warning',\n            tr(ALERTS.PROMO_MAX_QUANTITY, [\n                { quantity: navigator.hardwareConcurrency },\n            ]),\n            4000\n        );\n\n    // Ensure the user has enough balance (Code amount + Redeem fee + Blockchain fee buffer)\n    const nReservedBalance = arrPromoCreationThreads.reduce(\n        (a, b) => a + b.amount * COIN,\n        0\n    );\n    if (getBalance() - nReservedBalance < nAmount * COIN + PROMO_FEE * 2) {\n        return createAlert(\n            'warning',\n            tr(ALERTS.PROMO_NOT_ENOUGH, [\n                { ticker: cChainParams.current.TICKER },\n            ]),\n            4000\n        );\n    }\n\n    // Ensure the user doesn't create the same code twice\n    const db = await Database.getInstance();\n    const arrCodes = (await db.getAllPromos()).concat(arrPromoCreationThreads);\n    if (arrCodes.some((a) => a.code === strFinalCode)) {\n        return createAlert('warning', ALERTS.PROMO_ALREADY_CREATED, 3000);\n    }\n\n    // Create a new thread\n    const cThread = {\n        code: strFinalCode,\n        amount: nAmount,\n        thread: new Worker(new URL('./promos_worker.js', import.meta.url)),\n        txid: '',\n        update: function (evt) {\n            if (evt.data.type === 'progress') {\n                this.progress = evt.data.res.progress;\n                // If the State HTML is available, render it!\n                const cElement = document.getElementById('c' + this.code);\n                if (cElement) {\n                    cElement.innerText = this.progress;\n                }\n            } else {\n                this.key = evt.data.res.bytes;\n            }\n        },\n        end_state: '',\n    };\n\n    // Inject the promo code in to the thread context\n    cThread.thread.code = strFinalCode;\n\n    // Setup it's internal update function\n    cThread.thread.onmessage = cThread.update;\n\n    // Start the thread\n    cThread.thread.postMessage(strFinalCode);\n\n    // Push to the global threads list\n    arrPromoCreationThreads.push(cThread);\n\n    // Refresh the promo UI\n    await updatePromoCreationTick();\n}\n\nexport async function deletePromoCode(strCode) {\n    // Delete any ongoing threads\n    const nThread = arrPromoCreationThreads.findIndex(\n        (a) => a.code === strCode\n    );\n    if (nThread >= 0) {\n        // Terminate the Web Worker\n        arrPromoCreationThreads[nThread].thread.terminate();\n        // Remove the thread from memory\n        arrPromoCreationThreads.splice(nThread, 1);\n    }\n\n    // Delete the database entry, if it exists\n    const db = await Database.getInstance();\n    await db.removePromo(strCode);\n\n    // And splice from post-creation memory too, if it exists\n    const nMemIndex = arrPromoCodes.findIndex(\n        (cCode) => cCode.code === strCode\n    );\n    if (nMemIndex >= 0) {\n        arrPromoCodes.splice(nMemIndex, 1);\n    }\n\n    // Re-render promos\n    await updatePromoCreationTick();\n}\n\n/**\n * A pair of code quantity and HTML\n * @typedef {Object} RenderedPromoPair\n * @property {number} codes - The number of codes returned in the response.\n * @property {string} html - The HTML string returned in the response.\n */\n\n/** An in-memory representation of all created Promo Wallets\n * @type {Array<PromoWallet>}\n */\nlet arrPromoCodes = [];\n\n/**\n * Render locally-saved Promo Codes in the created list\n * @type {Promise<RenderedPromoPair>} - The code count and HTML pair\n */\nexport async function renderSavedPromos() {\n    // Begin rendering our list of codes\n    let strHTML = '';\n\n    // Finished or 'Saved' codes are hoisted to the top, static\n    const db = await Database.getInstance();\n    const arrCodes = await db.getAllPromos();\n\n    // Render each code; sorted by Newest First, Oldest Last.\n    for (const cDiskCode of arrCodes.sort((a, b) => b.time - a.time)) {\n        // Move on-disk promos to a memory representation for quick state computation\n        let cCode = arrPromoCodes.find((code) => code.code === cDiskCode.code);\n        if (!cCode) {\n            // Push this disk promo to memory\n            cCode = cDiskCode;\n            arrPromoCodes.push(cCode);\n        }\n\n        // Sync only the balance of the code (not full data)\n        cCode.getUTXOs(false);\n        const nBal = (await cCode.getBalance(true)) / COIN;\n\n        // A code younger than ~3 minutes without a balance will just say 'confirming', since Blockbook does not return a balance for NEW codes\n        const fNew = cCode.time.getTime() > Date.now() - 60000 * 3;\n\n        // If this code is allowed to be deleted or not\n        const fCannotDelete = !cCode.fSynced || fNew || nBal > 0;\n\n        // Status calculation (defaults to 'fNew' condition)\n        let strStatus = 'Confirming...';\n        if (!fNew) {\n            if (cCode.fSynced) {\n                strStatus = nBal > 0 ? 'Unclaimed' : 'Claimed';\n            } else {\n                strStatus = 'Syncing';\n            }\n        }\n        strHTML += `\n             <tr>\n                 <td>${\n                     fCannotDelete\n                         ? '<i class=\"fa-solid fa-ban\" style=\"opacity: 0.4; cursor: default;\">'\n                         : '<i class=\"fa-solid fa-ban ptr\" onclick=\"MPW.deletePromoCode(\\'' +\n                           cCode.code +\n                           '\\')\"></i>'\n                 }\n                 </td>\n                 <td><i onclick=\"MPW.toClipboard('copy${\n                     cCode.address\n                 }', this)\" class=\"fas fa-clipboard\" style=\"cursor: pointer; margin-right: 10px;\"></i><code id=\"copy${\n            cCode.address\n        }\" class=\"wallet-code\" style=\"display: inline !important; color: purple;\">${\n            cCode.code\n        }</code></td>\n                 <td>${\n                     fNew || !cCode.fSynced\n                         ? '...'\n                         : nBal + ' ' + cChainParams.current.TICKER\n                 }</td>\n                 <td><a class=\"ptr active\" style=\"margin-right: 10px;\" href=\"${\n                     getNetwork().strUrl + '/address/' + cCode.address\n                 }\" target=\"_blank\" rel=\"noopener noreferrer\"><i class=\"fa-solid fa-up-right-from-square\"></i></a>${strStatus}</td>\n             </tr>\n         `;\n    }\n\n    // Return how many codes were rendered\n    return { codes: arrCodes.length, html: strHTML };\n}\n\n/** Export and download all PIVX Promos data in to a CSV format */\nexport async function promosToCSV() {\n    const arrCSV = [\n        // Titles\n        ['Promo Code', 'PIV (Remaining)', 'Funding Address'],\n        // Content\n    ];\n\n    // Push each code in to the CSV\n    for (const cCode of arrPromoCodes) {\n        arrCSV.push([\n            cCode.code,\n            (await cCode.getBalance(true)) / COIN,\n            cCode.address,\n        ]);\n    }\n\n    // Encode it\n    const cCSV = arrayToCSV(arrCSV);\n\n    // Download it\n    downloadBlob(cCSV, 'promos.csv', 'text/csv;charset=utf-8;');\n}\n\n/**\n * Handle the Promo Workers, Code Rendering, and update or prompt the UI appropriately\n * @param {boolean} fRecursive - Whether this call is self-initiated or not\n */\nexport async function updatePromoCreationTick(fRecursive = false) {\n    // Begin rendering our list of codes\n    const cSavedCodes = await renderSavedPromos();\n    let strHTML = cSavedCodes.html;\n\n    // Loop all threads, displaying their progress\n    for (const cThread of arrPromoCreationThreads) {\n        // Check if the code is derived, if so, fill it with it's balance\n        if (cThread.thread.key && !cThread.end_state) {\n            const strAddress = deriveAddress({ pkBytes: cThread.thread.key });\n\n            // Ensure the wallet is unlocked\n            if (wallet.isViewOnly()) {\n                $('#redeemCodeModal').modal('hide');\n                if (await restoreWallet(translation.walletUnlockPromo)) {\n                    // Unlocked! Re-show the promo UI and continue\n                    $('#redeemCodeModal').modal('show');\n                } else {\n                    // Failed to unlock, so just mark as cancelled\n                    cThread.end_state = 'Cancelled';\n                    $('#redeemCodeModal').modal('show');\n                }\n            }\n\n            // Send the fill transaction if unlocked\n            if (!wallet.isViewOnly()) {\n                const res = await createAndSendTransaction({\n                    address: strAddress,\n                    amount: cThread.amount * COIN + 10000,\n                }).catch((_) => {\n                    // Failed to create this code - mark it as errored\n                    cThread.end_state = 'Errored';\n                });\n                if (res && res.ok) {\n                    cThread.txid = res.txid;\n                    cThread.end_state = 'Done';\n                } else {\n                    // If it looks like it was purposefully cancelled, then mark it as such\n                    cThread.end_state = 'Cancelled';\n                }\n            }\n        }\n\n        // The 'state' is either a percentage to completion, the TXID, or an arbitrary state (error, etc)\n        let strState = '';\n        if (cThread.txid) {\n            // Complete state\n            strState = 'Confirming...';\n        } else if (cThread.end_state) {\n            // Errored state (failed to broadcast, etc)\n            strState = cThread.end_state;\n        } else {\n            // Display progress\n            strState =\n                '<span id=\"c' +\n                cThread.code +\n                '\">' +\n                (cThread.thread.progress || 0) +\n                '</span>%';\n        }\n\n        // Render the table row\n        strHTML =\n            `\n             <tr>\n                 <td><i class=\"fa-solid fa-ban ptr\" onclick=\"MPW.deletePromoCode('${cThread.code}')\"></i></td>\n                 <td><code class=\"wallet-code active\" style=\"display: inline !important;\">${cThread.code}</code></td>\n                 <td>${cThread.amount} ${cChainParams.current.TICKER}</td>\n                 <td>${strState}</td>\n             </tr>\n         ` + strHTML;\n    }\n\n    // Render the compiled HTML\n    doms.domRedeemCodeCreatePendingList.innerHTML = strHTML;\n\n    const db = await Database.getInstance();\n    for (const cThread of arrPromoCreationThreads) {\n        if (cThread.end_state === 'Done') {\n            // Convert to PromoWallet\n            const cPromo = new PromoWallet({\n                code: cThread.code,\n                address: deriveAddress({ pkBytes: cThread.thread.key }),\n                pkBytes: cThread.thread.key,\n                // For storage, UTXOs are not necessary, so are left empty\n                utxos: [],\n                time: Date.now(),\n            });\n\n            // Save to DB\n            await db.addPromo(cPromo);\n\n            // Terminate and destroy the thread\n            cThread.thread.terminate();\n            arrPromoCreationThreads.splice(\n                arrPromoCreationThreads.findIndex(\n                    (a) => a.code === cThread.code\n                ),\n                1\n            );\n        }\n    }\n\n    // After the update completes, await another update in one second\n    if (!fPromoIntervalStarted || fRecursive) {\n        fPromoIntervalStarted = true;\n        setTimeout(() => updatePromoCreationTick(true), 1000);\n    }\n}\n\n/**\n * A sweep wrapper that handles the Promo UI after the sweep completes\n */\nexport async function sweepPromoCode() {\n    // Only allow clicking if there's a promo code loaded in memory\n    if (!cPromoWallet) return false;\n\n    // Convert the Promo Wallet in to a LegacyMasterkey\n    const cSweepMasterkey = new LegacyMasterKey({\n        pkBytes: cPromoWallet.pkBytes,\n    });\n\n    // Perform sweep\n    const strTXID = await sweepAddress(\n        await cPromoWallet.getUTXOs(true),\n        cSweepMasterkey,\n        PROMO_FEE\n    );\n\n    // Display the promo redeem results, then schedule a reset of the UI\n    if (strTXID) {\n        // Coins were redeemed!\n        const nAmt = ((await cPromoWallet.getBalance(true)) - PROMO_FEE) / COIN;\n        doms.domRedeemCodeETA.innerHTML =\n            '<br><br>You redeemed <b>' +\n            nAmt.toLocaleString('en-GB') +\n            ' ' +\n            cChainParams.current.TICKER +\n            '!</b>';\n        resetRedeemPromo(15);\n    } else {\n        // Most likely; this TX was claimed very recently and a mempool conflict occurred\n        doms.domRedeemCodeETA.innerHTML =\n            '<br><br>Oops, this code was valid, but someone may have claimed it seconds earlier!';\n        doms.domRedeemCodeGiftIcon.classList.remove('fa-gift');\n        doms.domRedeemCodeGiftIcon.classList.remove('fa-solid');\n        doms.domRedeemCodeGiftIcon.classList.add('fa-face-frown');\n        doms.domRedeemCodeGiftIcon.classList.add('fa-regular');\n        resetRedeemPromo(7.5);\n    }\n}\n\n/**\n * Resets the 'Redeem' promo code system back to it's default state\n * @param {number} nSeconds - The seconds to wait until the full reset\n */\nexport function resetRedeemPromo(nSeconds = 5) {\n    // Nuke the in-memory Promo Wallet\n    cPromoWallet = null;\n\n    // Reset Promo UI\n    doms.domRedeemCodeInput.value = '';\n    doms.domRedeemCodeGiftIcon.classList.remove('ptr');\n    doms.domRedeemCodeGiftIcon.classList.remove('fa-shake');\n\n    // After the specified seconds, reset the UI fully, and wipe the Promo Wallet\n    setTimeout(() => {\n        doms.domRedeemCodeETA.innerHTML = '';\n        doms.domRedeemCodeInputBox.style.display = '';\n        doms.domRedeemCodeGiftIconBox.style.display = 'none';\n        doms.domRedeemCodeGiftIcon.classList.add('fa-gift');\n        doms.domRedeemCodeGiftIcon.classList.add('fa-solid');\n        doms.domRedeemCodeGiftIcon.classList.remove('fa-face-frown');\n        doms.domRedeemCodeGiftIcon.classList.remove('fa-regular');\n        doms.domRedeemCodeConfirmBtn.style.display = '';\n    }, nSeconds * 1000);\n}\n\n/**\n * @type {Worker?} - The thread used for the PIVX Promos redeem process\n */\nexport let promoThread = null;\n\n/**\n * Derive a 'PIVX Promos' code with a webworker\n * @param {string} strCode - The Promo Code to derive\n */\nexport async function redeemPromoCode(strCode) {\n    // Ensure a Promo Code is not already being redeemed\n    if (promoThread) return;\n\n    // Create a new thread\n    promoThread = new Worker(new URL('./promos_worker.js', import.meta.url));\n\n    // Hide unnecessary UI components\n    doms.domRedeemCodeInputBox.style.display = 'none';\n    doms.domRedeemCodeConfirmBtn.style.display = 'none';\n\n    // Display Progress data and Redeem Animations\n    doms.domRedeemCodeETA.style.display = '';\n    doms.domRedeemCodeGiftIconBox.style.display = '';\n    doms.domRedeemCodeGiftIcon.classList.add('fa-bounce');\n\n    // Listen for and report derivation progress\n    promoThread.onmessage = async (evt) => {\n        if (evt.data.type === 'progress') {\n            doms.domRedeemCodeProgress.style.display = '';\n            doms.domRedeemCodeETA.innerHTML =\n                '<br><br>' +\n                evt.data.res.eta.toFixed(0) +\n                's remaining to unwrap...<br><br>' +\n                evt.data.res.progress +\n                '%';\n            doms.domRedeemCodeProgress.value = evt.data.res.progress;\n        } else {\n            // The finished key!\n            promoThread.terminate();\n            promoThread = null;\n\n            // Pause animations and finish 'unwrapping' by checking the derived Promo Key for a balance\n            doms.domRedeemCodeGiftIcon.classList.remove('fa-bounce');\n            doms.domRedeemCodeProgress.style.display = 'none';\n            doms.domRedeemCodeETA.innerHTML = '<br><br>Final checks...';\n\n            // Prepare the global Promo Wallet\n            cPromoWallet = new PromoWallet({\n                code: strCode,\n                address: '',\n                pkBytes: evt.data.res.bytes,\n                utxos: [],\n                time: 0,\n            });\n\n            // Derive the Public Key and synchronise UTXOs from the network\n            const nBalance = await cPromoWallet.getBalance();\n\n            // Display if the code is Valid (has coins) or is empty\n            if (nBalance > 0) {\n                doms.domRedeemCodeGiftIcon.classList.add('fa-shake');\n                doms.domRedeemCodeETA.innerHTML =\n                    '<br><br>This code is <b>verified!</b> Tap the gift to open it!';\n                doms.domRedeemCodeGiftIcon.classList.add('ptr');\n            } else {\n                doms.domRedeemCodeETA.innerHTML =\n                    '<br><br>This code had no balance!';\n                doms.domRedeemCodeGiftIcon.classList.remove('fa-gift');\n                doms.domRedeemCodeGiftIcon.classList.remove('fa-solid');\n                doms.domRedeemCodeGiftIcon.classList.add('fa-face-frown');\n                doms.domRedeemCodeGiftIcon.classList.add('fa-regular');\n                resetRedeemPromo();\n            }\n        }\n    };\n\n    // Send our 'Promo Code' to be derived on a separate thread, allowing a faster and non-blocking derivation\n    promoThread.postMessage(strCode);\n}\n\n/**\n * Prompt a QR scan for a PIVX Promos code\n */\nexport async function openPromoQRScanner() {\n    const cScan = await scanQRCode();\n\n    if (!cScan || !cScan.data) return;\n\n    // Enter the scanned code in to the redeem box\n    doms.domRedeemCodeInput.value = cScan.data;\n}\n","import { openDB, IDBPDatabase } from 'idb';\nimport Masternode from './masternode.js';\nimport { Settings } from './settings.js';\nimport { cChainParams } from './chain_params.js';\nimport {\n    confirmPopup,\n    sanitizeHTML,\n    createAlert,\n    isSameType,\n    isEmpty,\n} from './misc.js';\nimport { PromoWallet } from './promos.js';\nimport { ALERTS, translation } from './i18n.js';\nimport { Account } from './accounts.js';\n\n/** The current version of the DB - increasing this will prompt the Upgrade process for clients with an older version */\nexport const DB_VERSION = 2;\n\n/**\n *\n */\nexport class Database {\n    /**\n     * Current Database Version.\n     * Version 1 = Add index DB (PR #[FILL])\n     * @type{Number}\n     */\n    static version = 1;\n\n    /**\n     * @type{IDBPDatabase}\n     */\n    #db;\n\n    constructor({ db }) {\n        this.#db = db;\n    }\n\n    close() {\n        this.#db.close();\n        this.#db = null;\n    }\n\n    /**\n     * Add masternode to the database\n     * @param {Masternode} masternode\n     * @param {Masterkey} _masterKey - Masterkey associated to the masternode. Currently unused\n     */\n    async addMasternode(masternode, _masterKey) {\n        const store = this.#db\n            .transaction('masternodes', 'readwrite')\n            .objectStore('masternodes');\n        // For now the key is 'masternode' since we don't support multiple masternodes\n        await store.put(masternode, 'masternode');\n    }\n    /**\n     * Removes a masternode\n     * @param {Masterkey} _masterKey - Masterkey associated to the masternode. Currently unused\n     */\n    async removeMasternode(_masterKey) {\n        const store = this.#db\n            .transaction('masternodes', 'readwrite')\n            .objectStore('masternodes');\n        await store.delete('masternode');\n    }\n\n    /**\n     * Add Promo Code to the database for tracking and management\n     * @param {PromoWallet} promo\n     */\n    async addPromo(promo) {\n        const store = this.#db\n            .transaction('promos', 'readwrite')\n            .objectStore('promos');\n        // The plaintext code is our key, since codes are unique and deterministic anyway\n        await store.put(promo, promo.code);\n    }\n    /**\n     * Removes a Promo Code from the Promo management system\n     * @param {string} promo - the promo code to remove\n     */\n    async removePromo(promo) {\n        const store = this.#db\n            .transaction('promos', 'readwrite')\n            .objectStore('promos');\n        await store.delete(promo);\n    }\n\n    /**\n     * Adds an account to the database\n     *\n     * This will also apply missing Account keys from the Account class automatically, and check high-level type safety.\n     * @param {Account} account - The Account to add\n     */\n    async addAccount(account) {\n        // Critical: Ensure the input is an Account instance\n        if (!(account instanceof Account)) {\n            console.error(\n                '---- addAccount() called with invalid input, input dump below ----'\n            );\n            console.error(account);\n            console.error('---- end of account dump ----');\n            createAlert(\n                'warning',\n                '<b>Account Creation Error</b><br>Logs were dumped in your Browser Console<br>Please submit these privately to PIVX Labs Developers!'\n            );\n            return false;\n        }\n\n        // Create an empty DB Account\n        const cDBAccount = new Account();\n\n        // We'll overlay the `account` keys atop the `DB Account` keys:\n        // Note: Since the Account constructor defaults all properties to type-safe defaults, we can already assume `cDBAccount` is safe.\n        // Note: Since `addAccount` could be called with *anything*, we must apply the same type-safety on it's input.\n        for (const strKey of Object.keys(cDBAccount)) {\n            // Ensure the Type is correct for the Key against the Account class\n            if (!isSameType(account[strKey], cDBAccount[strKey])) {\n                console.error(\n                    'DB: addAccount() key \"' +\n                        strKey +\n                        '\" does NOT match the correct class type, likely data mismatch, please report!'\n                );\n                continue;\n            }\n\n            // Overlay the 'new' keys on top of the DB keys\n            cDBAccount[strKey] = account[strKey];\n        }\n\n        const store = this.#db\n            .transaction('accounts', 'readwrite')\n            .objectStore('accounts');\n\n        // Check this account isn't already added (by pubkey once multi-account)\n        if (await store.get('account'))\n            return console.error(\n                'DB: Ran addAccount() when account already exists!'\n            );\n\n        // When the account system is going to be added, the key is gonna be the publicKey\n        await store.put(cDBAccount, 'account');\n    }\n\n    /**\n     * Update specified keys for an Account in the DB.\n     *\n     * This will also apply new Account keys from MPW updates automatically, and check high-level type safety.\n     *\n     * ---\n     *\n     * To allow \"deleting/clearing/resetting\" keys, for example, when removing Proposals or Contacts, toggle `allowDeletion`.\n     *\n     * **Do NOT toggle unless otherwise necessary**, to avoid overwriting keys from code errors or misuse.\n     * @param {Account} account - The Account to update, with new data inside\n     * @param {boolean} allowDeletion - Allow setting keys to an \"empty\" state (`\"\"`, `[]`, `{}`)\n     */\n    async updateAccount(account, allowDeletion = false) {\n        // Critical: Ensure the input is an Account instance\n        if (!(account instanceof Account)) {\n            console.error(\n                '---- updateAccount() called with invalid input, input dump below ----'\n            );\n            console.error(account);\n            console.error('---- end of account dump ----');\n            createAlert(\n                'warning',\n                '<b>DB Update Error</b><br>Your wallet is safe, logs were dumped in your Browser Console<br>Please submit these privately to PIVX Labs Developers!'\n            );\n            return false;\n        }\n\n        // Fetch the DB account\n        const cDBAccount = await this.getAccount();\n\n        // If none exists; we should throw an error, as there's no reason for MPW to call `updateAccount` before an account was added using `addAccount`\n        // Note: This is mainly to force \"good standards\" in which we don't lazily use `updateAccount` to create NEW accounts.\n        if (!cDBAccount) {\n            console.error(\n                '---- updateAccount() called without an account existing, input dump below ----'\n            );\n            console.error(account);\n            console.error('---- end of input dump ----');\n            createAlert(\n                'warning',\n                '<b>DB Update Error</b><br>Logs were dumped in your Browser Console<br>Please submit these privately to PIVX Labs Developers!'\n            );\n            return false;\n        }\n\n        // We'll overlay the `account` keys atop the `DB Account` keys:\n        // Note: Since `getAccount` already checks type-safety, we can already assume `cDBAccount` is safe.\n        // Note: Since `updateAccount` could be called with *anything*, we must apply the same type-safety on it's input.\n        for (const strKey of Object.keys(cDBAccount)) {\n            // Ensure the Type is correct for the Key against the Account class\n            if (!isSameType(account[strKey], cDBAccount[strKey])) {\n                console.error(\n                    'DB: updateAccount() key \"' +\n                        strKey +\n                        '\" does NOT match the correct class type, likely data mismatch, please report!'\n                );\n                continue;\n            }\n\n            // Ensure the 'updated' key (which may not exist) is NOT a default or EMPTY value\n            // Note: this can be overriden manually when erasing data such as Contacts, Local Proposals, etc.\n            if (!allowDeletion && isEmpty(account[strKey])) continue;\n\n            // Overlay the 'new' keys on top of the DB keys\n            cDBAccount[strKey] = account[strKey];\n        }\n\n        const store = this.#db\n            .transaction('accounts', 'readwrite')\n            .objectStore('accounts');\n        // When the account system is going to be added, the key is gonna be the publicKey\n        await store.put(cDBAccount, 'account');\n    }\n\n    /**\n     * Removes an account from the database\n     * @param {Object} o\n     * @param {String} o.publicKey - Public key associated to the account.\n     */\n    async removeAccount({ publicKey }) {\n        const store = this.#db\n            .transaction('accounts', 'readwrite')\n            .objectStore('accounts');\n        // When the account system is going to be added, the key is gonna be the publicKey\n        await store.delete('account');\n    }\n\n    /**\n     * Gets an account from the database.\n     *\n     * This also will apply new keys from MPW updates automatically, and check high-level type safety.\n     * @returns {Promise<Account?>}\n     */\n    async getAccount() {\n        const store = this.#db\n            .transaction('accounts', 'readonly')\n            .objectStore('accounts');\n        const cDBAccount = await store.get('account');\n\n        // If there's no DB Account, we'll return null early\n        if (!cDBAccount) return null;\n\n        // We'll generate an Account Class for up-to-date keys, then layer the 'new' type-checked properties on it one-by-one\n        const cAccount = new Account();\n        for (const strKey of Object.keys(cAccount)) {\n            // If the key is missing: this is fine, `cAccount` will auto-fill it with the default blank Account Class type and value\n            if (!Object.prototype.hasOwnProperty.call(cDBAccount, strKey))\n                continue;\n\n            // Ensure the Type is correct for the Key against the Account class (with instanceof to also check Class validity)\n            if (!isSameType(cDBAccount[strKey], cAccount[strKey])) {\n                console.error(\n                    'DB: getAccount() key \"' +\n                        strKey +\n                        '\" does NOT match the correct class type, likely bad data saved, please report!'\n                );\n                continue;\n            }\n\n            // Overlay the 'DB' keys on top of the Class Instance keys\n            cAccount[strKey] = cDBAccount[strKey];\n        }\n\n        // Return the Account Class\n        return cAccount;\n    }\n\n    /**\n     * @returns {Promise<Masternode?>} the masternode stored in the db\n     */\n    async getMasternode(_masterKey) {\n        const store = this.#db\n            .transaction('masternodes', 'readonly')\n            .objectStore('masternodes');\n        return new Masternode(await store.get('masternode'));\n    }\n\n    /**\n     * @returns {Promise<Array<PromoWallet>>} all Promo Codes stored in the db\n     */\n    async getAllPromos() {\n        const store = this.#db\n            .transaction('promos', 'readonly')\n            .objectStore('promos');\n        // Convert all promo objects in to their Class and return them as a new array\n        return (await store.getAll()).map((promo) => new PromoWallet(promo));\n    }\n\n    /**\n     * @returns {Promise<Settings>}\n     */\n    async getSettings() {\n        const store = this.#db\n            .transaction('settings', 'readonly')\n            .objectStore('settings');\n        return new Settings(await store.get('settings'));\n    }\n\n    /**\n     * @param {Settings} settings - settings to use\n     * @returns {Promise<void>}\n     */\n    async setSettings(settings) {\n        const oldSettings = await this.getSettings();\n        const store = this.#db\n            .transaction('settings', 'readwrite')\n            .objectStore('settings');\n        await store.put(\n            {\n                ...oldSettings,\n                ...settings,\n            },\n            'settings'\n        );\n    }\n\n    /**\n     * Migrates from local storage\n     * @param {IDBPDatabase} db\n     */\n    async #migrateLocalStorage() {\n        if (localStorage.length === 0) return;\n        const settings = new Settings({\n            analytics: localStorage.analytics,\n            explorer: localStorage.explorer,\n            node: localStorage.node,\n            translation: localStorage.translation,\n            displayCurrency: localStorage.displayCurrency,\n        });\n        await this.setSettings(settings);\n\n        if (localStorage.masternode) {\n            try {\n                const masternode = JSON.parse(localStorage.masternode);\n                await this.addMasternode(masternode);\n            } catch (e) {\n                console.error(e);\n                createAlert('warning', ALERTS.MIGRATION_MASTERNODE_FAILURE);\n            }\n        }\n\n        if (localStorage.encwif || localStorage.publicKey) {\n            try {\n                const localProposals = JSON.parse(\n                    localStorage.localProposals || '[]'\n                );\n\n                // Update and format the old Account data\n                const cAccount = new Account({\n                    publicKey: localStorage.publicKey,\n                    encWif: localStorage.encwif,\n                    localProposals: localProposals,\n                });\n\n                // Migrate the old Account data to the new DB\n                await this.addAccount(cAccount);\n            } catch (e) {\n                console.error(e);\n                createAlert('warning', ALERTS.MIGRATION_ACCOUNT_FAILURE);\n                if (localStorage.encwif) {\n                    await confirmPopup({\n                        title: translation.MIGRATION_ACCOUNT_FAILURE_TITLE,\n                        html: `${\n                            translation.MIGRATION_ACCOUNT_FAILURE_HTML\n                        } <code id=\"exportPrivateKeyText\">${sanitizeHTML(\n                            localStorage.encwif\n                        )} </code>`,\n                    });\n                }\n            }\n        }\n    }\n\n    static async create(name) {\n        let migrate = false;\n        const database = new Database({ db: null });\n        const db = await openDB(`MPW-${name}`, DB_VERSION, {\n            upgrade: (db, oldVersion) => {\n                console.log(\n                    'DB: Upgrading from ' + oldVersion + ' to ' + DB_VERSION\n                );\n                if (oldVersion == 0) {\n                    db.createObjectStore('masternodes');\n                    db.createObjectStore('accounts');\n                    db.createObjectStore('settings');\n                    migrate = true;\n                }\n\n                // The introduction of PIVXPromos (safely added during <v2 upgrades)\n                if (oldVersion <= 1) {\n                    db.createObjectStore('promos');\n                }\n            },\n            blocking: () => {\n                // Another instance is waiting to upgrade, and we're preventing it\n                // Close the database and refresh the page\n                // (This would only happen if the user opened another window after MPW got an update)\n                database.close();\n                alert('New update received!');\n                window.location.reload();\n            },\n        });\n        database.#db = db;\n        if (migrate) {\n            database.#migrateLocalStorage();\n        }\n        return database;\n    }\n\n    /**\n     * Map name->instnace\n     * @type{Map<String, Database>}\n     */\n    static #instances = new Map();\n\n    /**\n     * @return {Promise<Database>} the default database instance\n     */\n    static async getInstance() {\n        const name = cChainParams.current.name;\n        const instance = this.#instances.get(name);\n        if (!instance || !instance.#db) {\n            this.#instances.set(name, await Database.create(name));\n        }\n\n        return this.#instances.get(name);\n    }\n}\n","import { sha256 } from '@noble/hashes/sha256';\nimport { hexToBytes, bytesToHex, dSHA256 } from './utils.js';\nimport * as nobleSecp256k1 from '@noble/secp256k1';\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { cChainParams, PRIVKEY_BYTE_LENGTH } from './chain_params.js';\nimport {\n    pubKeyHashNetworkLen,\n    writeToUint8,\n    getSafeRand,\n    pubPrebaseLen,\n} from './misc.js';\n\nimport bs58 from 'bs58';\n\n/**\n * Compress an uncompressed Public Key in byte form\n * @param {Array<Number> | Uint8Array} pubKeyBytes - The uncompressed public key bytes\n * @returns {Array<Number>} The compressed public key bytes\n */\nexport function compressPublicKey(pubKeyBytes) {\n    if (pubKeyBytes.length != 65)\n        throw new Error('Attempting to compress an invalid uncompressed key');\n    const x = pubKeyBytes.slice(1, 33);\n    const y = pubKeyBytes.slice(33);\n\n    // Compressed key is [key_parity + 2, x]\n    return [y[31] % 2 === 0 ? 2 : 3, ...x];\n}\n\n/**\n * Network encode 32 bytes for a private key\n * @param {Uint8Array} pkBytes - 32 Bytes\n * @returns {Uint8Array} - The network-encoded Private Key bytes\n */\nexport function encodePrivkeyBytes(pkBytes) {\n    const pkNetBytes = new Uint8Array(pkBytes.length + 2);\n    pkNetBytes[0] = cChainParams.current.SECRET_KEY; // Private key prefix (1 byte)\n    writeToUint8(pkNetBytes, pkBytes, 1); // Private key bytes             (32 bytes)\n    pkNetBytes[pkNetBytes.length - 1] = 1; // Leading digit                (1 byte)\n    return pkNetBytes;\n}\n\n/**\n * Generate a new private key OR encode an existing private key from raw bytes\n * @param {Uint8Array} pkBytesToEncode - Bytes to encode as a coin private key\n * @returns {PrivateKey} - The private key\n */\nexport function generateOrEncodePrivkey(pkBytesToEncode) {\n    // Private Key Generation\n    const pkBytes = pkBytesToEncode || getSafeRand();\n\n    // Network Encoding\n    const pkNetBytes = encodePrivkeyBytes(pkBytes);\n\n    // Double SHA-256 hash\n    const shaObj = dSHA256(pkNetBytes);\n\n    // WIF Checksum\n    const checksum = shaObj.slice(0, 4);\n    const keyWithChecksum = new Uint8Array(34 + checksum.length);\n    writeToUint8(keyWithChecksum, pkNetBytes, 0);\n    writeToUint8(keyWithChecksum, checksum, 34);\n\n    // Return both the raw bytes and the WIF format\n    return { pkBytes, strWIF: bs58.encode(keyWithChecksum) };\n}\n\n/**\n * Derive a Secp256k1 network-encoded public key (coin address) from raw private or public key bytes\n * @param {Object} options - The object to deconstruct\n * @param {String} [options.publicKey] - The hex encoded public key. Can be both compressed or uncompressed\n * @param {Array<Number> | Uint8Array} [options.pkBytes] - An array of bytes containing the private key\n * @param {\"ENCODED\" | \"UNCOMPRESSED_HEX\" | \"COMPRESSED_HEX\"} options.output - Output\n * @return {String} the public key with the specified encoding\n */\nexport function deriveAddress({ pkBytes, publicKey, output = 'ENCODED' }) {\n    if (!pkBytes && !publicKey) return null;\n    const compress = output !== 'UNCOMPRESSED_HEX';\n    // Public Key Derivation\n    let pubKeyBytes = publicKey\n        ? hexToBytes(publicKey)\n        : nobleSecp256k1.getPublicKey(pkBytes, compress);\n\n    if (output === 'UNCOMPRESSED_HEX') {\n        if (pubKeyBytes.length !== 65) {\n            // It's actually possible, but it's probably not something that we'll need\n            throw new Error(\"Can't uncompress an already compressed key\");\n        }\n        return bytesToHex(pubKeyBytes);\n    }\n\n    if (pubKeyBytes.length === 65) {\n        pubKeyBytes = compressPublicKey(pubKeyBytes);\n    }\n\n    if (pubKeyBytes.length != 33) {\n        throw new Error('Invalid public key');\n    }\n\n    if (output === 'COMPRESSED_HEX') {\n        return bytesToHex(pubKeyBytes);\n    }\n\n    // First pubkey SHA-256 hash\n    const pubKeyHashing = sha256(new Uint8Array(pubKeyBytes));\n\n    // RIPEMD160 hash\n    const pubKeyHashRipemd160 = ripemd160(pubKeyHashing);\n\n    // Network Encoding\n    const pubKeyHashNetwork = new Uint8Array(pubKeyHashNetworkLen);\n    pubKeyHashNetwork[0] = cChainParams.current.PUBKEY_ADDRESS;\n    writeToUint8(pubKeyHashNetwork, pubKeyHashRipemd160, 1);\n\n    // Double SHA-256 hash\n    const pubKeyHashingSF = dSHA256(pubKeyHashNetwork);\n\n    // Checksum\n    const checksumPubKey = pubKeyHashingSF.slice(0, 4);\n\n    // Public key pre-base58\n    const pubKeyPreBase = new Uint8Array(pubPrebaseLen);\n    writeToUint8(pubKeyPreBase, pubKeyHashNetwork, 0);\n    writeToUint8(pubKeyPreBase, checksumPubKey, pubKeyHashNetworkLen);\n\n    // Encode as Base58 human-readable network address\n    return bs58.encode(pubKeyPreBase);\n}\n\n// Verify the integrity of a WIF private key, optionally parsing and returning the key payload\nexport function verifyWIF(\n    strWIF = '',\n    fParseBytes = false,\n    skipVerification = false\n) {\n    // Convert from Base58\n    const bWIF = bs58.decode(strWIF);\n\n    if (!skipVerification) {\n        // Verify the byte length\n        if (bWIF.byteLength !== PRIVKEY_BYTE_LENGTH) {\n            throw Error(\n                'Private key length (' +\n                    bWIF.byteLength +\n                    ') is invalid, should be ' +\n                    PRIVKEY_BYTE_LENGTH +\n                    '!'\n            );\n        }\n\n        // Verify the network byte\n        if (bWIF[0] !== cChainParams.current.SECRET_KEY) {\n            // Find the network it's trying to use, if any\n            const cNetwork = Object.keys(cChainParams)\n                .filter((strNet) => strNet !== 'current')\n                .map((strNet) => cChainParams[strNet])\n                .find((cNet) => cNet.SECRET_KEY === bWIF[0]);\n            // Give a specific alert based on the byte properties\n            throw Error(\n                cNetwork\n                    ? 'This private key is for ' +\n                          (cNetwork.isTestnet ? 'Testnet' : 'Mainnet') +\n                          ', wrong network!'\n                    : 'This private key belongs to another coin, or is corrupted.'\n            );\n        }\n\n        // Perform SHA256d hash of the WIF bytes\n        const shaHash = dSHA256(bWIF.slice(0, 34));\n\n        // Verify checksum (comparison by String since JS hates comparing object-like primitives)\n        const bChecksumWIF = bWIF.slice(bWIF.byteLength - 4);\n        const bChecksum = shaHash.slice(0, 4);\n        if (bChecksumWIF.join('') !== bChecksum.join('')) {\n            throw Error(\n                'Private key checksum is invalid, key may be modified, mis-typed, or corrupt.'\n            );\n        }\n    }\n\n    return fParseBytes ? Uint8Array.from(bWIF.slice(1, 33)) : true;\n}\n\n// A convenient alias to verifyWIF that returns the raw byte payload\nexport function parseWIF(strWIF, skipVerification = false) {\n    return verifyWIF(strWIF, true, skipVerification);\n}\n","import { deriveAddress } from './encoding';\nimport { getSafeRand } from './misc.js';\n\nonmessage = function (_evt) {\n    while (true) {\n        const cKeypair = {};\n        cKeypair.priv = getSafeRand();\n\n        cKeypair.pub = deriveAddress({ pkBytes: cKeypair.priv });\n        postMessage(cKeypair);\n    }\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [621,421], () => (__webpack_require__(64714)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"./\" + chunkId + \".mpw.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = self.location + \"\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t479: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkMPW\"] = self[\"webpackChunkMPW\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["deferred","leafPrototypes","getProto","next","str","Buffer","bytes","toString","buff","Uint8Array","current","main","name","collateralInSats","isTestnet","TICKER","PUBKEY_PREFIX","STAKING_PREFIX","PUBKEY_ADDRESS","SECRET_KEY","BIP44_TYPE","BIP44_TYPE_LEDGER","PROTOCOL_VERSION","MASTERNODE_PORT","Explorers","url","Nodes","Consensus","UPGRADE_V6_0","undefined","budgetCycleBlocks","proposalFee","proposalFeeConfirmRequirement","maxPaymentCycles","maxPayment","testnet","eventEmitter","EventEmitter","constructor","id","path","sats","script","vin","vout","height","status","isDelegate","isReward","this","equalsUTXO","cUTXO","UTXOs","subscribeToNetwork","static","getUTXO","out","find","async","nBlocks","ms","Promise","res","_","setTimeout","removeUTXO","isAlreadyStored","some","getUTXOsByState","nState","filter","removeFromState","cNewUTXO","arrPendingUTXOs","addUTXO","newUTXO","updateUTXO","length","cStakeInput","txid","push","assert","utxo","PENDING","CONFIRMED","autoRemoveUTXO","REMOVED","removeWithDelay","error","autoRemoveUTXOs","arrUTXOs","getConfirmed","getStandardUTXOs","getDelegatedUTXOs","getBalance","cMasternode","collateralTxId","outidx","reduce","a","b","cachedBlockCount","getDelegatedBalance","on","utxos","getUTXOFullInfo","Map","enc","TextEncoder","TextDecoder","getPasswordKey","password","window","crypto","subtle","importKey","encode","deriveKey","passwordKey","salt","keyUsage","iterations","hash","accountData","publicKey","encWif","localProposals","contacts","getContactBy","pubkey","Error","label","getNameOrAddress","cAccount","address","nAccount","getMasterKey","wipePrivateData","isViewOnly","isHD","fIncludeNetwork","enabled","isLoaded","message","unlock","forEach","element","replaceAll","Object","keys","values","mk","setWallet","getAddress","nReceiving","nIndex","getDerivationPath","derivationPath","split","slice","join","getxpub","strPassword","strEncWIF","data","strPass","prompt","secretData","getRandomValues","iv","aesKey","encryptedContent","encrypt","encryptedContentArr","byteLength","set","btoa","String","fromCharCode","apply","buff_to_base64","e","log","encryptData","keyToBackup","getKeyToExport","database","getAccount","updateAccount","addAccount","removeEventListener","capture","last","lastWallet","isHardwareWallet","has","get","value","i","FALSE","PUSHDATA1","PUSHDATA2","PUSHDATA4","RESERVED","TRUE","NOP","VER","IF","NOTIF","VERIF","VERNOTIF","ELSE","ENDIF","VERIFY","RETURN","TOALTSTACK","FROMALTSTACK","IFDUP","DEPTH","DROP","DUP","NIP","OVER","PICK","ROLL","ROT","SWAP","TUCK","CAT","SUBSTR","LEFT","RIGHT","SIZE","INVERT","AND","OR","XOR","EQUAL","EQUALVERIFY","RESERVED1","RESERVED2","NEGATE","ABS","NOT","ADD","SUB","MUL","DIV","MOD","LSHIFT","RSHIFT","BOOLAND","BOOLOR","NUMEQUAL","NUMEQUALVERIFY","NUMNOTEQUAL","LESSTHAN","GREATERTHAN","LESSTHANOREQUAL","GREATERTHANOREQUAL","MIN","MAX","WITHIN","RIPEMD160","SHA1","SHA256","HASH160","HASH256","CODESEPARATOR","CHECKSIG","CHECKSIGVERIFY","CHECKMULTISIG","CHECKMULTISIGVERIFY","NOP1","NOP2","CHECKLOCKTIMEVERIFY","NOP3","NOP4","NOP5","NOP6","NOP7","NOP8","NOP9","NOP10","ZEROCOINMINT","ZEROCOINSPEND","ZEROCOINPUBLICSPEND","CHECKCOLDSTAKEVERIFY_LOF","CHECKCOLDSTAKEVERIFY","INVALIDOPCODE","freeze","MarketSource","cData","strName","strEndpoint","fetch","json","warn","txs","txCount","updating","isHistorySynced","rewardsText","ticker","explorerUrl","strUrl","txMap","icon","colour","content","update","fNewOnly","sync","cNet","arrTXs","arrTxHistory","syncTxHistoryChunk","props","rewards","arrStakes","type","nRewards","amount","parseTXs","newTxs","dateOptions","year","month","day","timeOptions","hour","minute","hour12","prevDateString","prevTimestamp","cDB","cTx","dateTime","Date","time","strDate","now","toLocaleTimeString","toLocaleDateString","fConfirmed","blockHeight","formattedAmt","Math","round","toFixed","fSendToSelf","strAddr","receivers","concat","senders","match","where","r","s","who","shieldedOutputs","arrExternalAddresses","all","map","addr","isOwnAddress","Set","substring","replace","date","confirmed","reset","getTxCount","Activity","title","mount","updateTicker","domGuiBalanceValueCurrency","innerText","domGuiStakingValueCurrency","domSendAmountValueCurrency","domSendAmountCoinsTicker","domStakeAmountValueCurrency","domStakeAmountCoinsTicker","domUnstakeAmountValueCurrency","domUnstakeAmountCoinsTicker","updatePriceDisplay","domValue","fCold","nPrice","nCurrencyValue","nValue","cLocale","nAmount","Intl","supportedValuesOf","includes","style","currency","currencyDisplay","maximumFractionDigits","minimumFractionDigits","optimiseCurrencyLocale","toLocaleString","updateGUI","nBalance","strBal","nDisplayDecimals","nLen","domGuiBalance","innerHTML","beautifyNumber","domAvailToDelegate","domGuiBalanceValue","domGuiBalanceStaking","domAvailToUndelegate","domGuiStakingValue","evt","preventDefault","returnValue","errorHandler","reason","alert","addEventListener","super","strCurrency","ensureCacheExists","market_data","current_price","cNode","Settings","analytics","explorer","node","autoswitch","coldAddress","translation","displayCurrency","displayDecimals","advancedMode","hit","time_to_sync","transaction","walletPrivateKeyPath","mnPrivateKey","getPrivateKey","strURL","cMasternodes","m","getFullData","ip","port","endsWith","onionBytes","c","charCodeAt","toUnsignedByteArray","Array","max","fill","_numToBytes","number","numBytes","littleEndian","reverse","blockHash","sigTime","idx","mnPublicKey","pkBytes","output","_decodeIpAddress","backend","bestBlockHash","toSign","getToSign","getWalletPublicKey","v","padding","walletPrivateKey","_getWalletPrivateKey","signature","der","recovered","getPingSignature","getPublicKey","getLastBlockHash","walletPublicKey","compress","sigBytes","getSignedMessage","sigPingBytes","getSignedPingMessage","broadcastMessageToHex","text","fAllowFinished","arrProposals","RemainingPaymentCount","voteCode","msg","proposalName","index","sessionVotes","findIndex","vHash","encodeURI","Vote","vote","storeVote","newVote","getSignedVoteMessage","nPayments","start","monthlyPayment","end","addressBytes","scriptBytes","ok","err","parseInt","_start","isSafeStr","test","strAddress","PromoWallet","code","fSynced","fLock","fCacheOnly","getUTXOs","fFull","arrSimpleUTXOs","db","close","masternode","_masterKey","store","objectStore","put","delete","promo","account","cDBAccount","strKey","isSameType","allowDeletion","prototype","hasOwnProperty","call","getAll","settings","oldSettings","getSettings","localStorage","setSettings","JSON","parse","addMasternode","encwif","html","resolvePromise","hideConfirm","purpleModal","textLeft","noPadding","maxHeight","modal","keyboard","domElement","focus","migrate","upgrade","oldVersion","createObjectStore","blocking","location","reload","instance","create","nSize","arr","pos","arrLen","strERR","timeout","domAlert","document","createElement","typeIcon","classList","add","opacity","zIndex","destroy","clearTimeout","timer","remove","strNumber","strDecFontSize","arrNumParts","strFontSize","getPrototypeOf","val","isArray","pubKeyBytes","x","compressPublicKey","pubKeyHashing","pubKeyHashRipemd160","ripemd160","pubKeyHashNetwork","checksumPubKey","pubKeyPreBase","pubKeyHashNetworkLen","strWIF","skipVerification","fParseBytes","bWIF","cNetwork","strNet","shaHash","bChecksumWIF","bChecksum","from","verifyWIF","onmessage","_evt","cKeypair","priv","pub","postMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","loaded","__webpack_modules__","__webpack_exports__","O","result","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","every","key","splice","n","getter","__esModule","d","obj","t","mode","then","ns","def","indexOf","getOwnPropertyNames","definition","o","defineProperty","enumerable","f","chunkId","promises","u","miniCssF","g","globalThis","Function","prop","Symbol","toStringTag","nmd","paths","children","scriptUrl","importScripts","currentScript","src","scripts","getElementsByTagName","p","self","installedChunks","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop"],"sourceRoot":""}