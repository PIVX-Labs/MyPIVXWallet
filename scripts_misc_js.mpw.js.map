{"version":3,"file":"./scripts_misc_js.mpw.js","mappings":";;;;;;;;;;;;;;;AAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,8EAA8E,iBAAiB;AAC/F;AACA;AACA;AACA,4CAA4C,KAAK;AACjD;AACA,wDAAwD,QAAQ;AAChE,iDAAiD,gBAAgB,WAAW;AAC5E,+BAA+B,aAAa;AAC5C;AACA,qFAAqF,gBAAgB;AACrG,6FAA6F,gBAAgB;AAC7G;AACA;AACA,kEAAkE,cAAc;AAChF,iEAAiE,SAAS,oBAAoB,cAAc;AAC5G;AACA;AACA;AACA;AACA;AACA,kEAAkE,aAAa;AAC/E,yDAAyD,KAAK;AAC9D,kEAAkE,MAAM;AACxE,6DAA6D,MAAM;AACnE;;AAEA;AACA,mCAAmC,QAAQ;AAC3C;AACA,+EAA+E,gBAAgB;AAC/F;AACA,wFAAwF;AACxF,6DAA6D,gBAAgB,sBAAsB,gBAAgB;AACnH,+BAA+B,gBAAgB,sCAAsC,gBAAgB;AACrG,iCAAiC,gBAAgB,UAAU,MAAM;;;AAGjE;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;AClLO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mFAAmF,iBAAiB;AACpG;AACA;AACA;AACA,6CAA6C,KAAK,mFAAmF,KAAK;AAC1I;AACA,4DAA4D,SAAS,iDAAiD;AACtH,iDAAiD,gBAAgB,WAAW;AAC5E;AACA;AACA,yFAAyF,gBAAgB;AACzG,iGAAiG,gBAAgB;AACjH;AACA;AACA,kEAAkE,cAAc,gEAAgE,cAAc;AAC9J,uEAAuE,SAAS,oBAAoB,cAAc,+DAA+D,SAAS,oBAAoB,cAAc;AAC5N;AACA;AACA;AACA;;AAEA,mEAAmE,aAAa,sDAAsD,aAAa;AACnJ,6DAA6D,KAAK,sDAAsD,KAAK;AAC7H,mEAAmE,MAAM,uDAAuD,MAAM;AACtI,iEAAiE,MAAM,gEAAgE,MAAM;AAC7I;;AAEA;AACA,mCAAmC,QAAQ,kEAAkE,QAAQ;AACrH;AACA,gFAAgF,gBAAgB,2GAA2G,gBAAgB;AAC3N;AACA,0FAA0F,8GAA8G;AACxM,gEAAgE,gBAAgB,qBAAqB,8BAA8B,gEAAgE,gBAAgB,sBAAsB,8BAA8B;AACvQ,+BAA+B,gBAAgB,yCAAyC,8BAA8B,iDAAiD,gBAAgB,sCAAsC,8BAA8B;AAC3P,iCAAiC,gBAAgB,UAAU,MAAM,oBAAoB,gBAAgB,UAAU,MAAM;;;AAGrH;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACjLA;;AAEA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,UAAU,8BAA8B;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,QAAQ,OAAO,gBAAgB,EAAE;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,MAAM;AACN,QAAQ,OAAO,gBAAgB,EAAE;AACjC;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACjGA;AACA;AACA;AACO;;AAEA;AACA;;AAEP;AACO;;AAEP;AACA;AACO;;AAEP;AACO;;AAEP;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sDAAsD;AACpE,cAAc,iDAAiD;AAC/D;AACA,kBAAkB,yDAAyD;AAC3E;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qDAAqD;AACnE;AACA,kBAAkB,yDAAyD;AAC3E;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtEuC;AACE;AAC2B;AAC7B;AAOlB;AAOC;AACmD;AACI;AACL;AACjC;;AAEM;;AAEtC;;AAEA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,+CAAS;AACb;AACA;;AAEA;AACA,IAAI,2DAAc;;AAElB;AACA,IAAI,gDAAmB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,OAAO;AACf;AACA;;AAEA;AACA,QAAQ,8DAAkB;AAC1B;AACA;AACA;;AAEA;;AAEA;AACA,YAAY,wDAAY,GAAG,mBAAmB;AAC9C,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,4DAAe;AACnB;AACA;AACA;AACA,QAAQ,qFAAuC;AAC/C,IAAI,mDAAa;AACjB;;AAEA;AACO,oBAAoB,gDAAO;AAClC;;AAEA;AACO;;AAEA;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;;AAEA;AACA;AACA;AACA,iCAAiC,kDAAI;AACrC,mDAAmD,kDAAI;AACvD;AACA;AACA;AACA;AACA,wBAAwB,kDAAI;AAC5B;AACA,YAAY,yEAA2B;;AAEvC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;;AAEA;AACA;AACA,oEAAoE,kDAAI;AACxE;AACA,kCAAkC,kDAAI;AACtC;AACA;AACA;AACA;AACA,wBAAwB,kDAAI;AAC5B;AACA,YAAY,yEAA2B;AACvC;;AAEA;AACA;;AAEO;AACP,yEAAyE,kDAAI;AAC7E;;AAEO;AACP,SAAS,0DAAiB;AAC1B,4GAA4G;AAC5G,wBAAwB,8DAAiB;AACzC;AACA;AACA;AACA,oBAAoB,uDACR;AACZ;AACA,0CAA0C;AAC1C,oBAAoB,uDAAa;AACjC,iBAAiB,gBAAgB;AACjC;AACA,uCAAuC,WAAW,gBAAgB;AAClE,oBAAoB,yEAA2B;AAC/C,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB,0DAAiB;AACtC;AACA;AACA;AACA;AACA,iEAAiE,UAAU,EAAE,yEAA2B,CAAC;AACzG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iKAA4B;AAClD;AACA;AACA,sBAAsB,8JAA2B;AACjD;AACA;AACA,sBAAsB,iKAA4B;AAClD;AACA,SAAS;AACT;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA,iCAAiC,oKAA6B;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,sDAAY;AAC3B,mBAAmB,+DAAyB;AAC5C,kBAAkB,oEAA8B;AAChD,SAAS;AACT;AACA;AACA,oCAAoC,sDAAU;AAC9C;AACA;AACA;AACA,gBAAgB,qDAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E;AACA;AACA,gBAAgB,qDAAW;AAC3B,cAAc;AACd;AACA,gBAAgB,qDAAW;AAC3B;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,gBAAgB,qDAAW;AAC3B;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,gBAAgB,OAAO;AACvB,gBAAgB,qDAAW;AAC3B;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,qDAAW;AACvB;AACA;AACA;;AAEO;AACP;AACA,YAAY,4DAAoB;AAChC,mBAAmB,qDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA,gCAAgC,sDAAU;AAC1C;AACA;AACA;AACA,YAAY,qDAAW;AACvB;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,qDAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,QAAQ,qDAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,GAAG,GAAG,kFAAoC,CAAC;AAChE,MAAM;AACN;AACA;;AAEA,SAAS,sDAAc;AACvB;AACA;AACA;AACA;AACA,0CAA0C,mFAAqC;AAC/E;;AAEA;AACA;AACA,oCAAoC,mFAAqC;AACzE;AACA,gBAAgB,qDAAW;AAC3B;AACA;AACA,yBAAyB,mFAAqC;AAC9D;AACA,4BAA4B,kDAAI;AAChC;AACA,wBAAwB,yEAA2B;AACnD;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,gBAAgB,qDAAW;AAC3B;AACA;AACA,wBAAwB,mFAAqC,GAAG,kDAAI;AACpE;AACA,wBAAwB,yEAA2B;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,gCAAgC,mFAAqC;AACrE,mBAAmB,qDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,sDAAU;AACtC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAkB;AAC1B;AACA;AACA;AACA;AACA;;AAEO;AACP,QAAQ,8DAAkB;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEO;AACP;;AAEA;AACA,QAAQ,4EAA8B,SAAS,wDAAY;;AAE3D;AACA,SAAS,8DAAkB,0BAA0B,wDAAY;;AAEjE;AACA;AACA;AACA,SAAS,8DAAkB;AAC3B,gCAAgC,oDAAO;AACvC;AACA,mBAAmB,qDAAW,YAAY,6DAAuB;AACjE,UAAU;AACV;AACA,mBAAmB,wDAAY;AAC/B;AACA,aAAa;AACb;AACA;AACA;AACA,6BAA6B,yDAAa;;AAE1C;AACA;AACA;;AAEO;AACP;AACA,QAAQ,4EAA8B;AACtC,eAAe,qDAAW;AAC1B;AACA,YAAY,wEAAkC;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,6DAAe;AACxC,eAAe,qDAAW;AAC1B;AACA,YAAY,+DAAyB;AACrC,eAAe,iBAAiB,6DAAe,EAAE;AACjD;AACA;AACA;AACA,eAAe,qDAAW;AAC1B;AACA,YAAY,kEAA4B;AACxC;AACA;AACA;AACA,IAAI,yDAAa;AACjB,IAAI,qDAAW,YAAY,iEAA2B;;AAEtD,IAAI,CAAC;;AAEL;AACA;;AAEO;AACP;AACA,YAAY,8DAAkB;AAC9B;AACA;AACA,UAAU;AACV,gBAAgB,4DAAoB;AACpC;AACA,cAAc;AACd,qDAAqD,6DAAqB;AAC1E;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEO;AACP,mCAAmC;AACnC,oCAAoC;AACpC,gDAAgD;AAChD;;AAEA;AACA,SAAS,yDAAmB;AAC5B;AACA;AACA,eAAe,qDAAW;AAC1B;AACA,YAAY,kEAA4B;AACxC,eAAe,YAAY;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,eAAe,qDAAW,UAAU,mEAA6B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,yDAAmB;AACpC,uBAAuB,qDAAW;AAClC;AACA,oBAAoB,kEAA4B;AAChD,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA,uBAAuB,qDAAW;AAClC;AACA,oBAAoB,kEAA4B;AAChD,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ,OAAO;AACf;AACA;AACA,mCAAmC,2GAAwC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAY;AAChC;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,iFAAmC;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA,MAAM;AACN;AACA;AACA;;AAEO;AACP,kBAAkB,8DAAkB;AACpC;AACA;AACA,iBAAiB,8DAAkB;AACnC;AACA;AACA;AACA,cAAc,sDAAY;AAC1B;AACA;AACA,SAAS;AACT;AACA,QAAQ,iEAAyB;AACjC;AACA,YAAY,8DAAkB;AAC9B;AACA;AACA;AACA;;AAEO;AACP;AACA,cAAc,sDAAY;AAC1B;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB,yDAAa;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,mEAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,sDAAY;AAC/D;AACA,UAAU,OAAO,sDAAY,gBAAgB;AAC7C;AACA,8BAA8B,sDAAY,0BAA0B;AACpE,YAAY,yEAA2B;AACvC,UAAU;AACV,gBAAgB,sDAAY;AAC5B;AACA,SAAS,2BAA2B,sDAAY,wBAAwB;AACxE,YAAY,yEAA2B;AACvC,UAAU;AACV;AACA,cAAc,aAAa;AAC3B;AACA;AACA;;AAEA,8BAA8B,sBAAsB;AACpD,iEAAiE,KAAK,MAAM;AAC5E,qDAAqD,KAAK,MAAM;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,iDAAS;AAClB;AACA;AACA,aAAa,8DAAkB;AAC/B;AACA;AACA;;AAEA,QAAQ,kEAA0B;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS,sDAAc;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mFAAqC;AAC/E;AACA;AACA;AACA;AACA,wCAAwC,sDAAU;AAClD;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU,mBAAmB,mFAAqC;AAClE;AACA;AACA;AACA,iBAAiB,mFAAqC,cAAc,kDAAI;AACxE;AACA,gBAAgB,yEAA2B;AAC3C;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,+BAA+B,mFAAqC;AACpE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC,4DAAoB;AAC7D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oCAAoC,sDAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,+CAAK,EAAE,OAAO;;AAEtB;AACA;AACA;AACA,2CAA2C,sDAAY;AACvD;AACA,UAAU;AACV,qCAAqC,sDAAY;AACjD,sCAAsC,sDAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,4DAAoB;AACjC,YAAY,qDAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qDAAW;AAC3B;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,gBAAgB,qDAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,YAAY,qDAAW;AACvB;AACA,iDAAiD,sDAAY;AAC7D;AACA,mBAAmB;AACnB;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,YAAY,qDAAW;AACvB;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,oBAAoB,qDAAW;AAC/B;;AAEA;AACA;AACA;;AAEO;AACP;AACA,SAAS,uDAAc;AACvB,eAAe,OAAO;AACtB;AACA;AACA,SAAS,iDAAS;;AAElB;AACA;AACA;;AAEA;AACA,IAAI,0DAAa;AACjB;AACA;;AAEA;AACO;AACP;AACA;AACA,SAAS,4EAA8B;AACvC,QAAQ,qDAAW,YAAY,+DAAyB;AACxD;AACA,8BAA8B,0EAAoC;AAClE;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnrC6D;AACE;;AAExD;AACA;;AAEP;AACA;AACO;AACP,QAAQ,qEAAc;AACtB,SAAS,uEAAe;AACxB;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,QAAQ,OAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,GAAG;AACpC,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA,0BAA0B,EAAE;AAC5B;AACO;AACP;AACA;AACA,cAAc,gCAAgC;AAC9C;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO;;AAEA;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC5IiD;AACA;AACgB;AACJ;AAC7B;AACmB;;AAEnD;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,IAAI;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,+DAAuB;AAC5C;;AAEA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA,0BAA0B,mDAAS,CAAC,0BAA0B,oBAAoB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,yBAAyB;AACzB;AACA,UAAU;AACV;AACA,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qDAAU;AAC3B;AACA;;AAEA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,OAAO;AACvB;AACA,8BAA8B,yBAAy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B,UAAU;AAC3B,YAAY,+CAAK;AACjB,YAAY,OAAO;AACnB,uCAAuC,UAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sDAAU;AAClB,QAAQ,6DAAiB;AACzB;;AAEA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,OAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gEAAgE;AAChE,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA,gCAAgC,4DAAgB;AAChD;AACA;;AAEA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,mBAAmB,yDAAgB;AACnC,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzU4C;AACT;AACG;AACd;AACsB;AACM;;AAEpD;AACO;AACA;AACA;;AAEP;AACO;AACP;AACO;;AAEP;AACA;AACO;AACP;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,yDAAe;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,IAAI,oEAA4B;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACO,8BAA8B,6BAA6B;AAClE;AACA,IAAI,gFAAwC;AAC5C,IAAI,2EAAmC;;AAEvC,+DAA+D;AAC/D,IAAI,qFAA6C;AACjD;AACA;AACA;AACA;AACA,IAAI,CAAC,oDAAoD,iBAAiB;;AAE1E;AACA,IAAI,6EAAqC;;AAEzC;AACA;AACA;AACA;AACA,YAAY,iFAAyC;AACrD;AACA;AACA,YAAY,gFAAwC;AACpD;AACA;AACA,SAAS;AACT;AACA;AACA,MAAM;AACN;AACA,QAAQ,CAAC;AACT;AACA;;AAEA;AACO;AACP;AACA,gBAAgB,uDAAM;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qDAAU;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,wBAAwB,yEAA8B;AACtD;AACA;;AAEA;AACA,mBAAmB,qDAAU;AAC7B;;AAEA;AACA,mBAAmB,qDAAU,YAAY,qDAAU;AACnD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW,kDAAW;AACtB;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;AC1MgC;AACK;;AAErC;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,kDAAW;AAC9B,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpB6E;AACR;AACK;AACF;AAChC;AACD;AAChC;AACA;AACA;;AAEP;AACO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,IAAI,sEAA8B;AAClC,IAAI,sEAA8B;AAClC;AACA;;AAEA;AACO;AACP;AACA;AACA;;AAEO;;AAEP;AACA;AACA,QAAQ,qDAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA,wBAAwB,uDAAa;AACrC;AACA;AACA;AACA;AACA,QAAQ,8EAAsC;AAC9C,QAAQ,qFAA6C;AACrD;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,eAAe;AAC1B,aAAa,eAAe;AAC5B;AACA;AACA;;AAEA;AACA,YAAY,+DAAuB,GAAG,kCAAkC;AACxE,YAAY,0DAAkB,GAAG,kCAAkC;AACnE;AACA;AACA;AACA,2BAA2B,uDAAa,CAAC,sBAAsB,WAAW;AAC1E;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,kEAA0B;AAC3C,sBAAsB,oFAAsC;AAC5D,sBAAsB,6EAA+B;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,uDAAe;AACvB;AACA;AACA,2CAA2C,kDAAI;AAC/C;AACA;AACA;AACA,4CAA4C,wDAAe,GAAG,0DAAiB;AAC/E;AACA;AACA,SAAS;AACT;AACA,IAAI,yDAAa;AACjB;AACA;AACA;AACA;AACA,sBAAsB,wDAAc;AACpC,SAAS;AACT;AACA;;AAEA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sDAAc;AAC1B,mCAAmC,6DAAiB,CAAC,kEAA0B;AAC/E;AACA;AACA;AACA,8BAA8B,yDAAiB;AAC/C,UAAU;AACV,8BAA8B,4DAAoB;AAClD;AACA;AACA;AACA;AACA,+BAA+B,uDAAa,CAAC,eAAe,UAAU;AACtE;AACA;AACA,MAAM;AACN,QAAQ,OAAO;AACf;AACA,MAAM;AACN;AACA;AACA;;AAEO;AACP;AACA;AACA,wBAAwB,uDAAa;AACrC;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY,OAAO;AACnB,gBAAgB,+DAAuB,KAAK,6DAAe;AAC3D,gBAAgB,kEAA0B;AAC1C,6CAA6C,4BAA4B;AACzE;AACA;AACA;AACA,gBAAgB,kEAA0B;AAC1C;AACA;AACA;AACA,YAAY,uEAA+B;AAC3C,YAAY,+DAAuB;AACnC,YAAY,iEAAyB;AACrC,YAAY,qDAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,OAAO;AACnB,YAAY,qDAAW;AACvB;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,cAAc;AACd,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA,YAAY,kEAA0B;AACtC,sCAAsC,4BAA4B,6BAA6B;AAC/F;AACA;AACA;AACA;AACA,MAAM;AACN,QAAQ,OAAO;AACf;AACA;AACA;;AAEO;AACP;AACA,uBAAuB;AACvB;;AAEO;AACP,2BAA2B,iDAAS;AACpC,IAAI,oFAA4C;AAChD,4BAA4B,oFAA4C;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sDAAc;AACtB,+BAA+B,6DAAiB,CAAC,kEAA0B;AAC3E;AACA;AACA;AACA,2BAA2B,yDAAiB;AAC5C;AACA;AACA;AACA,oBAAoB,uDAAa;AACjC,iBAAiB,eAAe,KAAK;AACrC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,8BAA8B,4DAAoB;AAClD;AACA;AACA;AACA,oBAAoB,uDAAa;AACjC,iBAAiB,kBAAkB,QAAQ;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,kDAAI;AACvE;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,YAAY,gFAAwC;;AAEpD;AACA;AACA,QAAQ,mEAAuB;AAC/B,MAAM;AACN;AACA,QAAQ,gFAAwC;;AAEhD;AACA;AACA;AACA;;AAEO;AACP,+BAA+B,uDAAa,CAAC,aAAa,OAAO;AA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AAEA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;;AAEO;AACP,kBAAkB,mBAAmB;AACrC;AACA;AACA,gCAAgC,2DAAoB;AACpD,iCAAiC,4DAAqB;AACtD,gCAAgC,4DAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,+BAA+B,WAAW,qDAAU,mBAAmB;AACvE;;AAEA;AACA;;AAEA,sBAAsB,4DAAqB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,SAAS,IAAI;AAC1C;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;;AAEP;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,oFAAsC;AAChD,UAAU,6EAA+B;AACzC;AACA,sBAAsB,YAAY;AAClC;AACA,oBA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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iEAAiE,gBAAgB;AACjF,yCAAyC,QAAQ;AACjD;;AAEO;AACP;AACA;AACA,EAAE,IAAI;AACN,iBAAiB,mDAAU;AAC3B;AACA,8BAA8B,6DAAe;AAC7C,2CAA2C,iBAAiB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sDAAY;AAC9C,mBAAmB,uEAAgC;AACnD;AACA,yDAAyD,QAAQ;AACjE,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,QAAQ,kDAAQ,oBAAoB,uDAAe;AACnD,QAAQ,sEAA8B,uDAAuD,QAAQ,+EAA+E,YAAY;AAChM,QAAQ,8EAAsC;AAC9C,QAAQ,+EAAuC;AAC/C,QAAQ,gFAAwC;AAChD;AACA;AACA;AACA;AACA;;AAEO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6EAAsB;AACpD,kCAAkC,6DAAM,GAAG,6BAA6B;AACxE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,qDAAW,SAAS,8DAAuB;AAC/D;AACA;AACA;AACA,SAAS;;AAET;AACA,mBAAmB,mDAAU;AAC7B;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,qDAAW,SAAS,gEAAyB;AACzD;AACA;;AAEA;AACA;AACA,YAAY,qDAAW;AACvB;AACA,gBAAgB,6EAAsC;AACtD;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+CAAK;AACvB;AACA;;AAEA;AACA;AACA,YAAY,qDAAW;AACvB;AACA,gBAAgB,kEAA2B;AAC3C;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA,YAAY,OAAO;AACnB;;AAEA;AACA,QAAQ,qDAAW;AACnB;AACA,YAAY,mEAA4B;AACxC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;ACp7BA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;;;;WCrCA;WACA;WACA;WACA;WACA,+BAA+B,wCAAwC;WACvE;WACA;WACA;WACA;WACA,iBAAiB,qBAAqB;WACtC;WACA;WACA,kBAAkB,qBAAqB;WACvC;WACA;WACA,KAAK;WACL;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WC3BA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,sDAAsD;WACtD,sCAAsC,iEAAiE;WACvG;WACA;WACA;WACA;WACA;WACA;;;;;WCzBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;;;;;WCRA;WACA;WACA;WACA;WACA;;;;;WCJA;WACA;WACA;WACA;WACA;;;;;WCJA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;WACA;WACA;WACA;WACA;;;;;WCJA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WCfA;;WAEA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,aAAa;WACb;WACA;WACA;WACA;;WAEA;WACA;WACA;;WAEA;;WAEA;;;;;WCpCA;WACA;WACA;WACA;;;;;UEHA;UACA","sources":["webpack://MPW/./locale/en/translation.js","webpack://MPW/./locale/uwu/translation.js","webpack://MPW/./scripts/aes-gcm.js","webpack://MPW/./scripts/chain_params.js","webpack://MPW/./scripts/global.js","webpack://MPW/./scripts/i18n.js","webpack://MPW/./scripts/masternode.js","webpack://MPW/./scripts/mempool.js","webpack://MPW/./scripts/misc.js","webpack://MPW/./scripts/native.js","webpack://MPW/./scripts/network.js","webpack://MPW/./scripts/settings.js","webpack://MPW/./scripts/utils.js","webpack://MPW/./scripts/vanitygen_worker.js","webpack://MPW/./scripts/wallet.js","webpack://MPW/ignored|/run/media/jskitty/media/projects/MyPIVXWallet/node_modules/@noble/secp256k1/lib/esm|crypto","webpack://MPW/ignored|/run/media/jskitty/media/projects/MyPIVXWallet/node_modules/asn1.js/node_modules/bn.js/lib|buffer","webpack://MPW/ignored|/run/media/jskitty/media/projects/MyPIVXWallet/node_modules/bn.js/lib|buffer","webpack://MPW/ignored|/run/media/jskitty/media/projects/MyPIVXWallet/node_modules/brorand|crypto","webpack://MPW/ignored|/run/media/jskitty/media/projects/MyPIVXWallet/node_modules/create-ecdh/node_modules/bn.js/lib|buffer","webpack://MPW/ignored|/run/media/jskitty/media/projects/MyPIVXWallet/node_modules/diffie-hellman/node_modules/bn.js/lib|buffer","webpack://MPW/ignored|/run/media/jskitty/media/projects/MyPIVXWallet/node_modules/elliptic/node_modules/bn.js/lib|buffer","webpack://MPW/ignored|/run/media/jskitty/media/projects/MyPIVXWallet/node_modules/miller-rabin/node_modules/bn.js/lib|buffer","webpack://MPW/ignored|/run/media/jskitty/media/projects/MyPIVXWallet/node_modules/public-encrypt/node_modules/bn.js/lib|buffer","webpack://MPW/ignored|/run/media/jskitty/media/projects/MyPIVXWallet/node_modules/readable-stream/lib/internal/streams|util","webpack://MPW/ignored|/run/media/jskitty/media/projects/MyPIVXWallet/node_modules/readable-stream/lib|util","webpack://MPW/ignored|/run/media/jskitty/media/projects/MyPIVXWallet/node_modules/tiny-secp256k1/node_modules/bn.js/lib|buffer","webpack://MPW/webpack/bootstrap","webpack://MPW/webpack/runtime/chunk loaded","webpack://MPW/webpack/runtime/compat get default export","webpack://MPW/webpack/runtime/create fake namespace object","webpack://MPW/webpack/runtime/define property getters","webpack://MPW/webpack/runtime/ensure chunk","webpack://MPW/webpack/runtime/get javascript chunk filename","webpack://MPW/webpack/runtime/get mini-css chunk filename","webpack://MPW/webpack/runtime/global","webpack://MPW/webpack/runtime/hasOwnProperty shorthand","webpack://MPW/webpack/runtime/make namespace object","webpack://MPW/webpack/runtime/node module decorator","webpack://MPW/webpack/runtime/publicPath","webpack://MPW/webpack/runtime/importScripts chunk loading","webpack://MPW/webpack/runtime/startup chunk dependencies","webpack://MPW/webpack/before-startup","webpack://MPW/webpack/startup","webpack://MPW/webpack/after-startup"],"sourcesContent":["export const en_translation = {\n    // This document is to be used as a template as all the base code is in English\n    // Basic HTML tags are allowed such as <b><i> etc. All data is sanitized https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML\n\n    // General words\n    enabled: \"enabled\",                    //\n    active: \"Active\",                     //\n    disabled: \"disabled\",                   //\n    on:\"On\",                          //\n    experimental:\"Experimental\",                //\n    amount:\"Amount\",                      //\n    staking:\"Staking\",                     //\n    rewards:\"rewards\",                     //\n    available:\"Available\",                   //\n\n    // Nav Bar\n    navIntro: \"Intro\",                   //\n    navDashboard: \"Dashboard\",               //\n    navSend: \"Send\",                    //\n    navStake: \"Stake\",                   //\n    navMasternode: \"Masternode\",              //\n    navGovernance:\"Governance\",               //\n    navSettings: \"Settings\",                //\n\n    navTestnet: \"<b>Testnet Mode On</b>\",                 //\n    navNetwork: \"<b>Network:</b>\",                 //\n    navDebug: \"Debug\",                   //\n    navExperimentalSync:\"<b>Experimental Sync Active</b>\",         //\n\n    // Footer\n    footerDonateLink: \"Donate!\",           //\n    footerBuiltWithPivxLabs: \"Built with 💜 by PIVX Labs\",    //\n    footerGithubLink: \"MyPIVXWallet\",           //\n\n    // Intro\n    title: \"Welcome to\",                      //\n    titleName: \"My PIVX Wallet!\",                  //\n\n    cardOneTitle: \"Be your own Bank!\",               //\n    cardOneDesc: \"MyPIVXWallet has <b>no custody</b> over your funds. You are in full ownership of your keys and your PIV. \",                //\n    cardOneLink: \"Know more\",                //\n\n    cardTwoTitle: \"Universal and Portable\",               //\n    cardTwoDesc: \"You can generate cryptographically-secure addresses with your browser and hardware.\",                // \n    cardTwoLink: \"Know more\",                //\n\n    cardThreeTitle: \"Don't trust, verify!\",             //\n    cardThreeDesc: \"MyPIVXWallet is completely open-source, available on the PIVX Labs github.\",              //\n    cardThreeLink: \"Know more\",              //\n\n    cardFourTitle: \"For the community\",              //\n    cardFourDesc: \"MyPIVXWallet is built with love without any fees, privacy intrusions or advertising. \",               //\n    cardFourLink: \"Know more\",               //\n\n    buttonDonate: \"Donate - Pay with MyPIVXWallet\",               //\n\n    // Dashboard\n    dashboardTitle: \"Dashboard\",             //\n    dCardOneTitle: \"Create a\",              //\n    dCardOneSubTitle: \"New Wallet\",           //\n    dCardOneDesc: \"This will create a new, random PIVX wallet that will contain no initial funds, you may transfer to-and-from this wallet with ease.\",               //\n    dCardOneButton: \"Create A New Wallet\",             //\n\n    dCardTwoTitle: \"Create a new\",              //\n    dCardTwoSubTitle: \"Vanity Wallet\",           //\n    dCardTwoDesc: \"This will create a PIVX wallet with a customized prefix of your choosing, requiring more processing power to generate such addresses, it is recommended to generate a prefix of less than 6 characters, for example: 'DAD' is a possible address prefix.\",               //\n    dCardTwoButton: \"Create A Vanity Wallet\",             //\n\n    dCardThreeTitle: \"Access your\",            //\n    dCardThreeSubTitle: \"Hardware Wallet\",         //\n    dCardThreeDesc: \"This will help managing the PIVX wallet on your ledger. Notice that the private key will remain safe in your hardware device\",             //\n    dCardThreeButton: \"Access my hardware wallet\",           //\n\n    dCardFourTitle: \"Go to\",             //\n    dCardFourSubTitle: \"My Wallet\",          //\n    dCardFourDesc: \"This will import a PIVX wallet that you hold via it's private key, loading the address and pulling your existing balance, if any, from an explorer node.\",              //\n    dCardFourSubDesc:\"*Note: MPW developers can NOT access your wallet, this wallet runs purely in YOUR browser using JavaScript.\",            //\n    dCardFourButtonI:\"Import Wallet\",            //\n    dCardFourButtonA:\"Access My Wallet\",            //\n\n    // Send\n    sendTitle: \"Create a\",                  //\n    sendSubTitle: \"Transaction\",               //\n    sendShieldingWarning: \"Please <b>AVOID</b> sending to Shielded addresses using this wallet - this functionality is currently unsupported.\",       //\n\n    sendSimpleTxTitle: \"Create Simple Transactions\",          //\n    sendSimpleTxAddress: \"Address\",        //\n    sendSimpleTxAll: \"(Send All)\",            //\n    sendSimpleTxDesc: \"Description (from the merchant)\",           //\n    sendSimpleTxButton:\"Send Transaction\",          //\n\n    sendManualTxTitle:\"Create Manual Transactions\",           //\n    sendManualTxInput:\"Inputs\",           //\n    sendManualTxTRXHash: \"Trx Hash\",        //\n    sendManualTxIndex:\"Index\",           //\n    sendManualTxScript:\"Script\",          //\n    sendManualTxOutputs:\"Outputs\",         //\n    sendManualTxOutputAddr:\"Output address 1\",      //\n    sendManualTxOutputAddrTwo:\"Output address 2\",   //\n    sendManualTxWIFKey:\"WIF key\",          //\n    sendManualTxWarning:\"<b>WARNING:</b> ANY FUNDS NOT ALLOCATED WILL BE USED AS FEES\",         //\n    sendManualTxButton:\"Create Raw Signed Transction\",          //\n    sendSignedRawTx:\"Signed Raw Transaction\",             //\n    sendSignedTutorial:\"Don't understand how this works? \",          //\n    sendSignedTutorialLink:\"Tutorial Here\",      //\n    sendSignedTutorialAdvInfo:\"Advanced Details: <br>locktime is set to 0, sequence is set to max. SIGHASH_ALL option is chosen for signing raw Transaction.\",   //\n\n    // Stake\n    stakeTitle:\"<b>New Feature!<b>\",                  //\n    stakeSubTitle:\"Please be aware MPW Cold Staking is a new, slightly experimental feature, it may be unstable, and is currently slow. Please have patience when using this feature, and wait for block confirmations before actions and balances are shown on-screen.\",               //\n    stakeUnstake:\"Unstake\",                //\n    stakeLoadMore:\"Load more\",               //\n\n    // Settings\n    settingsExplorer:\"Choose an explorer\",            //\n    settingsLanguage:\"Choose an Language:\",            //\n    settingsPivxNode:\"Choose a PIVX node:\",            //\n    settingsAnalytics:\"Choose your analytics contribution level:\",           //\n    settingsToggleDebug:\"Toggle Debug Mode\",         //\n    settingsToggleSync:\"Toggle Sync Mode\",          //\n    settingsToggleTestnet:\"Toggle Testnet Mode\",       //\n\n    // Transparency Report\n    transparencyReport: \"Transparency Report\",\n    hit:\"A ping indicating an app load, no unique data is sent.\",\n    time_to_sync:\"The time in seconds it took for MPW to last synchronise.\",\n    transaction:\"A ping indicating a Tx, no unique data is sent, but may be inferred from on-chain time.\",\n\n    // Alerts\n    ALERTS: \"<-- DO NOT EDIT! All below entries are for Alert Popups\",\n\n    FAILED_TO_IMPORT: '<b>Failed to import!</b> Invalid password',\n    TESTNET_ENCRYPTION_DISABLED: \"<b>Testnet Mode is ON!</b><br>Wallet encryption disabled\",\n    PASSWORD_TOO_SMALL: \"That password is a little short!<br>Use at least <b>{MIN_PASS_LENGTH} characters.</b>\",\n    PASSWORD_DOESNT_MATCH: 'Your passwords don\\'t match!',\n    NEW_PASSWORD_SUCCESS: '<b>You\\'re Secured! 🔐</b><br>Nice stuff, Armoured PIVian!',\n    INVALID_AMOUNT: '<b>Invalid amount!</b><br>',\n    UNSUPPORTED_CHARACTER: \"The character '{char}' is unsupported in addresses! (Not Base58 compatible)\",\n    UNSUPPORTED_WEBWORKERS: \"This browser doesn\\'t support Web Workers (multi-threaded JS), unfortunately you cannot generate Vanity wallets!\",\n    INVALID_ADDRESS: \"<b>Invalid PIVX address!</b><br> {address}\",\n    VALIDATE_AMOUNT_LOW: '<br>Minimum amount is {minimumAmount} {coinTicker}!',\n    VALIDATE_AMOUNT_DECIMAL: '{coinDecimal} decimal limit exceeded',\n    SUCCESS_STAKING_ADDR: '<b>Staking Address set!</b><br>Now go ahead and unstake!',\n    CONFIRM_UNSTAKE_H_WALLET:\"<b>Confirm your Unstake</b><br>Confirm the TX on your {strHardwareName}\",\n    CONFIRM_TRANSACTION_H_WALLET:\"<b>Confirm your transaction</b><br>Confirm the TX on your {strHardwareName}\",\n    SUCCESS_STAKING_ADDR_SET: '<b>Staking Address set!</b><br>Now go ahead and stake!',\n    STAKE_NOT_SEND: 'Here, use the <b>Stake</b> screen, not the Send screen!',\n    BAD_ADDR_LENGTH: '<b>Invalid PIVX address!<b><br>Bad length ({addressLength})',\n    BAD_ADDR_PREFIX: '<b>Invalid PIVX address!<b><br>Bad prefix {address} (Should start with {addressPrefix})',\n    SENT_NOTHING: 'You can\\'t send \\'nothing\\'!',\n    MORE_THEN_8_DECIMALS: '8 decimal limit exceeded',\n    SAVE_WALLET_PLEASE: \"<b>Save your wallet!</b><br>Dashboard ➜ Set Password\",\n    BACKUP_OR_ENCRYPT_WALLET: \"Please ENCRYPT and/or BACKUP your keys before leaving, or you may lose them!\",\n    \n    SWITCHED_EXPLORERS : \"<b>Switched explorer!</b><br>Now using {explorerName}\",\n    SWITCHED_NODE : \"<b>Switched node!</b><br>Now using {node}\",\n    SWITCHED_ANALYTICS: \"<b>Switched analytics level!</b><br>Now {level}\",\n    SWITCHED_SYNC: \"<b>Switched sync mode!</b><br>Now using {sync} sync\",\n    UNABLE_SWITCH_TESTNET: \"<b>Unable to switch Testnet Mode!</b><br>A wallet is already loaded\",\n\n    WALLET_OFFLINE_AUTOMATIC: \"<b>Offline Mode is active!</b><br>Please disable Offline Mode for automatic transactions\",\n    WALLET_UNLOCK_IMPORT: \"Please {unlock} your wallet before sending transactions!\",\n    WALLET_FIREFOX_UNSUPPORTED: \"<b>Firefox doesn't support this!</b><br>Unfortunately, Firefox does not support hardware wallets\",\n    WALLET_HARDWARE_WALLET:\"<b>Hardware wallet ready!</b><br>Please keep your {hardwareWallet} plugged in, unlocked, and in the PIVX app\",\n    WALLET_CONFIRM_L:\"Confirm the import on your Ledger\",\n    WALLET_NO_HARDWARE: \"<b>No device available</b><br>Couldn't find a hardware wallet; please plug it in and unlock!\",\n    WALLET_HARDWARE_CONNECTION_LOST: \"<b>Lost connection to {hardwareWallet} </b><br>It seems the {hardwareWallet} was unplugged mid-operation, oops!\",\n    WALLET_HARDWARE_BUSY: \"<b>{hardwareWallet} is waiting</b><br>Please unlock your {hardwareWallet} or finish it's current prompt\",\n    WALLET_HARDWARE_ERROR: \"<b> {hardwareWallet} </b><br> {error}\",\n\n\n    CONFIRM_POPUP_VOTE: \"Confirm Vote\",             \n    CONFIRM_POPUP_VOTE_HTML: \"Are you sure? It takes 60 minutes to change vote\",        \n    CONFIRM_POPUP_TRANSACTION: \"Confirm your transaction\",      \n    CONFIRM_POPUP_MN_P_KEY: \"Your Masternode Private Key\",         \n    CONFIRM_POPUP_MN_P_KEY_HTML: \"<br> Save this private key and copy it to your VPS config <br>\",  \n    CONFIRM_POPUP_VERIFY_ADDR: \"Verify your address\",      \n\n}\n","export const uwu_translation = {\n    // This document is to be used as a template as all the base code is in English\n    // Basic HTML tags are allowed such as <b><i> etc. All data is sanitized https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML\n\n    // General words\n    enabled: \"enabwed\",                    //enabled\n    active: \"\",                     //Active\n    disabled: \"disabwed\",                   //disabled\n    on:\"\",                          //On\n    experimental:\"Oh no! Dangewous!\",                //Experimental\n    amount:\"a<i>meow</i>nt\",                      //Amount\n    staking:\"\",                     //Staking\n    rewards:\"rewowods\",                     //rewards\n    available:\"avawable\",                   //Available\n\n    // Nav Bar\n    navIntro: \"Intwo\",                   //Intro\n    navDashboard: \"Dashbowed\",               //Dashboard\n    navSend: \"Send❣\",                    //Send\n    navStake: \"\",                   //Stake\n    navMasternode: \"\",              //Masternode\n    navGovernance:\"\",               //Governance\n    navSettings: \"\",                //Settings\n\n    navTestnet: \"Testnet Mowode On\",                 //<b>Testnet Mode On</b>\n    navNetwork: \"<b>Netwowork</b>\",                 //<b>Network:</b>\n    navDebug: \"Debuwug\",                   //Debug\n    navExperimentalSync:\"<b>Dangewous sync actiwated!</b>\",         //<b>Experimental Sync Active</b>\n\n    // Footer\n    footerDonateLink: \"Donate pwease owo!\",           //Donate!\n    footerBuiltWithPivxLabs: \"Built with wuv by PIVX Wabs❣\",    //Built with 💜 by PIVX Labs\n    footerGithubLink: \"\",           //MyPIVXWallet\n\n    // Intro\n    title: \"Wewcome to\",                      //Welcome to\n    titleName: \"My PIVX Wawwet!\",                  //My PIVX Wallet!\n\n    cardOneTitle: \"Be da bank!\",               //Be your own Bank!\n    cardOneDesc: \"MyPIVXWawwet has <b>nowo custody</b> over yowour funds. You are in full owonership of your keys and your PIV.\",                //MyPIVXWallet has <b>no custody</b> over your funds. You are in full ownership of your keys and your PIV. \n    cardOneLink: \"Knowo mowore\",                //Know more\n\n    cardTwoTitle: \"Univewsal and Portabwe\",               //Universal and Portable\n    cardTwoDesc: \"Yowou can genewate cwyptogwaphicawwy-secuwe adwesses with yowour bwowoser and hawdware.\",                //You can generate cryptographically-secure addresses with your browser and hardware. \n    cardTwoLink: \"Knowo mowore\",                //Know more\n\n    cardThreeTitle: \"Dun trust, vewify!\",             //Don't trust, verify!\n    cardThreeDesc: \"MYPIVXWawwet is compwetewy open-soworce, avawable on da PIVX Wabs Github.\",              //MyPIVXWallet is completely open-source, available on the PIVX Labs github.\n    cardThreeLink: \"Knowo mowore\",              //Know more\n\n    cardFourTitle: \"For da Commuwunity\",              //For the community\n    cardFourDesc: \"MyPIVXWawwet is built with wuv without any fees, pwiwacy intruwutions, or adwertizing.\",               //MyPIVXWallet is built with love without any fees, privacy intrusions or advertising. \n    cardFourLink: \"Knowo mowore\",               //Know more\n\n    buttonDonate: \"Dowonate! Pay with MyPIVXWawwet!\",               //Donate - Pay with MyPIVXWallet\n\n    // Dashboard\n    dashboardTitle: \"Dashbowod\",             //Dashboard\n    dCardOneTitle: \"Cweate a\",              //Create a\n    dCardOneSubTitle: \"New Wawwet!\",           //New Wallet\n    dCardOneDesc: \"Dis will cweate a new, wandom, PIVX wawwet dat will contain no initial funds, uwu. Yowou may twansfer to-and-fwom dis wawwet with ease! \",               //This will create a new, random PIVX wallet that will contain no initial funds, you may transfer to-and-from this wallet with ease.\n    dCardOneButton: \"Cweate A New Wawwet\",             //Create A New Wallet\n\n    dCardTwoTitle: \"Cweate a new\",              //Create a new\n    dCardTwoSubTitle: \"Vanity Wawwet\",           //Vanity Wallet\n    dCardTwoDesc: \"Dis will cweate a PIVX wawwet with a customizabwe pwefix of yowour choosing, requiweing mowore pwocessing power to genewate such addwesses, it is weccomended to genewate a pwefix of wess den six, fow example: 'DADDY' is a pawsibwe addwess pwefix.\",               //This will create a PIVX wallet with a customized prefix of your choosing, requiring more processing power to generate such addresses, it is recommended to generate a prefix of less than 6 characters, for example: \"DAD\" is a possible address prefix.\n    dCardTwoButton: \"Cweate A Vanity Wawwet\",             //Create A Vanity Wallet\n\n    dCardThreeTitle: \"Access yowour\",            //Access your\n    dCardThreeSubTitle: \"Hawdware Wawwet\",         //Hardware Wallet\n    dCardThreeDesc: \"Dis will help managing da PIVX wawwet on your wedger. Nowotice dat de pwivate key will wemaine safe in yowour hawdware device\",             //This will help managing the PIVX wallet on your ledger. Notice that the private key will remain safe in your hardware device\n    dCardThreeButton: \"Access my hawdware wawwet\",           //Access my hardware wallet\n\n    dCardFourTitle: \"Go to\",             //Go to\n    dCardFourSubTitle: \"My Wawwet\",          //My Wallet\n    dCardFourDesc: \"Dis will impowt a PIVX wawwet dat you howd via it's pwivate key, woading da adwess and puwwing your existing bawance, if any, fwom an expwowor node.\",              //This will import a PIVX wallet that you hold via it's private key, loading the address and pulling your existing balance, if any, from an explorer node.\n    dCardFourSubDesc:\"♡Nowote: MPW devewepers can NOT access yowour wawwet, dis wawwet wuns purewy in YOWOUR bwowser using JavaScwipt.\",            //*Note: MPW developers can NOT access your wallet, this wallet runs purely in YOUR browser using JavaScript.\n    dCardFourButtonI:\"Impowt Wawwet\",            //Import Wallet\n    dCardFourButtonA:\"Access My Wawwet\",            //Access My Wallet\n\n    // Send\n    sendTitle: \"Cweate a\",                  //Create a\n    sendSubTitle: \"Twansaction\",               //Transaction\n    sendShieldingWarning: \"Pwetty Pwease <b>AVOID</b> sending to Sheilded addwesses using dis wawwet, dis functionawity is cuwwentwy unsu<i>purr</i>ted.\",       //Please <b>AVOID</b> sending to Shielded addresses using this wallet - this functionality is currently unsupported.\n\n    sendSimpleTxTitle: \"Cweate Simple Twansactions\",          //Create Simple Transactions\n    sendSimpleTxAddress: \"Addwess\",        //Address\n    sendSimpleTxAll: \"(Send All♡)\",            //(Send All)\n    sendSimpleTxDesc: \"Deswiption (fwom da Mewrchant)\",           //Description (from the merchant)\n    sendSimpleTxButton:\"Send Twansaction\",          //Send Transaction\n\n    sendManualTxTitle:\"Cweate Manuwual Twansactions\",           //Create Manual Transactions\n    sendManualTxInput:\"\",           //Inputs\n    sendManualTxTRXHash: \"\",        //Trx Hash\n    sendManualTxIndex:\"\",           //Index\n    sendManualTxScript:\"Scwipt\",          //Script\n    sendManualTxOutputs:\"\",         //Outputs\n    sendManualTxOutputAddr:\"Output addwess 1\",      //Output address 1\n    sendManualTxOutputAddrTwo:\"Output addwess 2\",   //Output address 2\n    sendManualTxWIFKey:\"\",          //WIF key\n    sendManualTxWarning:\"<b>WARNING:</b> ANY FUNDS NOT AWWOCATED WILL BE USED AS FEES\",         //<b>WARNING:</b> ANY FUNDS NOT ALLOCATED WILL BE USED AS FEES\n    sendManualTxButton:\"Cweate Rawr Signed Twansaction\",          //Create Raw Signed Transction\n    sendSignedRawTx:\"Signed Rawr Twansaction\",             //Signed Raw Transaction\n    sendSignedTutorial:\"Don't undewstand how dis works?\",          //Don't understand how this works? \n    sendSignedTutorialLink:\"Tutowial hewe!\",      //Tutorial Here\n    sendSignedTutorialAdvInfo:\"Advanced Detaiws: <br>wocktime is set to zewo, sequence is set to max. SIGHASH_ALL option is chosen for signing rawr Twansaction.\",   //Advanced Details: <br>locktime is set to 0, sequence is set to max. SIGHASH_ALL option is chosen for signing raw Transaction.\n\n    // Stake\n    stakeTitle:\"New Feature!♡\",                  //<b>New Feature!<b>\n    stakeSubTitle:\"Pwease be aware MPW Cold staking is new, slightly expewimental, feature. It may be unstabwe, and is cuwwentwy slow. Pwease have patience when using dis feature, and wait for bwock confiwmations befowore actions and bawances are showown on-scween.\",               //Please be aware MPW Cold Staking is a new, slightly experimental feature, it may be unstable, and is currently slow. Please have patience when using this feature, and wait for block confirmations before actions and balances are shown on-screen.\n    stakeUnstake:\"\",                //Unstake\n    stakeLoadMore:\"Lowoad Mowore\",               //Load more\n\n    // Settings\n    settingsExplorer:\"Chowose an expwower\",            //Choose an explorer\n    settingsLanguage:\"Chowose a Languwuage!\",            //Choose an Language:\n    settingsAnalytics:\"Chowose your anawytics contwibution wevel:\",           //Choose your analytics contribution level:\n    settingsPivxNode:\"Chowose a PIVX nowode pwease:\",            //Choose a PIVX node:\n    settingsToggleDebug:\"Toggle Debug Mowode\",         //Toggle Debug Mode\n    settingsToggleSync:\"Toggle Sync Mowode\",          //Toggle Sync Mode\n    settingsToggleTestnet:\"Toggle Testnet Mowode\",       //Toggle Testnet Mode\n\n    // Transparency Report\n    transparencyReport: \"Twanspawency Repawt\",\n    hit:\"A ping indicating an app load, no unique data is sent.♡\",\n    time_to_sync:\"The time in seconds it took for MPW to last synchronise.♡\",\n    transaction:\"A ping indicating a Tx, no unique data is sent, but may be infewwed from on-chain time.♡\",\n    \n    // Alerts\n    ALERTS: \"<-- DO NOT EDIT! All below entries are for Alert Popups\",\n\n    FAILED_TO_IMPORT:\"<b>Faiwed to impawt!</b> Invawed password! Baka!\",             //'<b>Failed to import!</b> Invalid password',\n    TESTNET_ENCRYPTION_DISABLED:\"<b>Testnet Mowode in ON!</b><br>Wawwet encwyption disabwed\",  //\"<b>Testnet Mode is ON!</b><br>Wallet encryption disabled\",\n    PASSWORD_TOO_SMALL:\"Dat password is a wittle short!<br>Pwease use at least<b> {MIN_PASS_LENGTH} chawacters!</b>\",           //\"That password is a little short!<br>Use at least <b>\" + MIN_PASS_LENGTH + \" characters.</b>\",\n    PASSWORD_DOESNT_MATCH:\"Yowour passwords dun match!! baka!!\",        //'Your passwords don\\'t match!',\n    NEW_PASSWORD_SUCCESS:\"<b>Yowou\\'re Secuwed!</b><br>Good Job, PIVX Pogchamp!\",         //'<b>You\\'re Secured! 🔐</b><br>Nice stuff, Armoured PIVian!',\n    INVALID_AMOUNT:\"<b>Invawed a<i>meow</i>nt</b><br>\",               //'<b>Invalid amount!</b><br>',\n    UNSUPPORTED_CHARACTER:  \"The chawacter '{char}' is unsupurrted in addwesses! (Not Base58 compatible)\",        //\"The character '{char}' is unsupported in addresses! (Not Base58 compatible)\"\n    UNSUPPORTED_WEBWORKERS: \"Dis bwowser doesn't suppurrt web workers\",      //This browser doesn\\'t support Web Workers (multi-threaded JS), unfortunately you cannot generate Vanity wallets!\n    INVALID_ADDRESS: \"<b>Invawed PIVX addwess baka</b><br> {address} \",            //<b>Invalid PIVX address!<b><br> {address}\n    VALIDATE_AMOUNT_LOW:\"<br>Minimum ameownt is {minimumAmount} {coinTicker}!\",          //'<br>Minimum amount is ',\n    VALIDATE_AMOUNT_DECIMAL:\" decimal wimit exceeded. Yowouve gone too fawr!\",      //' decimal limit exceeded',\n    SUCCESS_STAKING_ADDR:\"<b>Staking Addwess set!</b><br>Now go ahead and unstake senpai❣\",         //'<b>Staking Address set!</b><br>Now go ahead and unstake!',\n    CONFIRM_UNSTAKE_H_WALLET:\"<b> Confirm yowour Unstake</b><br>Confirm da TX on yowour {strHardwareName}\",     //\"<b>Confirm your Unstake</b><br>Confirm the TX on your \",\n    CONFIRM_TRANSACTION_H_WALLET:\"<b>Confirm yowoure twansaction</b><br>Confirm da TX on yowour {strHardwareName}\", //\"<b>Confirm your transaction</b><br>Confirm the TX on your \",\n    SUCCESS_STAKING_ADDR_SET:\"<b>Staking Addwess set!~</b><br>Now go ahead and stake senpai❣\",     //'<b>Staking Address set!</b><br>Now go ahead and stake!',\n    STAKE_NOT_SEND:\"Here senpai❣ use da <b>Stake</b> scween, Not da send scween, baka!\",               //'Here, use the <b>Stake</b> screen, not the Send screen!',\n    BAD_ADDR_LENGTH:\"<b>Invawed PIVX addwess!</b><br>Bad wength ({addressLength})\",              //'<b>Invalid PIVX address!<b><br>Bad length ({addressLength})',\n    BAD_ADDR_PREFIX:\"<b>Invawed PIVX addwess! Baka!</b><br>Bad pwefix {address} (Should start with {addressPrefix})\",              //'<b>Invalid PIVX address!<b><br>Bad prefix {address} (Should start with {addressPrefix})',\n    SENT_NOTHING:\"You can\\'t send nothing!! Baka!\",                 //'You can\\'t send \\'nothing\\'!',\n    MORE_THEN_8_DECIMALS:\"8 decimal wimit exceeded. Too many nyumbers!!\",         //'8 decimal limit exceeded',\n    SAVE_WALLET_PLEASE:\"<b>Save yowour wawwet!</b><br>Dashbowed ➜ Set Password\",           // \"<b>Save your wallet!</b><br>Dashboard ➜ Set Password\",\n    BACKUP_OR_ENCRYPT_WALLET:\"Pwease ENCWYPT and/or BACKUP yowour keys befowe weaving, or you may lose dem! Oh noes!\",     // \"Please ENCRYPT and/or BACKUP your keys before leaving, or you may lose them!\"\n\n    SWITCHED_EXPLORERS : \"<b>Switched expwower!</b><br>Nowo using {explorerName}✿\",         //<b>Switched explorer!</b><br>Now using {explorerName},\n    SWITCHED_NODE : \"<b>Switched nowode!✿</b><br>Nowo using {node}\",              //<b>Switched node!</b><br>Now using {node},\n    SWITCHED_ANALYTICS: \"<b>Switched anawytics wevel!</b><br>Nowo {level}\",          //<b>Switched analytics level!</b><br>Now {level},\n    SWITCHED_SYNC: \"<b>Switched sync mowode!✿</b><br>Nowo using {sync} sync\",               //<b>Switched sync mode!</b><br>Now using {sync} sync,\n    UNABLE_SWITCH_TESTNET: \"<b>Unable to switch Testnet Mowode!</b><br>A wawwet is alweady woaded✿\",       //<b>Unable to switch Testnet Mode!</b><br>A wallet is already loaded\n\n    WALLET_OFFLINE_AUTOMATIC: \"<b>Offwine Mowode is active!</b><br>Pwease disabwe Offwine Mowode for automatic twansactions\",       //\"<b>Offline Mode is active!</b><br>Please disable Offline Mode for automatic transactions\",\n    WALLET_UNLOCK_IMPORT: \"Pwease {unlock} your wawwet befowore sending twansactions!\",           //\"Please {unlock} your wallet before sending transactions!\",\n    WALLET_FIREFOX_UNSUPPORTED: \"Oh noes!<b>Firefox senpai doesn't sup<i>purr</i>t this!</b><br>Unfortunatewy, Firefox senpai does not sup<i>purr</i>t hawdware wawwets\",     //\"<b>Firefox doesn't support this!</b><br>Unfortunately, Firefox does not support hardware wallets\",\n    WALLET_HARDWARE_WALLET: \"<b>Hawdware wawwet ready!</b><br>Pwease keep your {hardwareWallet} pwugged in, unwocked, and in da PIVX app ♥\",         //\"<b>Hardware wallet ready!</b><br>Please keep your {hardwareWallet} plugged in, unlocked, and in the PIVX app\",\n    WALLET_CONFIRM_L: \"Confiwm da impowot on your Wedger\",               //\"Confirm the import on your Ledger\",\n    WALLET_NO_HARDWARE: \"<b>No device avaiwable ☹</b><br>Couldn't find a hawdware wawwet; pwease pwug it in and unwock!\",             //\"<b>No device available</b><br>Couldn't find a hardware wallet; please plug it in and unlock!\",\n    WALLET_HARDWARE_CONNECTION_LOST: \"<b>Wost connection to da {hardwareWallet} </b><br>It seems da {hardwareWalletProductionName} was unpwugged mid-opewation, oops!!\",// \"<b>Lost connection to {hardwareWallet} </b><br>It seems the {hardwareWalletProductionName} was unplugged mid-operation, oops!\",\n    WALLET_HARDWARE_BUSY: \"<b>{hardwareWallet} is waiting!</b><br>Pwease unwock yowour {hardwareWalletProductionName} or finish it's cuwwent pwompt\",           //\"<b>{hardwareWallet} is waiting</b><br>Please unlock your {hardwareWalletProductionName} or finish it's current prompt\",\n    WALLET_HARDWARE_ERROR: \"<b> {hardwareWallet} </b><br> {error}\",          //\"<b> {hardwareWallet} </b><br> {error}\"\n\n\n    CONFIRM_POPUP_VOTE: \"Confiwm Vowote!\",             //Confirm Vote\n    CONFIRM_POPUP_VOTE_HTML: \"Are you suuure? It takes 60 minutes to change yowour vowote\",        //Are you sure? It takes 60 minutes to change vote\n    CONFIRM_POPUP_TRANSACTION: \"Confiwm yowour twansaction\",      //Confirm your transaction\n    CONFIRM_POPUP_MN_P_KEY: \"Yowour Masternode Pwivate Key\",         //Your Masternode Private Key\n    CONFIRM_POPUP_MN_P_KEY_HTML: \"<br> Save dis pwivate key and copy it to yowour VPS config <br>\",    // <br> Save this private key and copy it to your VPS config <br>\n    CONFIRM_POPUP_VERIFY_ADDR: \"Vewify yowour addwess\",      //Verify your address\n}\n","const buff_to_base64 = (buff) => btoa(String.fromCharCode.apply(null, buff));\n\nconst base64_to_buf = (b64) =>\n    Uint8Array.from(atob(b64), (c) => c.charCodeAt(null));\n\nconst enc = new TextEncoder();\nconst dec = new TextDecoder();\n\nexport async function encrypt(data, strPassword = '') {\n    const strPass =\n        strPassword ||\n        window.prompt('Please enter your wallet encryption password');\n    if (!strPass) return false;\n    return await encryptData(data, strPass);\n}\n\nexport async function decrypt(data, strPassword) {\n    const strPass =\n        strPassword ||\n        window.prompt('Please enter your wallet unlock password');\n    if (!strPass) return false;\n    return (await decryptData(data, strPass)) || 'decryption failed!';\n}\n\nconst getPasswordKey = (password) =>\n    window.crypto.subtle.importKey(\n        'raw',\n        enc.encode(password),\n        'PBKDF2',\n        false,\n        ['deriveKey']\n    );\n\nconst deriveKey = (passwordKey, salt, keyUsage) =>\n    window.crypto.subtle.deriveKey(\n        {\n            name: 'PBKDF2',\n            salt,\n            iterations: 250000,\n            hash: 'SHA-256',\n        },\n        passwordKey,\n        { name: 'AES-GCM', length: 256 },\n        false,\n        keyUsage\n    );\n\nasync function encryptData(secretData, password) {\n    try {\n        const salt = window.crypto.getRandomValues(new Uint8Array(16));\n        const iv = window.crypto.getRandomValues(new Uint8Array(12));\n        const passwordKey = await getPasswordKey(password);\n        const aesKey = await deriveKey(passwordKey, salt, ['encrypt']);\n        const encryptedContent = await window.crypto.subtle.encrypt(\n            {\n                name: 'AES-GCM',\n                iv: iv,\n            },\n            aesKey,\n            enc.encode(secretData)\n        );\n\n        const encryptedContentArr = new Uint8Array(encryptedContent);\n        let buff = new Uint8Array(\n            salt.byteLength + iv.byteLength + encryptedContentArr.byteLength\n        );\n        buff.set(salt, 0);\n        buff.set(iv, salt.byteLength);\n        buff.set(encryptedContentArr, salt.byteLength + iv.byteLength);\n        return buff_to_base64(buff);\n    } catch (e) {\n        console.log(`Error - ${e}`);\n        return '';\n    }\n}\n\nasync function decryptData(encryptedData, password) {\n    try {\n        const encryptedDataBuff = base64_to_buf(encryptedData);\n        const salt = encryptedDataBuff.slice(0, 16);\n        const iv = encryptedDataBuff.slice(16, 16 + 12);\n        const data = encryptedDataBuff.slice(16 + 12);\n        const passwordKey = await getPasswordKey(password);\n        const aesKey = await deriveKey(passwordKey, salt, ['decrypt']);\n        const decryptedContent = await window.crypto.subtle.decrypt(\n            {\n                name: 'AES-GCM',\n                iv: iv,\n            },\n            aesKey,\n            data\n        );\n        return dec.decode(decryptedContent);\n    } catch (e) {\n        console.log(`Error - ${e}`);\n        return '';\n    }\n}\n","// In most BTC-derived coins, the below parameters can be found in the 'src/chainparams.cpp' Mainnet configuration.\n// These below params share the same names as the CPP params, so finding and editing these is easy-peasy!\n// <[network_byte] [32_byte_payload] [0x01] [4_byte_checksum]>\nexport const PRIVKEY_BYTE_LENGTH = 38;\n\nexport const COIN_DECIMALS = 8;\nexport const COIN = 10 ** 8;\n\n/** The maximum gap (absence of transactions within a range of derived addresses) before an account search ends */\nexport const MAX_ACCOUNT_GAP = 20;\n\n/* Internal tweaking parameters */\n// A new encryption password must be 'at least' this long.\nexport const MIN_PASS_LENGTH = 6;\n\n// Cool stuff\nexport const donationAddress = 'DLabsktzGMnsK5K9uRTMCF6NoYNY6ET4Bb';\n\n/* chainparams */\nexport const cChainParams = {\n    current: null,\n    main: {\n        collateralInSats: 10000 * COIN,\n        isTestnet: false,\n        TICKER: 'PIV',\n        PUBKEY_PREFIX: ['D'],\n        STAKING_PREFIX: 'S',\n        PUBKEY_ADDRESS: 30,\n        SECRET_KEY: 212,\n        BIP44_TYPE: 119,\n        BIP44_TYPE_LEDGER: 77,\n        PROTOCOL_VERSION: 70926,\n        MASTERNODE_PORT: 51472,\n        // A list of Labs-trusted explorers\n        Explorers: [\n            // Display name      Blockbook-compatible API base\n            { name: 'rockdev', url: 'https://explorer.rockdev.org' },\n            { name: 'zkBitcoin', url: 'https://zkbitcoin.com' },\n        ],\n        Nodes: [{ name: 'duddino', url: 'https://rpc.duddino.com/mainnet' }],\n        Consensus: {\n            // Network upgrades\n            UPGRADE_V6_0: undefined,\n        },\n    },\n    testnet: {\n        collateralInSats: 10000 * COIN,\n        isTestnet: true,\n        TICKER: 'tPIV',\n        PUBKEY_PREFIX: ['x', 'y'],\n        STAKING_PREFIX: 'W',\n        PUBKEY_ADDRESS: 139,\n        SECRET_KEY: 239,\n        BIP44_TYPE: 1,\n        BIP44_TYPE_LEDGER: 1,\n        PROTOCOL_VERSION: 70926,\n        MASTERNODE_PORT: 51474,\n        // A list of Labs-trusted explorers\n        Explorers: [\n            // Display name      Blockbook-compatible API base\n            { name: 'rockdev', url: 'https://testnet.rockdev.org' },\n        ],\n        Nodes: [{ name: 'duddino', url: 'https://rpc.duddino.com/testnet' }],\n        Consensus: {\n            // Network upgrades\n            UPGRADE_V6_0: undefined,\n        },\n    },\n};\n// Set default chain\ncChainParams.current = cChainParams.main;\n","import { Mempool } from './mempool.js';\nimport Masternode from './masternode.js';\nimport { ALERTS, start as i18nStart, translation } from './i18n.js';\nimport * as jdenticon from 'jdenticon';\nimport {\n    masterKey,\n    hasEncryptedWallet,\n    importWallet,\n    encryptWallet,\n    decryptWallet,\n} from './wallet.js';\nimport {\n    submitAnalytics,\n    networkEnabled,\n    getBlockCount,\n    arrRewards,\n    getStakingRewards,\n} from './network.js';\nimport { start as settingsStart, cExplorer, debug } from './settings.js';\nimport { createAlert, confirmPopup, sanitizeHTML, MAP_B58 } from './misc.js';\nimport { cChainParams, COIN, MIN_PASS_LENGTH } from './chain_params.js';\nimport { decrypt } from './aes-gcm.js';\n\nimport { registerWorker } from './native.js';\n\nexport let doms = {};\n\nexport function start() {\n    doms = {\n        domStart: document.getElementById('start'),\n        domInstall: document.getElementById('installTab'),\n        domNavbarToggler: document.getElementById('navbarToggler'),\n        domGuiStaking: document.getElementById('guiStaking'),\n        domGuiWallet: document.getElementById('guiWallet'),\n        domGuiBalance: document.getElementById('guiBalance'),\n        domGuiBalanceTicker: document.getElementById('guiBalanceTicker'),\n        domGuiBalanceBox: document.getElementById('guiBalanceBox'),\n        domBalanceReload: document.getElementById('balanceReload'),\n        domBalanceReloadStaking: document.getElementById(\n            'balanceReloadStaking'\n        ),\n        domGuiBalanceStaking: document.getElementById('guiBalanceStaking'),\n        domGuiBalanceStakingTicker: document.getElementById(\n            'guiBalanceStakingTicker'\n        ),\n        domGuiStakingLoadMore: document.getElementById('stakingLoadMore'),\n        domGuiStakingLoadMoreIcon: document.getElementById(\n            'stakingLoadMoreIcon'\n        ),\n        domGuiBalanceBoxStaking: document.getElementById(\n            'guiBalanceBoxStaking'\n        ),\n        domGuiDelegateAmount: document.getElementById('delegateAmount'),\n        domGuiUndelegateAmount: document.getElementById('undelegateAmount'),\n        domTxTab: document.getElementById('txTab'),\n        domStakeTab: document.getElementById('stakeTab'),\n        domsendNotice: document.getElementById('sendNotice'),\n        domSimpleTXs: document.getElementById('simpleTransactions'),\n        domSimpleTXsDropdown: document.getElementById(\n            'simpleTransactionsDropdown'\n        ),\n        domAddress1s: document.getElementById('address1s'),\n        domValue1s: document.getElementById('value1s'),\n        domGuiViewKey: document.getElementById('guiViewKey'),\n        domModalQR: document.getElementById('ModalQR'),\n        domModalQrLabel: document.getElementById('ModalQRLabel'),\n        domPrefix: document.getElementById('prefix'),\n        domPrefixNetwork: document.getElementById('prefixNetwork'),\n        domWalletToggle: document.getElementById('wToggle'),\n        domGenerateWallet: document.getElementById('generateWallet'),\n        domGenVanityWallet: document.getElementById('generateVanityWallet'),\n        domGenHardwareWallet: document.getElementById('generateHardwareWallet'),\n        //GOVERNANCE ELEMENTS\n        domGovProposalsTable: document.getElementById('proposalsTable'),\n        domGovProposalsTableBody: document.getElementById('proposalsTableBody'),\n        //MASTERNODE ELEMENTS\n        domCreateMasternode: document.getElementById('createMasternode'),\n        domControlMasternode: document.getElementById('controlMasternode'),\n        domAccessMasternode: document.getElementById('accessMasternode'),\n        domMnAccessMasternodeText: document.getElementById(\n            'accessMasternodeText'\n        ),\n        domMnCreateType: document.getElementById('mnCreateType'),\n        domMnTextErrors: document.getElementById('mnTextErrors'),\n        domMnIP: document.getElementById('mnIP'),\n        domMnTxId: document.getElementById('mnTxId'),\n        domMnPrivateKey: document.getElementById('mnPrivateKey'),\n        domMnDashboard: document.getElementById('mnDashboard'),\n        domMnProtocol: document.getElementById('mnProtocol'),\n        domMnStatus: document.getElementById('mnStatus'),\n        domMnNetType: document.getElementById('mnNetType'),\n        domMnNetIP: document.getElementById('mnNetIP'),\n        domMnLastSeen: document.getElementById('mnLastSeen'),\n\n        domAccessWallet: document.getElementById('accessWallet'),\n        domImportWallet: document.getElementById('importWallet'),\n        domImportWalletText: document.getElementById('importWalletText'),\n        domAccessWalletBtn: document.getElementById('accessWalletBtn'),\n        domVanityUiButtonTxt: document.getElementById('vanButtonText'),\n        domGenKeyWarning: document.getElementById('genKeyWarning'),\n        domEncryptWarningTxt: document.getElementById('encryptWarningText'),\n        domEncryptBtnTxt: document.getElementById('encryptButton'),\n        domEncryptPasswordBox: document.getElementById('encryptPassword'),\n        domEncryptPasswordFirst: document.getElementById('newPassword'),\n        domEncryptPasswordSecond: document.getElementById('newPasswordRetype'),\n        domGuiAddress: document.getElementById('guiAddress'),\n        domGenIt: document.getElementById('genIt'),\n        domHumanReadable: document.getElementById('HumanReadable'),\n        domTxOutput: document.getElementById('transactionFinal'),\n        domReqDesc: document.getElementById('reqDesc'),\n        domReqDisplay: document.getElementById('reqDescDisplay'),\n        domIdenticon: document.getElementById('identicon'),\n        domPrivKey: document.getElementById('privateKey'),\n        domPrivKeyPassword: document.getElementById('privateKeyPassword'),\n        domAvailToDelegate: document.getElementById('availToDelegate'),\n        domAvailToUndelegate: document.getElementById('availToUndelegate'),\n        domAnalyticsDescriptor: document.getElementById('analyticsDescriptor'),\n        domStakingRewardsList: document.getElementById(\n            'staking-rewards-content'\n        ),\n        domStakingRewardsTitle: document.getElementById(\n            'staking-rewards-title'\n        ),\n        domMnemonicModalContent: document.getElementById(\n            'ModalMnemonicContent'\n        ),\n        domMnemonicModalButton: document.getElementById(\n            'modalMnemonicConfirmButton'\n        ),\n        domExportDiv: document.getElementById('exportKeyDiv'),\n        domExportPublicKey: document.getElementById('exportPublicKeyText'),\n        domExportPrivateKeyHold: document.getElementById('exportPrivateKey'),\n        domExportPrivateKey: document.getElementById('exportPrivateKeyText'),\n        domExportWallet: document.getElementById('guiExportWallet'),\n        domWipeWallet: document.getElementById('guiWipeWallet'),\n        domRestoreWallet: document.getElementById('guiRestoreWallet'),\n        domNewAddress: document.getElementById('guiNewAddress'),\n        domConfirmModalHeader: document.getElementById('confirmModalHeader'),\n        domConfirmModalTitle: document.getElementById('confirmModalTitle'),\n        domConfirmModalContent: document.getElementById('confirmModalContent'),\n        domConfirmModalButtons: document.getElementById('confirmModalButtons'),\n        domConfirmModalConfirmButton: document.getElementById(\n            'confirmModalConfirmButton'\n        ),\n        domConfirmModalCancelButton: document.getElementById(\n            'confirmModalCancelButton'\n        ),\n\n        masternodeLegacyAccessText:\n            'Access the masternode linked to this address<br> Note: the masternode MUST have been already created (however it can be online or offline)<br>  If you want to create a new masternode access with a HD wallet',\n        masternodeHDAccessText:\n            \"Access your masternodes if you have any! If you don't you can create one\",\n        // Aggregate menu screens and links for faster switching\n        arrDomScreens: document.getElementsByClassName('tabcontent'),\n        arrDomScreenLinks: document.getElementsByClassName('tablinks'),\n        // Alert DOM element\n        domAlertPos: document.getElementsByClassName('alertPositioning')[0],\n        domNetwork: document.getElementById('Network'),\n        domNetworkE: document.getElementById('NetworkE'),\n        domNetworkD: document.getElementById('NetworkD'),\n        domDebug: document.getElementById('Debug'),\n        domTestnet: document.getElementById('Testnet'),\n        domExplorerSelect: document.getElementById('explorer'),\n        domNodeSelect: document.getElementById('node'),\n        domTranslationSelect: document.getElementById('translation'),\n    };\n    i18nStart();\n    loadImages();\n    doms.domStart.click();\n\n    // Register native app service\n    registerWorker();\n\n    // Configure Identicon\n    jdenticon.configure();\n    // URL-Query request processing\n    const queryString = window.location.search;\n    const urlParams = new URLSearchParams(queryString);\n    let requestTo;\n    let requestAmount;\n    // Check for a payment request\n    if (urlParams.has('pay') && urlParams.has('amount')) {\n        requestTo = urlParams.get('pay');\n        requestAmount = parseFloat(urlParams.get('amount'));\n        console.log(requestTo + ' ' + requestAmount);\n        // We have our payment request info, wait until the page is fully loaded then display the payment request via .onload\n    }\n\n    // Customise the UI if a saved wallet exists\n    if (hasEncryptedWallet()) {\n        // Hide the 'Generate wallet' buttons\n        doms.domGenerateWallet.style.display = 'none';\n        doms.domGenVanityWallet.style.display = 'none';\n\n        const publicKey = localStorage.getItem('publicKey');\n\n        if (publicKey) {\n            importWallet({ newWif: publicKey });\n        } else {\n            // Display the password unlock upfront\n            accessOrImportWallet();\n        }\n    }\n\n    // Payment processor redirect\n    if (requestTo && requestAmount) {\n        guiPreparePayment(\n            requestTo,\n            requestAmount,\n            urlParams.has('desc') ? urlParams.get('desc') : ''\n        );\n    }\n\n    // If allowed by settings: submit a simple 'hit' (app load) to Labs Analytics\n    submitAnalytics('hit');\n    setInterval(refreshChainData, 15000);\n    doms.domPrefix.value = '';\n    doms.domPrefixNetwork.innerText =\n        cChainParams.current.PUBKEY_PREFIX.join(' or ');\n    settingsStart();\n}\n\n// WALLET STATE DATA\nexport const mempool = new Mempool();\nlet exportHidden = false;\n\n//                        PIVX Labs' Cold Pool\nexport let cachedColdStakeAddr = 'SdgQDpS8jDRJDX8yK8m9KnTMarsE84zdsy';\n\nexport function openTab(evt, tabName) {\n    // Hide all screens and deactivate link highlights\n    for (const domScreen of doms.arrDomScreens)\n        domScreen.style.display = 'none';\n    for (const domLink of doms.arrDomScreenLinks)\n        domLink.classList.remove('active');\n\n    // Show and activate the given screen\n    document.getElementById(tabName).style.display = 'block';\n    evt.currentTarget.classList.add('active');\n\n    // Close the navbar if it's not already closed\n    if (!doms.domNavbarToggler.className.includes('collapsed'))\n        doms.domNavbarToggler.click();\n\n    if (tabName === 'Governance') {\n        updateGovernanceTab();\n    }\n    if (tabName === 'Masternode') {\n        updateMasternodeTab();\n    }\n}\n\nexport function getBalance(updateGUI = false) {\n    const nBalance = mempool.getBalance();\n\n    // Update the GUI too, if chosen\n    if (updateGUI) {\n        // Set the balance, and adjust font-size for large balance strings\n        const nLen = (nBalance / COIN).toFixed(2).length;\n        doms.domGuiBalance.innerText = (nBalance / COIN).toFixed(\n            nLen >= 6 ? 0 : 2\n        );\n        doms.domAvailToDelegate.innerText =\n            'Available: ~' +\n            (nBalance / COIN).toFixed(2) +\n            ' ' +\n            cChainParams.current.TICKER;\n\n        // Add a notice to the Send page if balance is lacking\n        doms.domsendNotice.innerHTML = nBalance\n            ? ''\n            : '<div class=\"alert alert-danger\" role=\"alert\"><h4>Note:</h4><h5>You don\\'t have any funds, get some coins first!</h5></div>';\n    }\n\n    return nBalance;\n}\n\nexport function getStakingBalance(updateGUI = false) {\n    const nBalance = mempool.getDelegatedBalance();\n\n    if (updateGUI) {\n        // Set the balance, and adjust font-size for large balance strings\n        doms.domGuiBalanceStaking.innerText = Math.floor(nBalance / COIN);\n        doms.domGuiBalanceBoxStaking.style.fontSize =\n            Math.floor(nBalance / COIN).toString().length >= 4\n                ? 'large'\n                : 'x-large';\n        doms.domAvailToUndelegate.innerText =\n            'Staking: ~' +\n            (nBalance / COIN).toFixed(2) +\n            ' ' +\n            cChainParams.current.TICKER;\n    }\n\n    return nBalance;\n}\n\nexport function selectMaxBalance(domValueInput, fCold = false) {\n    domValueInput.value = (fCold ? getStakingBalance() : getBalance()) / COIN;\n}\n\nexport function updateStakingRewardsGUI(fCallback = false) {\n    if (!arrRewards.length) {\n        // This ensures we don't spam network requests, since if a network callback says we have no stakes; no point checking again!\n        if (!fCallback) getStakingRewards();\n        return;\n    }\n    //DOMS.DOM-optimised list generation\n    const strList = arrRewards\n        .map(\n            (cReward) =>\n                `<i style=\"opacity: 0.75; cursor: pointer\" onclick=\"window.open('${\n                    cExplorer.url + '/tx/' + cReward.id\n                }', '_blank')\">${new Date(\n                    cReward.time * 1000\n                ).toLocaleDateString()}</i> <b>+${cReward.amount} ${\n                    cChainParams.current.TICKER\n                }</b>`\n        )\n        .join('<br>');\n    // Calculate total\n    const nRewards = arrRewards.reduce(\n        (total, reward) => total + reward.amount,\n        0\n    );\n    // UpdateDOMS.DOM\n    doms.domStakingRewardsTitle.innerHTML = `Staking Rewards: ≥${nRewards} ${cChainParams.current.TICKER}`;\n    doms.domStakingRewardsList.innerHTML = strList;\n}\n\nasync function loadImages() {\n    // Promise.all is useless since we only need to load one image, but we might need to load more in the future\n    Promise.all([\n        (async () => {\n            document.getElementById('mpw-main-logo').src = (\n                await import('../assets/logo.png')\n            ).default;\n            document.getElementById('privateKeyImage').src = (\n                await import('../assets/key.png')\n            ).default;\n            document.getElementById('pivxLogoSend').src = (\n                await import('../assets/pivx.png')\n            ).default;\n        })(),\n    ]);\n}\n\nlet audio = null;\nexport async function playMusic() {\n    // On first play: load the audio into memory from the host\n    if (audio === null) {\n        // Dynamically load the file\n        audio = new Audio((await import('../assets/music.mp3')).default);\n    }\n\n    // Play or Pause\n    if (audio.paused || audio.ended) {\n        audio.play();\n        for (const domImg of document.getElementsByTagName('img'))\n            domImg.classList.add('discoFilter');\n    } else {\n        audio.pause();\n        for (const domImg of document.getElementsByTagName('img'))\n            domImg.classList.remove('discoFilter');\n    }\n}\n\nexport function unblurPrivKey() {\n    if (document.getElementById(\"exportPrivateKeyText\").classList.contains(\"blurred\")) {\n        document.getElementById(\"exportPrivateKeyText\").classList.remove(\"blurred\");\n    } else {\n        document.getElementById(\"exportPrivateKeyText\").classList.add(\"blurred\");\n    }\n}\n\nexport function toClipboard(source, caller) {\n    // Fetch the text/value source\n    const domCopy = document.getElementById(source) || source;\n\n    // Use an invisible textbox as the clipboard source\n    const domClipboard = document.getElementById('clipboard');\n    domClipboard.value = domCopy.value || domCopy.innerHTML || domCopy;\n    domClipboard.select();\n    domClipboard.setSelectionRange(0, 99999);\n\n    // Browser-dependent clipboard execution\n    if (!navigator.clipboard) {\n        document.execCommand('copy');\n    } else {\n        navigator.clipboard.writeText(domCopy.innerHTML || domCopy);\n    }\n\n    // Display a temporary checkmark response\n    caller.classList.add('fa-check');\n    caller.classList.remove('fa-clipboard');\n    caller.style.cursor = 'default';\n    setTimeout(() => {\n        caller.classList.add('fa-clipboard');\n        caller.classList.remove('fa-check');\n        caller.style.cursor = 'pointer';\n    }, 1000);\n}\n\nexport function guiPreparePayment(strTo = '', strAmount = 0, strDesc = '') {\n    doms.domTxTab.click();\n    if (doms.domSimpleTXs.style.display === 'none')\n        doms.domSimpleTXsDropdown.click();\n    // Apply values\n    doms.domAddress1s.value = strTo;\n    doms.domValue1s.value = strAmount;\n    doms.domReqDesc.value = strDesc;\n    doms.domReqDisplay.style.display = strDesc ? 'block' : 'none';\n    doms.domValue1s.focus();\n}\n\nexport function hideAllWalletOptions() {\n    // Hide and Reset the Vanity address input\n    doms.domPrefix.value = '';\n    doms.domPrefix.style.display = 'none';\n\n    // Hide all \"*Wallet\" buttons\n    doms.domGenerateWallet.style.display = 'none';\n    doms.domImportWallet.style.display = 'none';\n    doms.domGenVanityWallet.style.display = 'none';\n    doms.domAccessWallet.style.display = 'none';\n    doms.domGenHardwareWallet.style.display = 'none';\n}\n\nasync function govVote(hash, voteCode) {\n    if (\n        (await confirmPopup({\n            title: ALERTS.CONFIRM_POPUP_VOTE,\n            html: ALERTS.CONFIRM_POPUP_VOTE_HTML,\n        })) == true\n    ) {\n        if (localStorage.getItem('masternode')) {\n            const cMasternode = new Masternode(\n                JSON.parse(localStorage.getItem('masternode'))\n            );\n            if ((await cMasternode.getStatus()) !== 'ENABLED') {\n                createAlert(\n                    'warning',\n                    'Your masternode is not enabled yet!',\n                    6000\n                );\n                return;\n            }\n            const result = await cMasternode.vote(hash.toString(), voteCode); //1 yes 2 no\n            if (result.includes('Voted successfully')) {\n                //good vote\n                createAlert('success', 'Vote submitted!', 6000);\n            } else if (result.includes('Error voting :')) {\n                //If you already voted return an alert\n                createAlert(\n                    'warning',\n                    'You already voted for this proposal! Please wait 1 hour',\n                    6000\n                );\n            } else if (result.includes('Failure to verify signature.')) {\n                //wrong masternode private key\n                createAlert(\n                    'warning',\n                    \"Failed to verify signature, please check your masternode's private key\",\n                    6000\n                );\n            } else {\n                //this could be everything\n                console.error(result);\n                createAlert(\n                    'warning',\n                    'Internal error, please try again later',\n                    6000\n                );\n            }\n        } else {\n            createAlert('warning', 'Access a masternode before voting!', 6000);\n        }\n    }\n}\n\nexport async function startMasternode(fRestart = false) {\n    if (localStorage.getItem('masternode')) {\n        if (masterKey.isViewOnly) {\n            return createAlert(\n                'warning',\n                \"Can't start masternode in view only mode\",\n                6000\n            );\n        }\n        const cMasternode = new Masternode(\n            JSON.parse(localStorage.getItem('masternode'))\n        );\n        if (await cMasternode.start()) {\n            createAlert(\n                'success',\n                '<b>Masternode ' + (fRestart ? 're' : '') + 'started!</b>',\n                4000\n            );\n        } else {\n            createAlert(\n                'warning',\n                '<b>Failed to ' +\n                    (fRestart ? 're' : '') +\n                    'start masternode!</b>',\n                4000\n            );\n        }\n    }\n}\n\nexport function destroyMasternode() {\n    if (localStorage.getItem('masternode')) {\n        localStorage.removeItem('masternode');\n        createAlert(\n            'success',\n            '<b>Masternode destroyed!</b><br>Your coins are now spendable.',\n            5000\n        );\n        updateMasternodeTab();\n    }\n}\n\nexport async function importMasternode() {\n    const mnPrivKey = doms.domMnPrivateKey.value;\n\n    const ip = doms.domMnIP.value;\n    let address;\n    let collateralTxId;\n    let outidx;\n    let collateralPrivKeyPath;\n    doms.domMnIP.value = '';\n    doms.domMnPrivateKey.value = '';\n\n    if (!ip.includes(':')) {\n        address = `${ip}:${cChainParams.current.MASTERNODE_PORT}`;\n    } else {\n        address = ip;\n    }\n\n    if (!masterKey.isHD) {\n        // Find the first UTXO matching the expected collateral size\n        const cCollaUTXO = mempool\n            .getConfirmed()\n            .find(\n                (cUTXO) => cUTXO.sats === cChainParams.current.collateralInSats\n            );\n\n        // If there's no valid UTXO, exit with a contextual message\n        if (!cCollaUTXO) {\n            if (getBalance(false) < cChainParams.current.collateralInSats) {\n                // Not enough balance to create an MN UTXO\n                createAlert(\n                    'warning',\n                    'You need <b>' +\n                        (cChainParams.current.collateralInSats -\n                            getBalance(false)) /\n                            COIN +\n                        ' more ' +\n                        cChainParams.current.TICKER +\n                        '</b> to create a Masternode!',\n                    10000\n                );\n            } else {\n                // Balance is capable of a masternode, just needs to be created\n                // TODO: this UX flow is weird, is it even possible? perhaps we can re-design this entire function accordingly\n                createAlert(\n                    'warning',\n                    'You have enough balance for a Masternode, but no valid collateral UTXO of ' +\n                        cChainParams.current.collateralInSats / COIN +\n                        ' ' +\n                        cChainParams.current.TICKER,\n                    10000\n                );\n            }\n            return;\n        }\n\n        collateralTxId = cCollaUTXO.id;\n        outidx = cCollaUTXO.vout;\n        collateralPrivKeyPath = 'legacy';\n    } else {\n        const path = doms.domMnTxId.value;\n        const masterUtxo = mempool\n            .getConfirmed()\n            .findLast((u) => u.path === path); // first UTXO for each address in HD\n        // sanity check:\n        if (masterUtxo.sats !== cChainParams.current.collateralInSats) {\n            return createAlert(\n                'warning',\n                'This is not a suitable UTXO for a Masternode',\n                10000\n            );\n        }\n        collateralTxId = masterUtxo.id;\n        outidx = masterUtxo.vout;\n        collateralPrivKeyPath = path;\n    }\n    doms.domMnTxId.value = '';\n\n    const cMasternode = new Masternode({\n        walletPrivateKeyPath: collateralPrivKeyPath,\n        mnPrivateKey: mnPrivKey,\n        collateralTxId: collateralTxId,\n        outidx: outidx,\n        addr: address,\n    });\n    await refreshMasternodeData(cMasternode, true);\n    await updateMasternodeTab();\n}\n\nexport function accessOrImportWallet() {\n    // Hide and Reset the Vanity address input\n    doms.domPrefix.value = '';\n    doms.domPrefix.style.display = 'none';\n\n    // Show Import button, hide access button\n    doms.domImportWallet.style.display = 'block';\n    setTimeout(() => {\n        doms.domPrivKey.style.opacity = '1';\n    }, 100);\n    doms.domAccessWalletBtn.style.display = 'none';\n\n    // If we have a local wallet, display the decryption prompt\n    // This is no longer being used, as the user will be put in view-only\n    // mode when logging in, however if the user locked the wallet before\n    // #52 there would be no way to recover the public key without getting\n    // The password from the user\n    if (hasEncryptedWallet()) {\n        doms.domPrivKey.placeholder = 'Enter your wallet password';\n        doms.domImportWalletText.innerText = 'Unlock Wallet';\n        doms.domPrivKey.focus();\n    }\n}\n\nexport function onPrivateKeyChanged() {\n    if (hasEncryptedWallet()) return;\n    // Check whether the length of the string is 128 bytes (that's the length of ciphered plain texts)\n    // and it doesn't have any spaces (would be a mnemonic seed)\n    const fContainsSpaces = doms.domPrivKey.value.includes(' ');\n    doms.domPrivKeyPassword.hidden =\n        doms.domPrivKey.value.length !== 128 || fContainsSpaces;\n\n    // Uncloak the private input IF spaces are detected, to make Seed Phrases easier to input and verify\n    doms.domPrivKey.setAttribute('type', fContainsSpaces ? 'text' : 'password');\n}\n\nexport async function guiImportWallet() {\n    const fEncrypted = doms.domPrivKey.value.length === 128;\n\n    // If we are in testnet: prompt an import\n    if (cChainParams.current.isTestnet) return importWallet();\n\n    // If we don't have a DB wallet and the input is plain: prompt an import\n    if (!hasEncryptedWallet() && !fEncrypted) return importWallet();\n\n    // If we don't have a DB wallet and the input is ciphered:\n    const strPrivKey = doms.domPrivKey.value;\n    const strPassword = doms.domPrivKeyPassword.value;\n    if (!hasEncryptedWallet() && fEncrypted) {\n        const strDecWIF = await decrypt(strPrivKey, strPassword);\n        if (!strDecWIF || strDecWIF === 'decryption failed!') {\n            return createAlert('warning', ALERTS.FAILED_TO_IMPORT, [], 6000);\n        } else {\n            localStorage.setItem('encwif', strPrivKey);\n            return importWallet({\n                newWif: strDecWIF,\n            });\n        }\n    }\n    // Prompt for decryption of the existing wallet\n    const fHasWallet = await decryptWallet(doms.domPrivKey.value);\n\n    // If the wallet was successfully loaded, hide all options and load the dash!\n    if (fHasWallet) hideAllWalletOptions();\n}\n\nexport function guiEncryptWallet() {\n    // Disable wallet encryption in testnet mode\n    if (cChainParams.current.isTestnet)\n        return createAlert(\n            'warning',\n            ALERTS.TESTNET_ENCRYPTION_DISABLED,\n            [],\n            2500\n        );\n\n    // Fetch our inputs, ensure they're of decent entropy + match eachother\n    const strPass = doms.domEncryptPasswordFirst.value,\n        strPassRetype = doms.domEncryptPasswordSecond.value;\n    if (strPass.length < MIN_PASS_LENGTH)\n        return createAlert(\n            'warning',\n            ALERTS.PASSWORD_TOO_SMALL,\n            [{ MIN_PASS_LENGTH: MIN_PASS_LENGTH }],\n            4000\n        );\n    if (strPass !== strPassRetype)\n        return createAlert(\n            'warning',\n            ALERTS.PASSWORD_DOESNT_MATCH,\n            [],\n            2250\n        );\n    encryptWallet(strPass);\n    createAlert('success', ALERTS.NEW_PASSWORD_SUCCESS, [], 5500);\n\n    $('#encryptWalletModal').modal('hide');\n\n    doms.domWipeWallet.hidden = false;\n}\n\nexport async function toggleExportUI() {\n    if (!exportHidden) {\n        if (hasEncryptedWallet()) {\n            doms.domExportPrivateKey.innerHTML = localStorage.getItem('encwif');\n            exportHidden = true;\n        } else {\n            if (masterKey.isViewOnly) {\n                exportHidden = false;\n            } else {\n                doms.domExportPrivateKey.innerHTML = masterKey.keyToBackup;\n                exportHidden = true;\n            }\n        }\n    } else {\n        doms.domExportPrivateKey.innerHTML = '';\n        exportHidden = false;\n    }\n}\n\nexport function checkVanity() {\n    var e = event || window.event; // get event object\n    var key = e.keyCode || e.which; // get key cross-browser\n    var char = String.fromCharCode(key).trim(); // convert key to char\n    if (char.length == 0) return;\n\n    // Ensure the input is base58 compatible\n    if (!MAP_B58.toLowerCase().includes(char.toLowerCase())) {\n        if (e.preventDefault) e.preventDefault();\n        e.returnValue = false;\n        return createAlert(\n            'warning',\n            ALERTS.UNSUPPORTED_CHARACTER,\n            [{ char: char }],\n            3500\n        );\n    }\n}\n\nlet isVanityGenerating = false;\nconst arrWorkers = [];\nlet vanUiUpdater;\n\nfunction stopSearch() {\n    isVanityGenerating = false;\n    for (let thread of arrWorkers) {\n        thread.terminate();\n    }\n    while (arrWorkers.length) arrWorkers.pop();\n    doms.domPrefix.disabled = false;\n    doms.domVanityUiButtonTxt.innerText = 'Create A Vanity Wallet';\n    clearInterval(vanUiUpdater);\n}\n\nexport async function generateVanityWallet() {\n    if (isVanityGenerating) return stopSearch();\n    if (typeof Worker === 'undefined')\n        return createAlert('error', ALERTS.UNSUPPORTED_WEBWORKERS, [], 7500);\n    // Generate a vanity address with the given prefix\n    if (\n        doms.domPrefix.value.length === 0 ||\n        doms.domPrefix.style.display === 'none'\n    ) {\n        // No prefix, display the intro!\n        doms.domPrefix.style.display = 'block';\n        setTimeout(() => {\n            doms.domPrefix.style.opacity = '1';\n        },100);\n        doms.domGuiAddress.innerHTML = '~';\n        doms.domPrefix.focus();\n    } else {\n        // Remove spaces from prefix\n        doms.domPrefix.value = doms.domPrefix.value.replace(/ /g, '');\n\n        // Cache a lowercase equivilent for lower-entropy comparisons (a case-insensitive search is ALOT faster!) and strip accidental spaces\n        const nInsensitivePrefix = doms.domPrefix.value.toLowerCase();\n        const nPrefixLen = nInsensitivePrefix.length;\n\n        // Ensure the input is base58 compatible\n        for (const char of doms.domPrefix.value) {\n            if (!MAP_B58.toLowerCase().includes(char.toLowerCase()))\n                return createAlert(\n                    'warning',\n                    ALERTS.UNSUPPORTED_CHARACTER,\n                    [{ char: char }],\n                    3500\n                );\n            // We also don't want users to be mining addresses for years... so cap the letters to four until the generator is more optimized\n            if (doms.domPrefix.value.length > 5)\n                return createAlert(\n                    'warning',\n                    ALERTS.UNSUPPORTED_CHARACTER,\n                    [{ char: char }],\n                    3500\n                );\n        }\n        isVanityGenerating = true;\n        doms.domPrefix.disabled = true;\n        let attempts = 0;\n\n        // Setup workers\n        const nThreads = Math.max(\n            Math.floor(window.navigator.hardwareConcurrency * 0.75),\n            1\n        );\n        console.log('Spawning ' + nThreads + ' vanity search threads!');\n        while (arrWorkers.length < nThreads) {\n            arrWorkers.push(\n                new Worker(new URL('./vanitygen_worker.js', import.meta.url))\n            );\n            const checkResult = (data) => {\n                attempts++;\n                if (\n                    data.pub.substr(1, nPrefixLen).toLowerCase() ==\n                    nInsensitivePrefix\n                ) {\n                    importWallet({\n                        newWif: data.priv,\n                        fRaw: true,\n                    });\n                    stopSearch();\n                    doms.domGuiBalance.innerHTML = '0';\n                    doms.domGuiBalanceBox.style.fontSize = 'x-large';\n                    return console.log(\n                        'VANITY: Found an address after ' +\n                            attempts +\n                            ' attempts!'\n                    );\n                }\n            };\n\n            arrWorkers[arrWorkers.length - 1].onmessage = (event) =>\n                checkResult(event.data);\n            arrWorkers[arrWorkers.length - 1].postMessage(\n                cChainParams.current.PUBKEY_ADDRESS\n            );\n        }\n\n        // GUI Updater\n        doms.domVanityUiButtonTxt.innerText =\n            'Stop (Searched ' + attempts.toLocaleString('en-GB') + ' keys)';\n        vanUiUpdater = setInterval(() => {\n            doms.domVanityUiButtonTxt.innerText =\n                'Stop (Searched ' + attempts.toLocaleString('en-GB') + ' keys)';\n        }, 200);\n    }\n}\n\nexport function toggleDropDown(id) {\n    const domID = document.getElementById(id);\n    domID.style.display = domID.style.display === 'block' ? 'none' : 'block';\n}\n\nexport function askForCSAddr(force = false) {\n    if (force) cachedColdStakeAddr = null;\n    if (cachedColdStakeAddr === '' || cachedColdStakeAddr === null) {\n        cachedColdStakeAddr = prompt(\n            'Please provide a Cold Staking address (either from your own node, or a 3rd-party!)'\n        ).trim();\n        if (cachedColdStakeAddr) return true;\n    } else {\n        return true;\n    }\n    return false;\n}\n\nexport function isMasternodeUTXO(cUTXO, masternode = null) {\n    const cMasternode =\n        masternode || JSON.parse(localStorage.getItem('masternode'));\n    if (cMasternode) {\n        const { collateralTxId, outidx } = cMasternode;\n        return collateralTxId === cUTXO.id && cUTXO.vout === outidx;\n    } else {\n        return false;\n    }\n}\n\nexport async function wipePrivateData() {\n    const title = hasEncryptedWallet()\n        ? 'Do you want to lock your wallet?'\n        : 'Do you want to wipe your wallet private data?';\n    const html = hasEncryptedWallet()\n        ? 'You will need to enter your password to access your funds'\n        : \"You will lose access to your funds if you haven't backed up your private key or seed phrase\";\n    if (\n        await confirmPopup({\n            title,\n            html,\n        })\n    ) {\n        masterKey.wipePrivateData();\n        doms.domWipeWallet.hidden = true;\n        if (hasEncryptedWallet()) {\n            doms.domRestoreWallet.hidden = false;\n        }\n    }\n}\n\nexport async function restoreWallet() {\n    if (\n        await confirmPopup({\n            title: 'Unlock your wallet',\n            html: '<input type=\"password\" id=\"restoreWalletPassword\" placeholder=\"Wallet password\">',\n        })\n    ) {\n        const password = document.getElementById('restoreWalletPassword').value;\n        if (await decryptWallet(password)) {\n            doms.domRestoreWallet.hidden = true;\n            doms.domWipeWallet.hidden = false;\n        }\n    }\n}\n\nasync function updateGovernanceTab() {\n    const proposals = await Masternode.getProposals();\n    doms.domGovProposalsTableBody.innerHTML = '';\n    for (const proposal of proposals) {\n        if (proposal.RemainingPaymentCount === 0) {\n            continue;\n        }\n        const tr = doms.domGovProposalsTableBody.insertRow();\n        const td1 = tr.insertCell();\n        // IMPORTANT: We must sanite all of our HTML or a rogue server or malicious proposal could perform a cross side scripting attack\n        td1.innerHTML = `<a class=\"active\" href=\"${sanitizeHTML(\n            proposal.URL\n        )}\"><b>${sanitizeHTML(proposal.Name)}</b></a>`;\n        const td2 = tr.insertCell();\n        td2.innerHTML = `<b>${sanitizeHTML(proposal.MonthlyPayment)}</b> ${\n            cChainParams.current.TICKER\n        } <br>\n      <small> ${sanitizeHTML(\n          proposal['RemainingPaymentCount']\n      )} payments remaining of <b>${sanitizeHTML(proposal.TotalPayment)}</b> ${\n            cChainParams.current.TICKER\n        } total</small>`;\n        const td3 = tr.insertCell();\n        let { Yeas, Nays } = proposal;\n        Yeas = parseInt(Yeas);\n        Nays = parseInt(Nays);\n        const percentage = Yeas + Nays !== 0 ? (Yeas / (Yeas + Nays)) * 100 : 0;\n\n        td3.innerHTML = `<b>${percentage.toFixed(2)}%</b> <br>\n      <small> <b><div class=\"text-success\" style=\"display:inline;\"> ${Yeas} </div></b> /\n\t  <b><div class=\"text-danger\" style=\"display:inline;\"> ${Nays} </div></b>\n      `;\n        const td4 = tr.insertCell();\n        //append vote buttons\n        const buttonNo = document.createElement('button');\n        buttonNo.className = 'pivx-button-big';\n        buttonNo.innerText = 'No';\n        buttonNo.onclick = () => govVote(proposal.Hash, 2);\n\n        const buttonYes = document.createElement('button');\n        buttonYes.className = 'pivx-button-big';\n        buttonYes.innerText = 'Yes';\n        buttonYes.onclick = () => govVote(proposal.Hash, 1);\n\n        td4.appendChild(buttonNo);\n        td4.appendChild(buttonYes);\n    }\n}\n\nexport async function updateMasternodeTab() {\n    //TODO: IN A FUTURE ADD MULTI-MASTERNODE SUPPORT BY SAVING MNs with which you logged in the past.\n    // Ensure a wallet is loaded\n    doms.domMnTextErrors.innerHTML = '';\n    doms.domAccessMasternode.style.display = 'none';\n    doms.domCreateMasternode.style.display = 'none';\n    doms.domMnDashboard.style.display = 'none';\n\n    if (!masterKey) {\n        doms.domMnTextErrors.innerHTML =\n            'Please ' +\n            (hasEncryptedWallet() ? 'unlock' : 'import') +\n            ' your <b>COLLATERAL WALLET</b> first.';\n        return;\n    }\n\n    if (masterKey.isHardwareWallet) {\n        doms.domMnTxId.style.display = 'none';\n        doms.domMnTextErrors.innerHTML = 'Ledger is not yet supported';\n        return;\n    }\n\n    if (!mempool.getConfirmed().length) {\n        doms.domMnTextErrors.innerHTML =\n            'Your wallet is empty or still loading, re-open the tab in a few seconds!';\n        return;\n    }\n\n    let strMasternodeJSON = localStorage.getItem('masternode');\n    // If the collateral is missing (spent, or switched wallet) then remove the current MN\n    if (strMasternodeJSON) {\n        const cMasternode = JSON.parse(strMasternodeJSON);\n        if (\n            !mempool\n                .getConfirmed()\n                .find((utxo) => isMasternodeUTXO(utxo, cMasternode))\n        ) {\n            localStorage.removeItem('masternode');\n            strMasternodeJSON = null;\n        }\n    }\n\n    doms.domControlMasternode.style.display = strMasternodeJSON\n        ? 'block'\n        : 'none';\n\n    // first case: the wallet is not HD and it is not hardware, so in case the wallet has collateral the user can check its status and do simple stuff like voting\n    if (!masterKey.isHD) {\n        doms.domMnAccessMasternodeText.innerHTML =\n            doms.masternodeLegacyAccessText;\n        doms.domMnTxId.style.display = 'none';\n        // Find the first UTXO matching the expected collateral size\n        const cCollaUTXO = mempool\n            .getConfirmed()\n            .find(\n                (cUTXO) => cUTXO.sats === cChainParams.current.collateralInSats\n            );\n        const balance = getBalance(false);\n        if (cCollaUTXO) {\n            if (strMasternodeJSON) {\n                const cMasternode = new Masternode(\n                    JSON.parse(localStorage.getItem('masternode'))\n                );\n                await refreshMasternodeData(cMasternode);\n                doms.domMnDashboard.style.display = '';\n            } else {\n                doms.domMnTxId.style.display = 'none';\n                doms.domccessMasternode.style.display = 'block';\n            }\n        } else if (balance < cChainParams.current.collateralInSats) {\n            // The user needs more funds\n            doms.domMnTextErrors.innerHTML =\n                'You need <b>' +\n                (cChainParams.current.collateralInSats - balance) / COIN +\n                ' more ' +\n                cChainParams.current.TICKER +\n                '</b> to create a Masternode!';\n        } else {\n            // The user has the funds, but not an exact collateral, prompt for them to create one\n            doms.domCreateMasternode.style.display = 'block';\n            doms.domMnTxId.style.display = 'none';\n            doms.domMnTxId.innerHTML = '';\n        }\n    } else {\n        doms.domMnTxId.style.display = 'none';\n        doms.domMnTxId.innerHTML = '';\n        doms.domMnAccessMasternodeText.innerHTML = doms.masternodeHDAccessText;\n\n        // First UTXO for each address in HD\n        const mapCollateralAddresses = new Map();\n\n        // Aggregate all valid Masternode collaterals into a map of Address <--> Collateral\n        for (const cUTXO of mempool.getConfirmed()) {\n            if (cUTXO.sats !== cChainParams.current.collateralInSats) continue;\n            mapCollateralAddresses.set(cUTXO.path, cUTXO);\n        }\n        const fHasCollateral = mapCollateralAddresses.size > 0;\n\n        // If there's no loaded MN, but valid collaterals, display the configuration screen\n        if (!strMasternodeJSON && fHasCollateral) {\n            doms.domMnTxId.style.display = 'block';\n            doms.domAccessMasternode.style.display = 'block';\n\n            for (const [key] of mapCollateralAddresses) {\n                const option = document.createElement('option');\n                option.value = key;\n                option.innerText = await masterKey.getAddress(key);\n                doms.domMnTxId.appendChild(option);\n            }\n        }\n\n        // If there's no collateral found, display the creation UI\n        if (!fHasCollateral) doms.domCreateMasternode.style.display = 'block';\n\n        // If we have a collateral and a loaded Masternode, display the Dashboard\n        if (fHasCollateral && strMasternodeJSON) {\n            const cMasternode = new Masternode(JSON.parse(strMasternodeJSON));\n            // Refresh the display\n            refreshMasternodeData(cMasternode);\n            doms.domMnDashboard.style.display = '';\n        }\n    }\n}\n\nasync function refreshMasternodeData(cMasternode, fAlert = false) {\n    const cMasternodeData = await cMasternode.getFullData();\n    if (debug) console.log(cMasternodeData);\n\n    // If we have MN data available, update the dashboard\n    if (cMasternodeData && cMasternodeData.status !== 'MISSING') {\n        doms.domMnTextErrors.innerHTML = '';\n        doms.domMnProtocol.innerText = `(${sanitizeHTML(\n            cMasternodeData.version\n        )})`;\n        doms.domMnStatus.innerText = sanitizeHTML(cMasternodeData.status);\n        doms.domMnNetType.innerText = sanitizeHTML(\n            cMasternodeData.network.toUpperCase()\n        );\n        doms.domMnNetIP.innerText = cMasternode.addr;\n        doms.domMnLastSeen.innerText = new Date(\n            cMasternodeData.lastseen * 1000\n        ).toLocaleTimeString();\n    }\n\n    if (cMasternodeData.status === 'MISSING') {\n        doms.domMnTextErrors.innerHTML =\n            'Masternode is currently <b>OFFLINE</b>';\n        if (!masterKey.isViewOnly) {\n            createAlert(\n                'warning',\n                'Your masternode is offline, we will try to start it',\n                6000\n            );\n            // try to start the masternode\n            const started = await cMasternode.start();\n            if (started) {\n                doms.domMnTextErrors.innerHTML =\n                    'Masternode successfully started!';\n                createAlert(\n                    'success',\n                    'Masternode successfully started!, it will be soon online',\n                    6000\n                );\n                localStorage.setItem('masternode', JSON.stringify(cMasternode));\n            } else {\n                doms.domMnTextErrors.innerHTML =\n                    \"We couldn't start your masternode\";\n                createAlert(\n                    'warning',\n                    'We could not start your masternode',\n                    6000\n                );\n            }\n        }\n    } else if (\n        cMasternodeData.status === 'ENABLED' ||\n        cMasternodeData.status === 'PRE_ENABLED'\n    ) {\n        if (fAlert)\n            createAlert(\n                'success',\n                `Your masternode status is <b> ${sanitizeHTML(\n                    cMasternodeData.status\n                )} </b>`,\n                6000\n            );\n        localStorage.setItem('masternode', JSON.stringify(cMasternode));\n    } else if (cMasternodeData.status === 'REMOVED') {\n        doms.domMnTextErrors.innerHTML =\n            'Masternode is currently <b>REMOVED</b>';\n        if (fAlert)\n            createAlert(\n                'warning',\n                'Your masternode is in <b>REMOVED</b> state',\n                6000\n            );\n    } else {\n        // connection problem\n        doms.domMnTextErrors.innerHTML = 'Unable to connect!';\n        if (fAlert) createAlert('warning', 'Unable to connect!', 6000);\n    }\n\n    // Return the data in case the caller needs additional context\n    return cMasternodeData;\n}\n\nexport function refreshChainData() {\n    // If in offline mode: don't sync ANY data or connect to the internet\n    if (!networkEnabled)\n        return console.warn(\n            'Offline mode active: For your security, the wallet will avoid ALL internet requests.'\n        );\n    if (!masterKey) return;\n\n    // Play reload anim\n    doms.domBalanceReload.classList.add('playAnim');\n    doms.domBalanceReloadStaking.classList.add('playAnim');\n\n    // Fetch block count + UTXOs\n    getBlockCount();\n    getBalance(true);\n}\n\n// A safety mechanism enabled if the user attempts to leave without encrypting/saving their keys\nexport const beforeUnloadListener = (evt) => {\n    evt.preventDefault();\n    // Disable Save your wallet warning on unload\n    if (!cChainParams.current.isTestnet)\n        createAlert('warning', ALERTS.SAVE_WALLET_PLEASE, [], 10000);\n    // Most browsers ignore this nowadays, but still, keep it 'just incase'\n    return (evt.returnValue = translation.BACKUP_OR_ENCRYPT_WALLET);\n};\n","import { en_translation } from '../locale/en/translation.js';\nimport { uwu_translation } from '../locale/uwu/translation.js';\n\nexport const ALERTS = {};\nexport let translation = {};\n\n// TRANSLATION\n//Create an object of objects filled with all the translations\nexport const translatableLanguages = {\n    en: en_translation,\n    uwu: uwu_translation,\n};\n\n/**\n * Takes the language name and sets the translation settings based on the language file\n * @param {string} langName\n */\nexport function switchTranslation(langName) {\n    if (arrActiveLangs.includes(langName)) {\n        translation = translatableLanguages[langName];\n        translate(translation);\n        loadAlerts();\n        return true;\n    } else {\n        console.log(\n            'i18n: The language (' +\n                langName +\n                \") is not supported yet, if you'd like to contribute translations (for rewards!) contact us on GitHub or Discord!\"\n        );\n        translation = translatableLanguages.en_translation;\n        return false;\n    }\n}\n\n/**\n * Takes a string that includes {x} and replaces that based on what is in the array of objects\n * @param {string} message\n * @param {array<Object>} variables\n * @returns a string with the variables implemented in the string\n *\n * @example\n * //returns \"test this\"\n * translateAlerts(\"test {x}\" [x : \"this\"])\n */\nexport function translateAlerts(message, variables) {\n    variables.forEach((element) => {\n        message = message.replaceAll(\n            '{' + Object.keys(element)[0] + '}',\n            Object.values(element)[0]\n        );\n    });\n    return message;\n}\n\n/**\n * Translates all the static html based on the tag data-i18n\n * @param {Array} i18nLangs\n *\n */\nexport function translate(i18nLangs) {\n    if (!i18nLangs) return;\n\n    document.querySelectorAll('[data-i18n]').forEach(function (element) {\n        if (!i18nLangs[element.dataset.i18n]) return;\n\n        if (element.dataset.i18n_target) {\n            element[element.dataset.i18n_target] =\n                i18nLangs[element.dataset.i18n];\n        } else {\n            switch (element.tagName.toLowerCase()) {\n                case 'input':\n                case 'textarea':\n                    element.placeholder = i18nLangs[element.dataset.i18n];\n                    break;\n                default:\n                    element.innerHTML = i18nLangs[element.dataset.i18n];\n                    break;\n            }\n        }\n    });\n    loadAlerts();\n}\n\n/**\n * Translates the alerts by loading the data into the ALERTS object\n */\nexport function loadAlerts() {\n    // Alerts are designated by a special 'ALERTS' entry in each translation file\n    let fFoundAlerts = false;\n    for (const [alert_key, alert_translation] of Object.entries(translation)) {\n        if (fFoundAlerts) {\n            ALERTS[alert_key] = alert_translation;\n        }\n        // Skip all entries until we find the ALERTS flag\n        if (alert_key === 'ALERTS') fFoundAlerts = true;\n    }\n}\nfunction parseUserAgentLang(strUA, arrLangsWithSubset) {\n    if (arrLangsWithSubset.some((strLang) => strUA.includes(strLang))) {\n        // Split the lang in to 'primary' and 'subset', only use the primary lang\n        return strUA.substring(0, 2);\n    }\n    // Otherwise, just use the full language spec\n    return strUA;\n}\n\n// When adding a lang remember to add it to the object translatableLanguages as well as here.\nexport const arrActiveLangs = ['en', 'uwu'];\n\nexport function start() {\n    // We use this function to parse the UA lang in a safer way: for example, there's multiple `en` definitions\n    // ... but we shouldn't duplicate the language files, we can instead cut the affix (US, GB) and simply use 'en'.\n    // ... This logic may apply to other languages with such subsets as well, so take care of them here!\n    const arrLangsWithSubset = ['en'];\n\n    const strLang = parseUserAgentLang(\n        window.navigator.userLanguage || window.navigator.language,\n        arrLangsWithSubset\n    );\n\n    // When removing you do not have to remove from translatableLanguages\n    let localTranslation = localStorage.getItem('translation');\n    // Check if set in local storage\n    if (localTranslation != null) {\n        switchTranslation(localTranslation);\n    } else {\n        // Check if we support the user's browser locale\n        if (arrActiveLangs.includes(strLang)) {\n            switchTranslation(strLang);\n        } else {\n            // Default to EN if the locale isn't supported yet\n            console.log(\n                'i18n: Your language (' +\n                    strLang +\n                    \") is not supported yet, if you'd like to contribute translations (for rewards!) contact us on GitHub or Discord!\"\n            );\n            switchTranslation('en');\n        }\n    }\n    translate(translation);\n}\n","import { cNode, cExplorer } from './settings.js';\nimport { cChainParams } from './chain_params.js';\nimport { masterKey, parseWIF, deriveAddress } from './wallet.js';\nimport { dSHA256, bytesToHex, hexToBytes } from './utils.js';\nimport { Buffer } from 'buffer';\nimport * as nobleSecp256k1 from '@noble/secp256k1';\n\n/**\n * Construct a Masternode\n * @param {string} [masternode.walletPrivateKeyPath] - BIP39 path pointing to the private key holding the collateral. Optional if not HD\n * @param {string} masternode.mnPrivateKey - Masternode private key. Must be uncompressed WIF\n * @param {string} masternode.collateralTxId - Must be a UTXO pointing to the collateral\n * @param {number} masternode.outidx - The output id of the collateral starting from 0\n * @param {string} masternode.addr - IPV4 address in the form `ip:port`\n */\nexport default class Masternode {\n    constructor({\n        walletPrivateKeyPath,\n        mnPrivateKey,\n        collateralTxId,\n        outidx,\n        addr,\n    } = {}) {\n        this.walletPrivateKeyPath = walletPrivateKeyPath;\n        this.mnPrivateKey = mnPrivateKey;\n        this.collateralTxId = collateralTxId;\n        this.outidx = outidx;\n        this.addr = addr;\n    }\n\n    async _getWalletPrivateKey() {\n        return await masterKey.getPrivateKey(this.walletPrivateKeyPath);\n    }\n\n    /**\n       @return {Promise<Object>} The object containing masternode information for this masternode\n     */\n    async getFullData() {\n        const strURL = `${cNode.url}/listmasternodes?params=${this.collateralTxId}`;\n        try {\n            const cMasternodes = (await (await fetch(strURL)).json()).filter(\n                (m) => m.outidx === this.outidx\n            );\n            if (cMasternodes.length > 0) {\n                return cMasternodes[0];\n            } else {\n                return { status: 'MISSING' };\n            }\n        } catch (e) {\n            //this is the unfortunate state in which the node is not reachable\n            console.error(e);\n            return 'EXPLORER_DOWN';\n        }\n    }\n\n    /**\n       @return {Promise<string>} The status of this masternode.\n     */\n    async getStatus() {\n        const cMasternode = await this.getFullData();\n        return cMasternode ? cMasternode.status : 'MISSING';\n    }\n\n    static _decodeIpAddress(ip, port) {\n        // Only IPV4 for now\n        let start = '00000000000000000000ffff';\n        for (const digit of ip.split('.').map((n) => parseInt(n))) {\n            start += ('0' + digit.toString(16)).slice(-2);\n        }\n        start += bytesToHex(Masternode._numToBytes(port, 2, false));\n        return start;\n    }\n\n    static _numToBytes(number, numBytes = 8, littleEndian = true) {\n        const bytes = [];\n        for (let i = 0; i < numBytes; i++) {\n            bytes.push((number / 2 ** (8 * i)) & 0xff);\n        }\n        return littleEndian ? bytes : bytes.reverse();\n    }\n\n    /**\n     * @param {Object} message - message to encode\n     * @param {string} message.vin.txid - transaction id of the collateral\n     * @param {number} message.vin.idx - output id of the collateral starting from 0\n     * @param {string} message.blockHash - latest blockhash\n     * @param {number} message.sigTime - current time in seconds since UNIX epoch\n     * @return {Array} Returns the unsigned ping message. It needs to be signed with the MN private key\n     */\n    static getPingSignature({ vin, blockHash, sigTime }) {\n        const ping = [\n            ...hexToBytes(vin.txid).reverse(),\n            ...Masternode._numToBytes(vin.idx, 4, true),\n            // Should be tx sequence, but 0xffffff is fine\n            ...[0, 255, 255, 255, 255],\n            ...hexToBytes(blockHash).reverse(),\n            ...Masternode._numToBytes(sigTime, 8, true),\n        ];\n        return dSHA256(ping);\n    }\n\n    /**\n     * @param {Object} message - Message to encode\n     * @param {string} message.walletPrivateKey - private key of the collateral\n     * @param {string} message.addr - Masternode ipv4 with port\n     * @param {string} message.mnPrivateKey - private key of masternode\n     * @param {number} message.sigTime - current time in seconds since UNIX epoch\n     * @return {string} The message to be signed with the collateral private key.\n     * it needs to be padded with \"\\x18DarkNet Signed Message:\\n\" + Message length + Message\n     * Then hashed two times with SHA256\n     */\n    static getToSign({ walletPrivateKey, addr, mnPrivateKey, sigTime }) {\n        const [ip, port] = addr.split(':');\n        const publicKey = hexToBytes(\n            deriveAddress({\n                pkBytes: parseWIF(walletPrivateKey, true),\n                output: 'COMPRESSED_HEX',\n            })\n        );\n        const mnPublicKey = hexToBytes(\n            deriveAddress({\n                pkBytes: parseWIF(mnPrivateKey, true),\n                output: 'UNCOMPRESSED_HEX',\n            })\n        );\n\n        const pkt = [\n            ...Masternode._numToBytes(1, 4, true), // Message version\n            ...hexToBytes(Masternode._decodeIpAddress(ip, port)), // Encoded ip + port\n            ...Masternode._numToBytes(sigTime, 8, true),\n            ...Masternode._numToBytes(publicKey.length, 1, true), // Collateral public key length\n            ...publicKey,\n            ...Masternode._numToBytes(mnPublicKey.length, 1, true), // Masternode public key length\n            ...mnPublicKey,\n            ...Masternode._numToBytes(\n                cChainParams.current.PROTOCOL_VERSION,\n                4,\n                true\n            ), // Protocol version\n        ];\n        return bytesToHex(dSHA256(pkt).reverse());\n    }\n\n    /**\n     * @return {Promise<string>} The last block hash\n     */\n    static async getLastBlockHash() {\n        const status = await (await fetch(`${cExplorer.url}/api/`)).json();\n        return status.backend.bestBlockHash;\n    }\n\n    /**\n     * @return {Promise<string>} The signed message signed with the collateral private key\n     */\n    async getSignedMessage(sigTime) {\n        const padding = '\\x18DarkNet Signed Message:\\n'\n            .split('')\n            .map((c) => c.charCodeAt(0));\n        const walletPrivateKey = await this._getWalletPrivateKey();\n        const toSign = Masternode.getToSign({\n            addr: this.addr,\n            walletPrivateKey: walletPrivateKey,\n            mnPrivateKey: this.mnPrivateKey,\n            sigTime,\n        })\n            .split('')\n            .map((c) => c.charCodeAt(0));\n        const hash = dSHA256(padding.concat(toSign.length).concat(toSign));\n        const [signature, v] = await nobleSecp256k1.sign(\n            hash,\n            parseWIF(walletPrivateKey, true),\n            { der: false, recovered: true }\n        );\n        return [v + 31, ...signature];\n    }\n    /**\n     * @return {Promise<string>} The signed ping message signed with the masternode private key\n     */\n    async getSignedPingMessage(sigTime, blockHash) {\n        const toSign = Masternode.getPingSignature({\n            vin: {\n                txid: this.collateralTxId,\n                idx: this.outidx,\n            },\n            blockHash,\n            sigTime,\n        });\n        const [signature, v] = await nobleSecp256k1.sign(\n            toSign,\n            parseWIF(this.mnPrivateKey, true),\n            { der: false, recovered: true }\n        );\n        return [v + 27, ...signature];\n    }\n\n    /**\n     * Get the message encoded to hex used to start a masternode\n     * It uses to two signatures: `getPingSignature()` which is signed\n     * With the masternode private key, and `getToSign()` which is signed with\n     * The collateral private key\n     * @return {Promise<string>} The message used to start a masternode.\n     */\n    async broadcastMessageToHex() {\n        const sigTime = Math.round(Date.now() / 1000);\n        const blockHash = await Masternode.getLastBlockHash();\n        const [ip, port] = this.addr.split(':');\n        const walletPrivateKey = await this._getWalletPrivateKey();\n        const walletPublicKey = hexToBytes(\n            deriveAddress({\n                pkBytes: parseWIF(walletPrivateKey, true),\n                output: 'COMPRESSED_HEX',\n            })\n        );\n\n        const mnPublicKey = hexToBytes(\n            deriveAddress({\n                pkBytes: parseWIF(this.mnPrivateKey, true),\n                output: 'UNCOMPRESSED_HEX',\n                compress: false,\n            })\n        );\n\n        const sigBytes = await this.getSignedMessage(sigTime);\n        const sigPingBytes = await this.getSignedPingMessage(\n            sigTime,\n            blockHash\n        );\n\n        const message = [\n            ...hexToBytes(this.collateralTxId).reverse(),\n            ...Masternode._numToBytes(this.outidx, 4, true),\n            ...Masternode._numToBytes(0, 1, true), // Message version\n            ...Masternode._numToBytes(0xffffffff, 4, true),\n            ...hexToBytes(Masternode._decodeIpAddress(ip, port)),\n            ...Masternode._numToBytes(walletPublicKey.length, 1, true),\n            ...walletPublicKey,\n            ...Masternode._numToBytes(mnPublicKey.length, 1, true),\n            ...mnPublicKey,\n            ...Masternode._numToBytes(sigBytes.length, 1, true),\n            ...sigBytes,\n            ...Masternode._numToBytes(sigTime, 8, true),\n            ...Masternode._numToBytes(\n                cChainParams.current.PROTOCOL_VERSION,\n                4,\n                true\n            ),\n            ...hexToBytes(this.collateralTxId).reverse(),\n            ...Masternode._numToBytes(this.outidx, 4, true),\n            ...Masternode._numToBytes(0, 1, true),\n            ...Masternode._numToBytes(0xffffffff, 4, true),\n            ...hexToBytes(blockHash).reverse(),\n            ...Masternode._numToBytes(sigTime, 8, true),\n            ...Masternode._numToBytes(sigPingBytes.length, 1, true),\n            ...sigPingBytes,\n            ...Masternode._numToBytes(1, 4, true),\n            ...Masternode._numToBytes(1, 4, true),\n        ];\n        return bytesToHex(message);\n    }\n\n    /**\n     * Start the masternode\n     * @return {Promise<bool>} Whether or not the message was relayed successfully. This does not necessarely mean\n     * starting was successful, but only that the node was able to decode the broadcast.\n     */\n    async start() {\n        const message = await this.broadcastMessageToHex();\n        const url = `${cNode.url}/relaymasternodebroadcast?params=${message}`;\n        const response = await (await fetch(url)).text();\n        return response.includes('Masternode broadcast sent');\n    }\n\n    /**\n     * @return {Promise<Array>} A list of currently active proposal\n     */\n    static async getProposals() {\n        const url = `${cNode.url}/getbudgetinfo`;\n        return await (await fetch(url)).json();\n    }\n\n    /**\n     * @param {string} hash - the hash of the proposal to vote\n     * @param {number} voteCode - the vote code. \"Yes\" is 1, \"No\" is 2\n     * @param {number} sigTime - The current time in seconds since UNIX epoch\n     * @return {Promise<string>} The signed message used to vote\n     */\n    async getSignedVoteMessage(hash, voteCode, sigTime) {\n        const msg = [\n            ...hexToBytes(this.collateralTxId).reverse(),\n            ...Masternode._numToBytes(this.outidx, 4, true),\n            // Should be tx sequence, but 0xffffff is fine\n            ...[0, 255, 255, 255, 255],\n            ...hexToBytes(hash).reverse(),\n            ...Masternode._numToBytes(voteCode, 4, true),\n            ...Masternode._numToBytes(sigTime, 8, true),\n        ];\n\n        const [signature, v] = await nobleSecp256k1.sign(\n            dSHA256(msg),\n            parseWIF(this.mnPrivateKey, true),\n            { der: false, recovered: true }\n        );\n        return Buffer.from([v + 27, ...signature]).toString('base64');\n    }\n\n    /**\n     * @param {string} hash - the hash of the proposal to vote\n     * @param {number} voteCode - the vote code. \"Yes\" is 1, \"No\" is 2\n     * @return {Promise<string>} The response from the node\n     */\n    async vote(hash, voteCode) {\n        const sigTime = Math.round(Date.now() / 1000);\n        const signature = await this.getSignedVoteMessage(\n            hash,\n            voteCode,\n            sigTime\n        );\n        const url = `${cNode.url}/mnbudgetrawvote?params=${\n            this.collateralTxId\n        },${this.outidx},${hash},${\n            voteCode === 1 ? 'yes' : 'no'\n        },${sigTime},${encodeURI(signature).replaceAll('+', '%2b')}`;\n        const text = await (await fetch(url)).text();\n        return text;\n    }\n}\n","import { cachedBlockCount } from './network.js';\nimport { getBalance, isMasternodeUTXO, getStakingBalance } from './global.js';\nimport { sleep } from './misc.js';\nimport { debug } from './settings.js';\n\n/** An Unspent Transaction Output, used as Inputs of future transactions */\nexport class UTXO {\n    /**\n     * @param {Object} UTXO\n     * @param {String} UTXO.id - Transaction ID\n     * @param {String} UTXO.path - If applicable, the HD Path of the owning address\n     * @param {Number} UTXO.sats - Satoshi value in this UTXO\n     * @param {String} UTXO.script - HEX encoded spending script\n     * @param {Number} UTXO.vout - Output position of this transaction\n     * @param {Number} UTXO.height - Block height of the UTXO\n     * @param {Number} UTXO.status - UTXO status enum state\n     * @param {bool} UTXO.isDelegate - Whether the UTXO is a cold stake delegation\n     */\n    constructor({\n        id,\n        path,\n        sats,\n        script,\n        vout,\n        height,\n        status,\n        isDelegate = false,\n        isReward = false,\n    } = {}) {\n        /** Transaction ID\n         * @type {String} */\n        this.id = id;\n\n        /** HD Path of the owning address\n         *  @type {String} */\n        this.path = path;\n\n        /** Satoshi value in this UTXO\n         *  @type {Number} */\n        this.sats = sats;\n\n        /** HEX encoded spending script\n         *  @type {String} */\n        this.script = script;\n\n        /** Output position of this transaction\n         *  @type {Number} */\n        this.vout = vout;\n\n        /** Block height of the UTXO\n         *  @type {Number} */\n        this.height = height;\n\n        /** UTXO status enum state\n         *  @type {Number} */\n        this.status = status;\n\n        /** If it's a delegation UTXO\n         * @type {bool} */\n        this.isDelegate = isDelegate;\n\n        this.isReward = isReward;\n    }\n\n    /**\n     * Check for equality between this UTXO and another UTXO\n     * @param {UTXO} cUTXO - UTXO to compare against\n     * @returns {Boolean} `true` if equal, `false` if unequal\n     */\n    equalsUTXO(cUTXO) {\n        return (\n            this.id === cUTXO.id &&\n            this.vout === cUTXO.vout &&\n            this.status === cUTXO.status\n        );\n    }\n}\n\n/** A Mempool instance, stores and handles UTXO data for the wallet */\nexport class Mempool {\n    constructor() {\n        /**\n         * An array of all known UTXOs\n         * @type {Array<UTXO>}\n         */\n        this.UTXOs = [];\n    }\n\n    /** The CONFIRMED state (UTXO is spendable) */\n    static CONFIRMED = 0;\n\n    /** The REMOVED state (UTXO was spent and will be removed soon) */\n    static REMOVED = 1;\n\n    /** The PENDING state (standard UTXO is in mempool, pending confirmation) */\n    static PENDING = 2;\n\n    /**\n     * Remove a UTXO after a set amount of time\n     * @param {Number} nBlocks - Estimated blocks to wait\n     * @param {UTXO} cUTXO - UTXO to remove\n     */\n    async removeWithDelay(nBlocks, cUTXO) {\n        await sleep(nBlocks * 60 * 1000);\n        this.removeUTXO(cUTXO);\n    }\n\n    /**\n     * Check if an exact UTXO match can be found in our wallet\n     * @param {Object} UTXO\n     * @param {String} UTXO.id - Transaction ID\n     * @param {Number} UTXO.vout - Output position of this transaction\n     * @param {Number} [UTXO.status] - UTXO status enum state. If it's undefined, it will ignore it.\n     * @returns {Boolean} `true` or `false`\n     */\n    isAlreadyStored({ id, vout, status }) {\n        return this.UTXOs.some(\n            (cUTXO) =>\n                cUTXO.id === id &&\n                cUTXO.vout === vout &&\n                (!status || cUTXO.status === status)\n        );\n    }\n\n    /**\n     * Fetches an array of UTXOs filtered by their state\n     * @param {Number} nState - Specific UTXO state\n     * @returns {Array<UTXO>} `array` - An array of UTXOs\n     */\n    getUTXOsByState(nState) {\n        return this.UTXOs.filter((cUTXO) => cUTXO.status === nState);\n    }\n\n    /**\n     * Removes a UTXO from a specific state\n     * @param {UTXO} cNewUTXO - Pending UTXO to remove\n     * @param {Number} nState - Specific state of this UTXO to search for\n     */\n    removeFromState(cNewUTXO, nState) {\n        const arrPendingUTXOs = this.getUTXOsByState(nState);\n        // Loop each pending UTXO\n        for (const cUTXO of arrPendingUTXOs) {\n            // Search for matching ID + output number\n            if (cUTXO.id === cNewUTXO.id && cUTXO.vout === cNewUTXO.vout) {\n                // Nuke it from orbit\n                this.removeUTXO(cUTXO);\n                break;\n            }\n        }\n    }\n\n    /**\n     * Add a new UTXO to the wallet\n     * @param {Object} UTXO\n     * @param {String} UTXO.id - Transaction ID\n     * @param {String} UTXO.path - If applicable, the HD Path of the owning address\n     * @param {Number} UTXO.sats - Satoshi value in this UTXO\n     * @param {String} UTXO.script - HEX encoded spending script\n     * @param {Number} UTXO.vout - Output position of this transaction\n     * @param {Number} UTXO.height - Block height of the UTXO\n     * @param {Number} UTXO.status - UTXO status enum state\n     * @param {Boolean} UTXO.isDelegate - If this is a Cold Delegation\n     */\n    addUTXO({\n        id,\n        path,\n        sats,\n        script,\n        vout,\n        height,\n        status,\n        isDelegate,\n        isReward,\n    }) {\n        const newUTXO = new UTXO({\n            id,\n            path,\n            sats,\n            script,\n            vout,\n            height,\n            status,\n            isDelegate,\n            isReward,\n        });\n\n        if (this.isAlreadyStored({ id, vout })) {\n            this.updateUTXO({ id, vout });\n        } else {\n            this.UTXOs.push(newUTXO);\n        }\n        getBalance(true);\n        getStakingBalance(true);\n    }\n\n    /**\n     * Update an existing UTXO, by confirming its pending status\n     * The UTXO must be in\n     * @param {Object} UTXO - Object to be deconstructed\n     * @param {String} UTXO.id - Transaction id\n     * @param {Number} UTXO.vout - vout\n     */\n    updateUTXO({ id, vout }) {\n        if (debug) {\n            console.assert(\n                this.isAlreadyStored({ id, vout }),\n                'updateUTXO must be called with an existing UTXO'\n            );\n        }\n        const cUTXO = this.UTXOs.find(\n            (utxo) => utxo.id === id && utxo.vout == vout\n        );\n        switch (cUTXO.status) {\n            case Mempool.PENDING:\n                cUTXO.status = Mempool.CONFIRMED;\n                break;\n        }\n        getBalance(true);\n        getStakingBalance(true);\n    }\n\n    /**\n     * Remove a UTXO completely from our wallet\n     * @param {UTXO} cUTXO - UTXO to remove\n     */\n    removeUTXO(cUTXO) {\n        this.UTXOs = this.UTXOs.filter((utxo) => !utxo.equalsUTXO(cUTXO));\n    }\n\n    /**\n     * Remove a UTXO completely from our wallet, with a 12 minute delay given his id, path and vout\n     * @param {Object} UTXO\n     * @param {String} UTXO.id - Transaction ID\n     * @param {Number} UTXO.vout - Output position of this transaction\n     */\n    autoRemoveUTXO({ id, vout }) {\n        for (const cUTXO of this.UTXOs) {\n            // Loop given + internal UTXOs to find a match, then start the delayed removal\n            if (cUTXO.id === id && cUTXO.vout === vout) {\n                cUTXO.status = Mempool.REMOVED;\n                this.removeWithDelay(12, cUTXO);\n                return;\n            }\n        }\n        console.error(\n            'Mempool: Failed to find UTXO ' +\n                id +\n                ' (' +\n                vout +\n                ') for auto-removal!'\n        );\n    }\n\n    /**\n     * Remove many UTXOs completely from our wallet, with a 12 minute delay\n     * @param {Array<UTXO>} arrUTXOs - UTXOs to remove\n     */\n    autoRemoveUTXOs(arrUTXOs) {\n        for (const cNewUTXO of arrUTXOs) {\n            for (const cUTXO of this.UTXOs) {\n                // Loop given + internal UTXOs to find a match, then start the delayed removal\n                if (cUTXO.equalsUTXO(cNewUTXO)) {\n                    cUTXO.status = Mempool.REMOVED;\n                    this.removeWithDelay(12, cUTXO);\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * Fetches an array of confirmed UTXOs, an easier alias to {@link getUTXOsByState}\n     * @returns {Array<UTXO>} `array` - An array of UTXOs\n     */\n    getConfirmed() {\n        return this.getUTXOsByState(Mempool.CONFIRMED);\n    }\n\n    /**\n     * Get standard, non delegated, UTXOs\n     * @returns {Array<UTXO>} Non delegated utxos\n     */\n    getStandardUTXOs() {\n        return this.UTXOs.filter(\n            (cUTXO) => cUTXO.status !== Mempool.REMOVED && !cUTXO.isDelegate\n        );\n    }\n\n    /**\n     * Get delegated UTXOs\n     * @returns {Array<UTXO>} Delegated UTXOs\n     */\n    getDelegatedUTXOs() {\n        return this.UTXOs.filter(\n            (cUTXO) => cUTXO.status !== Mempool.REMOVED && cUTXO.isDelegate\n        );\n    }\n\n    /**\n     * Returns the real-time balance of the wallet (all addresses)\n     * @returns {Number} Balance in satoshis\n     */\n    getBalance() {\n        // Fetch 'standard' balances: the sum of all Confirmed or Unconfirmed transactions (excluding Masternode collaterals)\n        return this.getStandardUTXOs()\n            .filter((cUTXO) => !isMasternodeUTXO(cUTXO))\n            .reduce((a, b) => a + b.sats, 0);\n    }\n\n    /**\n     * Returns if a UTXO is valid\n     * @param {UTXO} cUTXO - UTXO\n     * @returns {Boolean} `true` if the reward UTXO is spendable, `false` if not\n     */\n    static isValidUTXO(cUTXO) {\n        if (cUTXO.isReward) {\n            return cachedBlockCount - cUTXO.height > 100;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Returns the real-time delegated balance of the wallet (all addresses)\n     * @returns {Number} Delegated balance in satoshis\n     */\n    getDelegatedBalance() {\n        return this.getDelegatedUTXOs().reduce((a, b) => a + b.sats, 0);\n    }\n}\n","import { translateAlerts } from './i18n.js';\nimport { doms } from './global.js';\nimport qrcode from 'qrcode-generator';\nimport bs58 from 'bs58';\nimport { cChainParams } from './chain_params';\nimport { hexToBytes, bytesToHex } from './utils.js';\n\n/* MPW constants */\nexport const pubKeyHashNetworkLen = 21;\nexport const pubChksum = 4;\nexport const pubPrebaseLen = pubKeyHashNetworkLen + pubChksum;\n\n// Base58 Encoding Map\nexport const MAP_B58 =\n    '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nexport const LEN_B58 = MAP_B58.length;\n\n/* --- UTILS --- */\n// Cryptographic Random-Gen\nexport function getSafeRand(nSize = 32) {\n    return crypto.getRandomValues(new Uint8Array(nSize));\n}\n\n// Writes a sequence of Array-like bytes into a location within a Uint8Array\nexport function writeToUint8(arr, bytes, pos) {\n    const arrLen = arr.length;\n    // Sanity: ensure an overflow cannot occur, if one is detected, somewhere in MPW's state could be corrupted.\n    if (arrLen - pos - bytes.length < 0) {\n        const strERR =\n            'CRITICAL: Overflow detected (' +\n            (arrLen - pos - bytes.length) +\n            '), possible state corruption, backup and refresh advised.';\n        createAlert('warning', strERR, 5000);\n        throw Error(strERR);\n    }\n    let i = 0;\n    while (pos < arrLen) arr[pos++] = bytes[i++];\n}\n\n/* --- NOTIFICATIONS --- */\n// Alert - Do NOT display arbitrary / external errors, the use of `.innerHTML` allows for input styling at this cost.\n// Supported types: success, info, warning\nexport function createAlert(type, message, alertVariables = [], timeout = 0) {\n    const domAlert = document.createElement('div');\n    domAlert.classList.add('alertpop');\n    domAlert.classList.add(type);\n    setTimeout(() => {\n        domAlert.style.opacity = '1';\n        domAlert.style.zIndex = '999999';\n        domAlert.classList.add('bounce-ani');\n        domAlert.classList.add('bounce');\n    }, 100);\n    \n\n    // Maintainer QoL adjustment: if `alertVariables` is a number, it is instead assumed to be `timeout`\n    if (typeof alertVariables === 'number') {\n        timeout = alertVariables;\n        alertVariables = [];\n    }\n\n    // Apply translations\n    const translatedMessage = translateAlerts(message, alertVariables);\n\n    // Message\n    domAlert.innerHTML = translatedMessage;\n    domAlert.destroy = () => {\n        // Fully destroy timers + DOM elements, no memory leaks!\n        clearTimeout(domAlert.timer);\n        domAlert.style.opacity = '0';\n        setTimeout(() => {\n            domAlert.remove();\n        }, 600);\n    };\n    // On Click: Delete alert from DOM after close animation.\n    domAlert.addEventListener('click', domAlert.destroy);\n    // On Timeout: Delete alert from DOM after a period of inactive time.\n    if (timeout > 0) domAlert.timer = setTimeout(domAlert.destroy, timeout);\n    doms.domAlertPos.appendChild(domAlert);\n}\n\n// Shows the confirm modal with the provided html.\n// If resolvePromise has a value, the popup won't have\n// Confirm/Cancel buttons and will wait for the promise to resolve\n// Returns the awaited value of resolvePromise\n// or true/false if the user confirmed or not the modal\nexport async function confirmPopup({ title, html, resolvePromise }) {\n    // If there's a title provided: display the header and text\n    doms.domConfirmModalHeader.style.display = title ? 'block' : 'none';\n    doms.domConfirmModalTitle.innerHTML = title || '';\n\n    // If there's a promise to resolve, don't display buttons; the modal visibility will be controlled by the promise (f.e: a 'pls wait' screen)\n    doms.domConfirmModalButtons.style.setProperty(\n        'display',\n        resolvePromise ? 'none' : 'block',\n        resolvePromise ? 'important' : undefined\n    );\n    $('#confirmModal').modal(resolvePromise ? 'show' : { keyboard: false });\n\n    // Set content display\n    doms.domConfirmModalContent.innerHTML = html;\n\n    // Wait for the promise to resolve OR create a new one which resolves upon a modal button click\n    resolvePromise =\n        resolvePromise ||\n        new Promise((res, _) => {\n            doms.domConfirmModalConfirmButton.onclick = () => {\n                res(true);\n            };\n            doms.domConfirmModalCancelButton.onclick = () => {\n                res(false);\n            };\n        });\n    try {\n        return await resolvePromise;\n    } finally {\n        // We want to hide the modal even if an exception occurs\n        $('#confirmModal').modal('hide');\n    }\n}\n\n// Generates and sets a QRCode image from a string and dom element\nexport function createQR(strData = '', domImg, size = 4) {\n    // QRCode class consists of 'typeNumber' & 'errorCorrectionLevel'\n    const cQR = qrcode(size, 'L');\n    cQR.addData(strData);\n    cQR.make();\n    domImg.innerHTML = cQR.createImgTag(2,2);\n    domImg.firstChild.style.borderRadius = '8px';\n}\n\n//generate private key for masternodes\nexport async function generateMnPrivkey() {\n    // maximum value for a decoded private key\n    let max_decoded_value =\n        115792089237316195423570985008687907852837564279074904382605163141518161494337n;\n    let valid = false;\n    let priv_key = 0;\n    while (!valid) {\n        priv_key = bytesToHex(getSafeRand(32));\n        let decoded_priv_key = BigInt('0x' + priv_key);\n\n        if (0 < decoded_priv_key && decoded_priv_key < max_decoded_value) {\n            valid = true;\n        }\n    }\n    return await convertMnPrivKeyFromHex(priv_key);\n}\n\nexport async function convertMnPrivKeyFromHex(hexStr) {\n    //prefixes\n    let WIF_PREFIX = 212;\n    let TESTNET_WIF_PREFIX = 239;\n    let base58_secret = cChainParams.current.isTestnet\n        ? TESTNET_WIF_PREFIX\n        : WIF_PREFIX;\n\n    //convert the hexStr+ initial prefix to byte array hexToBytes(string)\n    let data = [...hexToBytes(hexStr)];\n    data.unshift(base58_secret);\n\n    //generate the checksum with double sha256 hashing\n    let checksum = hexToBytes(await hash(hexToBytes(await hash(data)))).slice(\n        0,\n        4\n    );\n\n    //concatenate data and checksum\n    for (const byte of checksum) {\n        data.push(byte);\n    }\n\n    return bs58.encode(data);\n}\n\n//sha256 a bytearray and return the hash in hexadecimal\nexport async function hash(byteArray) {\n    const utf8 = new Uint8Array(byteArray);\n    const hashBuffer = await crypto.subtle.digest('SHA-256', utf8);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    const hashHex = hashArray\n        .map((bytes) => bytes.toString(16).padStart(2, '0'))\n        .join('');\n    return hashHex;\n}\n\nexport function sanitizeHTML(text) {\n    const element = document.createElement('div');\n    element.innerText = text;\n    return element.innerHTML;\n}\n\n/**\n * An artificial sleep function to pause code execution\n *\n * @param {Number} ms - The milliseconds to sleep\n *\n * @example\n * // Pause an asynchronous script for 1 second\n * await sleep(1000);\n */\nexport function sleep(ms) {\n    return new Promise((res, _) => setTimeout(res, ms));\n}\n","import { doms } from './global';\nimport { createAlert } from './misc';\n\n// Register a service worker, if it's supported\nexport function registerWorker() {\n    if ('serviceWorker' in navigator) {\n        navigator.serviceWorker.register('./native-worker.js');\n\n        // Listen for device pre-install events, these fire if MPW is capable of being installed on the device\n        window.addEventListener('beforeinstallprompt', (event) => {\n            // Prevent the mini-infobar from appearing on mobile.\n            event.preventDefault();\n        });\n\n        // Listen for successful installs\n        window.addEventListener('appinstalled', (_event) => {\n            // Notify!\n            return createAlert('success', 'App Installed!', 2500);\n        });\n    }\n}\n","import { cAnalyticsLevel, cStatKeys, cExplorer, STATS } from './settings.js';\nimport { doms, mempool, updateStakingRewardsGUI } from './global.js';\nimport { masterKey, getDerivationPath, getNewAddress } from './wallet.js';\nimport { cChainParams, donationAddress, COIN } from './chain_params.js';\nimport { createAlert } from './misc.js';\nimport { Mempool } from './mempool.js';\nexport let networkEnabled = true;\nexport let cachedBlockCount = 0;\nexport let arrRewards = [];\n\n// Disable the network, return true if successful.\nexport function disableNetwork() {\n    if (networkEnabled) return !toggleNetwork();\n    return false;\n}\n\nexport function toggleNetwork() {\n    networkEnabled = !networkEnabled;\n    //TRANSLATION CHANGE\n    //doms.domNetwork.innerHTML = '<b>Network:</b> ' + (networkEnabled ? 'Enabled' : 'Disabled');\n    doms.domNetworkE.style.display = networkEnabled ? '' : 'none';\n    doms.domNetworkD.style.display = networkEnabled ? 'none' : '';\n    return networkEnabled;\n}\n\n// Enable the network, return true if successful.\nexport function enableNetwork() {\n    if (!networkEnabled) return toggleNetwork();\n    return false;\n}\n\nexport let lastWallet = 0;\n\nfunction networkError() {\n    if (disableNetwork()) {\n        createAlert(\n            'warning',\n            '<b>Failed to synchronize!</b> Please try again later.' +\n                '<br>You can attempt re-connect via the Settings.',\n            []\n        );\n    }\n}\n\nexport function getBlockCount() {\n    var request = new XMLHttpRequest();\n    request.open('GET', cExplorer.url + '/api/v2/api', true);\n    request.onerror = networkError;\n    request.onload = function () {\n        const data = JSON.parse(this.response);\n        // If the block count has changed, refresh all of our data!\n        doms.domBalanceReload.classList.remove('playAnim');\n        doms.domBalanceReloadStaking.classList.remove('playAnim');\n        if (data.backend.blocks > cachedBlockCount) {\n            console.log(\n                'New block detected! ' +\n                    cachedBlockCount +\n                    ' --> ' +\n                    data.backend.blocks\n            );\n            getUTXOs();\n            getStakingRewards();\n        }\n        cachedBlockCount = data.backend.blocks;\n    };\n    request.send();\n}\n\n/**\n * Parses UTXOs and puts them in the mempool\n * @param {Array<Object>} arrUTXOs - Array of object-formatted UTXOs\n * @returns {Promise<void>} Resolves when it has parsed every UTXO\n */\nasync function acceptUTXO(arrUTXOs) {\n    const nTimeSyncStart = Date.now() / 1000;\n\n    for (const cUTXO of arrUTXOs) {\n        if (mempool.isAlreadyStored({ id: cUTXO.txid, vout: cUTXO.vout })) {\n            mempool.updateUTXO({ id: cUTXO.txid, vout: cUTXO.vout });\n            continue;\n        }\n        const cTx = await (\n            await fetch(`${cExplorer.url}/api/v2/tx-specific/${cUTXO.txid}`)\n        ).json();\n        const cVout = cTx.vout[cUTXO.vout];\n\n        let path;\n        if (cUTXO.path) {\n            path = cUTXO.path.split('/');\n            path[2] =\n                (masterKey.isHardwareWallet\n                    ? cChainParams.current.BIP44_TYPE_LEDGER\n                    : cChainParams.current.BIP44_TYPE) + \"'\";\n            lastWallet = Math.max(parseInt(path[5]), lastWallet);\n            path = path.join('/');\n        }\n\n        const isColdStake = cVout.scriptPubKey.type === 'coldstake';\n        const isStandard = cVout.scriptPubKey.type === 'pubkeyhash';\n        const isReward = cTx.vout[0].scriptPubKey.hex === '';\n        // We don't know what this is\n        if (!isColdStake && !isStandard) {\n            continue;\n        }\n\n        mempool.addUTXO({\n            id: cUTXO.txid,\n            path,\n            sats: Math.round(cVout.value * COIN),\n            script: cVout.scriptPubKey.hex,\n            vout: cVout.n,\n            height: cachedBlockCount - (cTx.confirmations - 1),\n            status: cTx.confirmations < 1 ? Mempool.PENDING : Mempool.CONFIRMED,\n            isDelegate: isColdStake,\n            isReward,\n        });\n    }\n    getNewAddress(true);\n    if (arrUTXOs.length) {\n        // If allowed by settings: submit a sync performance measurement to Labs Analytics\n        return submitAnalytics('time_to_sync', {\n            time: Date.now() / 1000 - nTimeSyncStart,\n            explorer: cExplorer.name,\n        });\n    }\n}\n\n/**\n * Fetch UTXOs from the current primary explorer\n * @returns {Promise<void>} Resolves when it has finished fetching UTXOs\n */\nasync function getUTXOs() {\n    // Don't fetch UTXOs if we're already scanning for them!\n    if (getUTXOs.isSyncing) return;\n    getUTXOs.isSyncing = true;\n    try {\n        let publicKey;\n        if (masterKey.isHD) {\n            const derivationPath = getDerivationPath(masterKey.isHardwareWallet)\n                .split('/')\n                .slice(0, 4)\n                .join('/');\n            publicKey = await masterKey.getxpub(derivationPath);\n        } else {\n            publicKey = await masterKey.getAddress();\n        }\n        // Validate and sync these UTXOs\n        await acceptUTXO(\n            await (\n                await fetch(`${cExplorer.url}/api/v2/utxo/${publicKey}`)\n            ).json()\n        );\n    } catch (e) {\n        console.error(e);\n        networkError();\n    } finally {\n        getUTXOs.isSyncing = false;\n    }\n}\n\nexport async function sendTransaction(hex, msg = '') {\n    try {\n        const data = await (\n            await fetch(cExplorer.url + '/api/v2/sendtx/', {\n                method: 'post',\n                body: hex,\n            })\n        ).json();\n        if (data.result && data.result.length === 64) {\n            console.log('Transaction sent! ' + data.result);\n            if (doms.domAddress1s.value !== donationAddress)\n                doms.domTxOutput.innerHTML =\n                    '<h4 style=\"color:green; font-family:mono !important;\">' +\n                    data.result +\n                    '</h4>';\n            else\n                doms.domTxOutput.innerHTML =\n                    '<h4 style=\"color:green\">Thank you for supporting MyPIVXWallet! 💜💜💜<br><span style=\"font-family:mono !important\">' +\n                    data.result +\n                    '</span></h4>';\n            doms.domSimpleTXs.style.display = 'none';\n            doms.domAddress1s.value = '';\n            doms.domValue1s.innerHTML = '';\n            createAlert(\n                'success',\n                msg || 'Transaction sent!',\n                msg ? 1250 + msg.length * 50 : 1500\n            );\n            // If allowed by settings: submit a simple 'tx' ping to Labs Analytics\n            submitAnalytics('transaction');\n            return true;\n        } else {\n            console.log('Error sending transaction: ' + data.result);\n            createAlert('warning', 'Transaction Failed!', 1250);\n            // Attempt to parse and prettify JSON (if any), otherwise, display the raw output.\n            let strError = data.error;\n            try {\n                strError = JSON.stringify(JSON.parse(data), null, 4);\n                console.log('parsed');\n            } catch (e) {\n                console.log('no parse!');\n                console.log(e);\n            }\n            doms.domTxOutput.innerHTML =\n                '<h4 style=\"color:red;font-family:mono !important;\"><pre style=\"color: inherit;\">' +\n                strError +\n                '</pre></h4>';\n            return false;\n        }\n    } catch (e) {\n        console.error(e);\n        networkError();\n    }\n}\n\nexport function getFee(bytes) {\n    // TEMPORARY: Hardcoded fee per-byte\n    return bytes * 50; // 50 sat/byte\n}\n\nexport async function getStakingRewards() {\n    if (!networkEnabled || masterKey == undefined) return;\n    doms.domGuiStakingLoadMoreIcon.style.opacity = 0.5;\n    const stopAnim = () => (doms.domGuiStakingLoadMoreIcon.style.opacity = 1);\n    const nHeight = arrRewards.length\n        ? arrRewards[arrRewards.length - 1].blockHeight\n        : 0;\n    let mapPaths = new Map();\n    const txSum = (v) =>\n        v.reduce(\n            (t, s) =>\n                t +\n                (s.addresses\n                    .map((strAddr) => mapPaths.get(strAddr))\n                    .filter((v) => v).length && s.addresses.length === 2\n                    ? parseInt(s.value)\n                    : 0),\n            0\n        );\n    let cData;\n    if (masterKey.isHD) {\n        const derivationPath = getDerivationPath(masterKey.isHardwareWallet)\n            .split('/')\n            .slice(0, 4)\n            .join('/');\n        const xpub = await masterKey.getxpub(derivationPath);\n        cData = await (\n            await fetch(\n                `${\n                    cExplorer.url\n                }/api/v2/xpub/${xpub}?details=txs&pageSize=500&to=${\n                    nHeight ? nHeight - 1 : 0\n                }`\n            )\n        ).json();\n        // Map all address <--> derivation paths\n        if (cData.tokens)\n            cData.tokens.forEach((cAddrPath) =>\n                mapPaths.set(cAddrPath.name, cAddrPath.path)\n            );\n    } else {\n        const address = await masterKey.getAddress();\n        cData = await (\n            await fetch(\n                `${\n                    cExplorer.url\n                }/api/v2/address/${address}?details=txs&pageSize=500&to=${\n                    nHeight ? nHeight - 1 : 0\n                }`\n            )\n        ).json();\n        mapPaths.set(address, ':)');\n    }\n    if (cData && cData.transactions) {\n        // Update rewards\n        arrRewards = arrRewards.concat(\n            cData.transactions\n                .filter((tx) => tx.vout[0].addresses[0] === 'CoinStake TX')\n                .map((tx) => {\n                    return {\n                        id: tx.txid,\n                        time: tx.blockTime,\n                        blockHeight: tx.blockHeight,\n                        amount: (txSum(tx.vout) - txSum(tx.vin)) / COIN,\n                    };\n                })\n                .filter((tx) => tx.amount != 0)\n        );\n\n        // If the results don't match the full 'max/requested results', then we know there's nothing more to load, hide the button!\n        if (cData.transactions.length !== cData.itemsOnPage)\n            doms.domGuiStakingLoadMore.style.display = 'none';\n\n        // Update GUI\n        stopAnim();\n        updateStakingRewardsGUI(true);\n    } else {\n        // No balance history!\n        doms.domGuiStakingLoadMore.style.display = 'none';\n\n        // Update GUI\n        stopAnim();\n    }\n}\n\nexport async function getTxInfo(txHash) {\n    const req = await fetch(`${cExplorer.url}/api/v2/tx/${txHash}`);\n    return await req.json();\n}\n\n// PIVX Labs Analytics: if you are a user, you can disable this FULLY via the Settings.\n// ... if you're a developer, we ask you to keep these stats to enhance upstream development,\n// ... but you are free to completely strip MPW of any analytics, if you wish, no hard feelings.\nexport function submitAnalytics(strType, cData = {}) {\n    if (!networkEnabled) return;\n\n    // Limit analytics here to prevent 'leakage' even if stats are implemented incorrectly or forced\n    let i = 0,\n        arrAllowedKeys = [];\n    for (i; i < cAnalyticsLevel.stats.length; i++) {\n        const cStat = cAnalyticsLevel.stats[i];\n        arrAllowedKeys.push(cStatKeys.find((a) => STATS[a] === cStat));\n    }\n\n    // Check if this 'stat type' was granted permissions\n    if (!arrAllowedKeys.includes(strType)) return false;\n\n    // Format\n    const cStats = { type: strType, ...cData };\n\n    // Send to Labs Analytics\n    const request = new XMLHttpRequest();\n    request.open('POST', 'https://scpscan.net/mpw/statistic', true);\n    request.setRequestHeader('Content-Type', 'application/json');\n    request.send(JSON.stringify(cStats));\n    return true;\n}\n","import {\n    doms,\n    getBalance,\n    getStakingBalance,\n    updateStakingRewardsGUI,\n} from './global.js';\nimport { fWalletLoaded } from './wallet.js';\nimport { cChainParams } from './chain_params.js';\nimport { enableNetwork } from './network.js';\nimport { createAlert } from './misc.js';\nimport {\n    switchTranslation,\n    ALERTS,\n    translation,\n    arrActiveLangs,\n} from './i18n.js';\n\n// --- Default Settings\nexport let debug = false; // A mode that emits verbose console info for internal MPW operations\nlet networkEnabled = true; // A lock which blocks ALL network requests in totality\nexport let cExplorer = cChainParams.current.Explorers[0];\nexport let cNode = cChainParams.current.Nodes[0];\n\nlet transparencyReport;\n// A list of statistic keys and their descriptions\nexport let STATS = {\n    // Stat key   // Description of the stat, it's data, and it's purpose\n    hit: 'A ping indicating an app load, no unique data is sent.',\n    time_to_sync: 'The time in seconds it took for MPW to last synchronise.',\n    transaction:\n        'A ping indicating a Tx, no unique data is sent, but may be inferred from on-chain time.',\n};\n\nexport const cStatKeys = Object.keys(STATS);\n\n// A list of Analytics 'levels' at which the user may set depending on their privacy preferences\nlet arrAnalytics = [\n    // Statistic level  // Allowed statistics\n    { name: 'Disabled', stats: [] },\n    { name: 'Minimal', stats: [STATS.hit, STATS.time_to_sync] },\n    {\n        name: 'Balanced',\n        stats: [STATS.hit, STATS.time_to_sync, STATS.transaction],\n    },\n];\n\nexport let cAnalyticsLevel = arrAnalytics[2];\n\n// Users need not look below here.\n// ------------------------------\n// Global Keystore / Wallet Information\n\n// --- DOM Cache\nexport function start() {\n    //TRANSLATIONS\n    //to make translations work we need to change it so that we just enable or disable the visibility of the text\n    doms.domNetworkE.style.display = networkEnabled ? '' : 'none';\n    doms.domNetworkD.style.display = networkEnabled ? 'none' : '';\n    doms.domTestnet.style.display = cChainParams.current.isTestnet\n        ? ''\n        : 'none';\n    doms.domDebug.style.display = debug ? '' : 'none';\n\n    // Hook up the 'explorer' select UI\n    document.getElementById('explorer').onchange = function (evt) {\n        setExplorer(\n            cChainParams.current.Explorers.find(\n                (a) => a.url === evt.target.value\n            )\n        );\n    };\n\n    document.getElementById('translation').onchange = function (evt) {\n        setTranslation(evt.target.value);\n    };\n    // Hook up the 'analytics' select UI\n    document.getElementById('analytics').onchange = function (evt) {\n        setAnalytics(arrAnalytics.find((a) => a.name === evt.target.value));\n    };\n\n    const domAnalyticsSelect = document.getElementById('analytics');\n\n    fillExplorerSelect();\n    fillNodeSelect();\n    fillTranslationSelect();\n\n    // Add each analytics level into the UI selector\n    for (const analLevel of arrAnalytics) {\n        const opt = document.createElement('option');\n        opt.value = opt.innerHTML = analLevel.name;\n        domAnalyticsSelect.appendChild(opt);\n    }\n\n    // Fetch settings from LocalStorage\n    const strSettingAnalytics = localStorage.getItem('analytics');\n\n    // Apply translations to the transparency report\n    STATS = {\n        // Stat key   // Description of the stat, it's data, and it's purpose\n        hit: translation.hit,\n        time_to_sync: translation.time_to_sync,\n        transaction: translation.transaction,\n    };\n    transparencyReport = translation.transparencyReport;\n    arrAnalytics = [\n        // Statistic level  // Allowed statistics\n        { name: 'Disabled', stats: [] },\n        { name: 'Minimal', stats: [STATS.hit, STATS.time_to_sync] },\n        {\n            name: 'Balanced',\n            stats: [STATS.hit, STATS.time_to_sync, STATS.transaction],\n        },\n    ];\n\n    // Honour the \"Do Not Track\" header by default\n    if (!strSettingAnalytics && navigator.doNotTrack === '1') {\n        // Disabled\n        setAnalytics(arrAnalytics[0], true);\n        doms.domAnalyticsDescriptor.innerHTML =\n            '<h6 style=\"color:#dcdf6b;font-family:mono !important;\"><pre style=\"color: inherit;\">Analytics disabled to honour \"Do Not Track\" browser setting, you may manually enable if desired, though!</pre></h6>';\n    } else {\n        // Load from storage, or use defaults\n        setAnalytics(\n            (cAnalyticsLevel =\n                arrAnalytics.find((a) => a.name === strSettingAnalytics) ||\n                cAnalyticsLevel),\n            true\n        );\n    }\n\n    // And update the UI to reflect them\n    domAnalyticsSelect.value = cAnalyticsLevel.name;\n}\n// --- Settings Functions\nfunction setExplorer(explorer, fSilent = false) {\n    cExplorer = explorer;\n    localStorage.setItem(\n        'explorer' + (cChainParams.current.isTestnet ? '-testnet' : ''),\n        explorer.url\n    );\n\n    // Enable networking + notify if allowed\n    enableNetwork();\n    if (!fSilent)\n        createAlert(\n            'success',\n            ALERTS.SWITCHED_EXPLORERS,\n            [{ explorerName: cExplorer.name }],\n            2250\n        );\n}\n\nfunction setNode(node, fSilent = false) {\n    cNode = node;\n    localStorage.setItem(\n        'node' + (cChainParams.current.isTestnet ? '-testnet' : ''),\n        node.url\n    );\n\n    // Enable networking + notify if allowed\n    enableNetwork();\n    if (!fSilent)\n        createAlert(\n            'success',\n            ALERTS.SWITCHED_NODE,\n            [{ node: cNode.name }],\n            2250\n        );\n}\n\n//TRANSLATION\n/**\n * switches the translation and sets the translation preference to local storage\n * @param {string} lang\n * @param {bool} fSilent\n */\nfunction setTranslation(lang) {\n    switchTranslation(lang);\n    localStorage.setItem('translation', lang);\n}\n\n/**\n * Fills the translation dropbox on the settings page\n */\nfunction fillTranslationSelect() {\n    while (doms.domTranslationSelect.options.length > 0) {\n        doms.domTranslationSelect.remove(0);\n    }\n\n    // Add each trusted explorer into the UI selector\n    for (const lang of arrActiveLangs) {\n        const opt = document.createElement('option');\n        opt.value = lang;\n        opt.innerHTML = lang;\n        doms.domTranslationSelect.appendChild(opt);\n    }\n\n    // And update the UI to reflect them\n    doms.domTranslationSelect.value =\n        localStorage.getItem('translation') || 'en';\n}\n\nfunction setAnalytics(level, fSilent = false) {\n    cAnalyticsLevel = level;\n    localStorage.setItem('analytics', level.name);\n    // For total transparency, we'll 'describe' the various analytic keys of this chosen level\n    let strDesc = '<center>--- ' + transparencyReport + ' ---</center><br>',\n        i = 0;\n    const nLongestKeyLen = cStatKeys.reduce((prev, e) =>\n        prev.length >= e.length ? prev : e\n    ).length;\n    for (i; i < cAnalyticsLevel.stats.length; i++) {\n        const cStat = cAnalyticsLevel.stats[i];\n        // This formats Stat keys into { $key $(padding) $description }\n        strDesc +=\n            cStatKeys\n                .find((a) => STATS[a] === cStat)\n                .padEnd(nLongestKeyLen, ' ') +\n            ': ' +\n            cStat +\n            '<br>';\n    }\n\n    // Set display + notify if allowed\n    doms.domAnalyticsDescriptor.innerHTML =\n        cAnalyticsLevel.name === arrAnalytics[0].name\n            ? ''\n            : '<h6 style=\"color:#dcdf6b;font-family:mono !important;\"><pre style=\"color: inherit;\">' +\n              strDesc +\n              '</pre></h6>';\n    if (!fSilent)\n        createAlert(\n            'success',\n            ALERTS.SWITCHED_ANALYTICS,\n            [{ level: cAnalyticsLevel.name }],\n            2250\n        );\n}\n\nexport function toggleTestnet() {\n    if (fWalletLoaded)\n        return createAlert('warning', ALERTS.UNABLE_SWITCH_TESTNET, [], 3250);\n\n    // Update current chain config\n    cChainParams.current = cChainParams.current.isTestnet\n        ? cChainParams.main\n        : cChainParams.testnet;\n\n    // Update UI and static tickers\n    //TRANSLATIONS\n    doms.domTestnet.style.display = cChainParams.current.isTestnet\n        ? ''\n        : 'none';\n    doms.domGuiBalanceTicker.innerText = cChainParams.current.TICKER;\n    doms.domGuiBalanceStakingTicker.innerText = cChainParams.current.TICKER;\n    doms.domPrefixNetwork.innerText =\n        cChainParams.current.PUBKEY_PREFIX.join(' or ');\n    fillExplorerSelect();\n    fillNodeSelect();\n    getBalance(true);\n    getStakingBalance(true);\n    updateStakingRewardsGUI();\n}\n\nexport function toggleDebug() {\n    debug = !debug;\n    //TRANSLATION CHANGES\n    //doms.domDebug.innerHTML = debug ? '<b>DEBUG MODE ON</b>' : '';\n    doms.domDebug.style.display = debug ? '' : 'none';\n}\n\nfunction fillExplorerSelect() {\n    cExplorer = cChainParams.current.Explorers[0];\n\n    while (doms.domExplorerSelect.options.length > 0) {\n        doms.domExplorerSelect.remove(0);\n    }\n\n    // Add each trusted explorer into the UI selector\n    for (const explorer of cChainParams.current.Explorers) {\n        const opt = document.createElement('option');\n        opt.value = explorer.url;\n        opt.innerHTML =\n            explorer.name + ' (' + explorer.url.replace('https://', '') + ')';\n        doms.domExplorerSelect.appendChild(opt);\n    }\n\n    // Fetch settings from LocalStorage\n    const strSettingExplorer = localStorage.getItem(\n        'explorer' + (cChainParams.current.isTestnet ? '-testnet' : '')\n    );\n\n    // For any that exist: load them, or use the defaults\n    setExplorer(\n        cChainParams.current.Explorers.find(\n            (a) => a.url === strSettingExplorer\n        ) || cExplorer,\n        true\n    );\n\n    // And update the UI to reflect them\n    doms.domExplorerSelect.value = cExplorer.url;\n}\n\nfunction fillNodeSelect() {\n    cNode = cChainParams.current.Nodes[0];\n\n    while (doms.domNodeSelect.options.length > 0) {\n        doms.domNodeSelect.remove(0);\n    }\n\n    // Add each trusted node into the UI selector\n    for (const node of cChainParams.current.Nodes) {\n        const opt = document.createElement('option');\n        opt.value = node.url;\n        opt.innerHTML =\n            node.name + ' (' + node.url.replace('https://', '') + ')';\n        doms.domNodeSelect.appendChild(opt);\n    }\n\n    // Fetch settings from LocalStorage\n    const strSettingNode = localStorage.getItem(\n        'node' + (cChainParams.current.isTestnet ? '-testnet' : '')\n    );\n\n    // For any that exist: load them, or use the defaults\n    setNode(\n        cChainParams.current.Nodes.find((a) => a.url === strSettingNode) ||\n            cNode,\n        true\n    );\n\n    // And update the UI to reflect them\n    doms.domNodeSelect.value = cNode.url;\n}\n","import { Buffer } from 'buffer';\nimport { sha256 } from '@noble/hashes/sha256';\n\nexport function hexToBytes(str) {\n    return Buffer.from(str, 'hex');\n}\n\nexport function bytesToHex(bytes) {\n    return Buffer.from(bytes).toString('hex');\n}\n\n/**\n   @returns {Uint8Array} double sha256 or the buffer\n */\nexport function dSHA256(buff) {\n    return sha256(sha256(new Uint8Array(buff)));\n}\n","import { deriveAddress } from './wallet.js';\nimport { getSafeRand } from './misc.js';\n\nonmessage = function (_evt) {\n    while (true) {\n        const cKeypair = {};\n        cKeypair.priv = getSafeRand();\n\n        cKeypair.pub = deriveAddress({ pkBytes: cKeypair.priv });\n        postMessage(cKeypair);\n    }\n};\n","import { hexToBytes, bytesToHex, dSHA256 } from './utils.js';\nimport * as nobleSecp256k1 from '@noble/secp256k1';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { generateMnemonic, mnemonicToSeed, validateMnemonic } from 'bip39';\nimport { doms, beforeUnloadListener } from './global.js';\nimport HDKey from 'hdkey';\nimport { lastWallet, networkEnabled } from './network.js';\nimport {\n    pubKeyHashNetworkLen,\n    confirmPopup,\n    writeToUint8,\n    pubPrebaseLen,\n    createQR,\n    createAlert,\n    sleep,\n    getSafeRand,\n} from './misc.js';\nimport {\n    refreshChainData,\n    hideAllWalletOptions,\n    getBalance,\n    getStakingBalance,\n} from './global.js';\nimport {\n    cChainParams,\n    MAX_ACCOUNT_GAP,\n    PRIVKEY_BYTE_LENGTH,\n} from './chain_params.js';\nimport { ALERTS } from './i18n.js';\nimport { encrypt, decrypt } from './aes-gcm.js';\nimport bs58 from 'bs58';\nimport AppBtc from '@ledgerhq/hw-app-btc';\nimport TransportWebUSB from '@ledgerhq/hw-transport-webusb';\nimport createXpub from 'create-xpub';\nimport * as jdenticon from 'jdenticon';\n\nexport let fWalletLoaded = false;\n\n/**\n * Abstract class masterkey\n * @abstract\n */\nclass MasterKey {\n    /**\n     * @param {String} [path] - BIP32 path pointing to the private key.\n     * @return {Promise<Array<Number>>} Array of bytes containing private key\n     * @abstract\n     */\n    async getPrivateKeyBytes(_path) {\n        throw new Error('Not implemented');\n    }\n\n    /**\n     * @param {String} [path] - BIP32 path pointing to the private key.\n     * @return {String} encoded private key\n     * @abstract\n     */\n    async getPrivateKey(path) {\n        return generateOrEncodePrivkey(await this.getPrivateKeyBytes(path))\n            .strWIF;\n    }\n\n    /**\n     * @param {String} [path] - BIP32 path pointing to the address\n     * @return {String} Address\n     * @abstract\n     */\n    async getAddress(path) {\n        return deriveAddress({ pkBytes: await this.getPrivateKeyBytes(path) });\n    }\n\n    /**\n     * @param {String} path - BIP32 path pointing to the xpub\n     * @return {Promise<String>} xpub\n     * @abstract\n     */\n    async getxpub(_path) {\n        throw new Error('Not implemented');\n    }\n\n    /**\n     * Wipe all private data from key.\n     * @return {void}\n     * @abstract\n     */\n    wipePrivateData() {\n        throw new Error('Not implemented');\n    }\n\n    /**\n     * @return {String} private key suitable for backup.\n     * @abstract\n     */\n    get keyToBackup() {\n        throw new Error('Not implemented');\n    }\n\n    /**\n     * @return {String} public key to export. Only suitable for monitoring balance.\n     * @abstract\n     */\n    get keyToExport() {\n        throw new Error('Not implemented');\n    }\n\n    /**\n     * @return {Boolean} Whether or not this is a Hierarchical Deterministic wallet\n     */\n    get isHD() {\n        return this._isHD;\n    }\n\n    /**\n     * @return {Boolean} Whether or not this is a hardware wallet\n     */\n    get isHardwareWallet() {\n        return this._isHardwareWallet;\n    }\n\n    /**\n     * @return {Boolean} Whether or not this key is view only or not\n     */\n    get isViewOnly() {\n        return this._isViewOnly;\n    }\n}\n\nexport class HdMasterKey extends MasterKey {\n    constructor({ seed, xpriv, xpub }) {\n        super();\n        // Generate the HDKey\n        if (seed) this._hdKey = HDKey.fromMasterSeed(seed);\n        if (xpriv) this._hdKey = HDKey.fromExtendedKey(xpriv);\n        if (xpub) this._hdKey = HDKey.fromExtendedKey(xpub);\n        this._isViewOnly = !!xpub;\n        if (!this._hdKey)\n            throw new Error('All of seed, xpriv and xpub are undefined');\n        this._isHD = true;\n        this._isHardwareWallet = false;\n    }\n\n    async getPrivateKeyBytes(path) {\n        if (this.isViewOnly) {\n            throw new Error(\n                'Trying to get private key bytes from a view only key'\n            );\n        }\n        return this._hdKey.derive(path).privateKey;\n    }\n\n    get keyToBackup() {\n        if (this.isViewOnly) {\n            throw new Error('Trying to get private key from a view only key');\n        }\n        return this._hdKey.privateExtendedKey;\n    }\n\n    async getxpub(path) {\n        if (this.isViewOnly) return this._hdKey.publicExtendedKey;\n        return this._hdKey.derive(path).publicExtendedKey;\n    }\n\n    getAddress(path) {\n        let child;\n        if (this.isViewOnly) {\n            // If we're view only we can't derive hardened keys, so we'll assume\n            // That the xpub has already been derived\n            child = this._hdKey.derive(\n                path\n                    .split('/')\n                    .filter((n) => !n.includes(\"'\"))\n                    .join('/')\n            );\n        } else {\n            child = this._hdKey.derive(path);\n        }\n        return deriveAddress({ publicKey: bytesToHex(child.publicKey) });\n    }\n\n    wipePrivateData() {\n        if (this._isViewOnly) return;\n\n        this._hdKey = HDKey.fromExtendedKey(this.keyToExport);\n        this._isViewOnly = true;\n    }\n\n    get keyToExport() {\n        if (this._isViewOnly) return this._hdKey.publicExtendedKey;\n        // We need the xpub to point at the account level\n        return this._hdKey.derive(\n            getDerivationPath(false).split('/').slice(0, 4).join('/')\n        ).publicExtendedKey;\n    }\n}\n\nexport class HardwareWalletMasterKey extends MasterKey {\n    constructor() {\n        super();\n        this._isHD = true;\n        this._isHardwareWallet = true;\n    }\n    async getPrivateKeyBytes(_path) {\n        throw new Error('Hardware wallets cannot export private keys');\n    }\n\n    async getAddress(path, { verify } = {}) {\n        return deriveAddress({\n            publicKey: await getHardwareWalletKeys(path, false, verify),\n        });\n    }\n\n    get keyToBackup() {\n        throw new Error(\"Hardware wallets don't have keys to backup\");\n    }\n\n    async getxpub(path) {\n        if (!this.xpub) {\n            this.xpub = await getHardwareWalletKeys(path, true);\n        }\n        return this.xpub;\n    }\n\n    // Hardware Wallets don't have exposed private data\n    wipePrivateData() {}\n\n    get isViewOnly() {\n        return false;\n    }\n    get keyToExport() {\n        return this.getxpub(\n            getDerivationPath(true)\n                .split('/')\n                .filter((v) => !v.includes(\"'\"))\n                .join('/')\n        );\n    }\n}\n\nexport class LegacyMasterKey extends MasterKey {\n    constructor({ pkBytes, address }) {\n        super();\n        this._isHD = false;\n        this._isHardwareWallet = false;\n        this._pkBytes = pkBytes;\n        this._address = address || super.getAddress();\n        this._isViewOnly = !!address;\n    }\n\n    getAddress() {\n        return this._address;\n    }\n\n    get keyToExport() {\n        return this._address;\n    }\n\n    async getPrivateKeyBytes(_path) {\n        if (this.isViewOnly) {\n            throw new Error(\n                'Trying to get private key bytes from a view only key'\n            );\n        }\n        return this._pkBytes;\n    }\n\n    get keyToBackup() {\n        return generateOrEncodePrivkey(this._pkBytes).strWIF;\n    }\n\n    async getxpub(_path) {\n        throw new Error(\n            'Trying to get an extended public key from a legacy address'\n        );\n    }\n\n    wipePrivateData() {\n        this._pkBytes = null;\n        this._isViewOnly = true;\n    }\n}\n\n// Ledger Hardware wallet constants\nexport const LEDGER_ERRS = new Map([\n    // Ledger error code <--> User-friendly string\n    [25870, 'Open the PIVX app on your device'],\n    [25873, 'Open the PIVX app on your device'],\n    [57408, 'Navigate to the PIVX app on your device'],\n    [27157, 'Wrong app! Open the PIVX app on your device'],\n    [27266, 'Wrong app! Open the PIVX app on your device'],\n    [27904, 'Wrong app! Open the PIVX app on your device'],\n    [27010, 'Unlock your Ledger, then try again!'],\n    [27404, 'Unlock your Ledger, then try again!'],\n]);\n\nexport let masterKey;\n\n// Construct a full BIP44 pubkey derivation path from it's parts\nexport function getDerivationPath(\n    fLedger = false,\n    nAccount = 0,\n    nReceiving = 0,\n    nIndex = 0\n) {\n    // Coin-Type is different on Ledger, as such, we modify it if we're using a Ledger to derive a key\n    const strCoinType = fLedger\n        ? cChainParams.current.BIP44_TYPE_LEDGER\n        : cChainParams.current.BIP44_TYPE;\n    if (masterKey && !masterKey.isHD && !fLedger) {\n        return `:)//${strCoinType}'`;\n    }\n    return `m/44'/${strCoinType}'/${nAccount}'/${nReceiving}/${nIndex}`;\n}\n\n// Verify the integrity of a WIF private key, optionally parsing and returning the key payload\nexport function verifyWIF(\n    strWIF = '',\n    fParseBytes = false,\n    skipVerification = false\n) {\n    // Convert from Base58\n    const bWIF = bs58.decode(strWIF);\n\n    if (!skipVerification) {\n        // Verify the byte length\n        if (bWIF.byteLength !== PRIVKEY_BYTE_LENGTH) {\n            throw Error(\n                'Private key length (' +\n                    bWIF.byteLength +\n                    ') is invalid, should be ' +\n                    PRIVKEY_BYTE_LENGTH +\n                    '!'\n            );\n        }\n\n        // Verify the network byte\n        if (bWIF[0] !== cChainParams.current.SECRET_KEY) {\n            // Find the network it's trying to use, if any\n            const cNetwork = Object.keys(cChainParams)\n                .filter((strNet) => strNet !== 'current')\n                .map((strNet) => cChainParams[strNet])\n                .find((cNet) => cNet.SECRET_KEY === bWIF[0]);\n            // Give a specific alert based on the byte properties\n            throw Error(\n                cNetwork\n                    ? 'This private key is for ' +\n                          (cNetwork.isTestnet ? 'Testnet' : 'Mainnet') +\n                          ', wrong network!'\n                    : 'This private key belongs to another coin, or is corrupted.'\n            );\n        }\n\n        // Perform SHA256d hash of the WIF bytes\n        const shaHash = dSHA256(bWIF.slice(0, 34));\n\n        // Verify checksum (comparison by String since JS hates comparing object-like primitives)\n        const bChecksumWIF = bWIF.slice(bWIF.byteLength - 4);\n        const bChecksum = shaHash.slice(0, 4);\n        if (bChecksumWIF.join('') !== bChecksum.join('')) {\n            throw Error(\n                'Private key checksum is invalid, key may be modified, mis-typed, or corrupt.'\n            );\n        }\n    }\n\n    return fParseBytes ? Uint8Array.from(bWIF.slice(1, 33)) : true;\n}\n\n// A convenient alias to verifyWIF that returns the raw byte payload\nexport function parseWIF(strWIF, skipVerification = false) {\n    return verifyWIF(strWIF, true, skipVerification);\n}\n\n// Generate a new private key OR encode an existing private key from raw bytes\nexport function generateOrEncodePrivkey(pkBytesToEncode) {\n    // Private Key Generation\n    const pkBytes = pkBytesToEncode || getSafeRand();\n    const pkNetBytesLen = pkBytes.length + 2;\n    const pkNetBytes = new Uint8Array(pkNetBytesLen);\n\n    // Network Encoding\n    pkNetBytes[0] = cChainParams.current.SECRET_KEY; // Private key prefix (1 byte)\n    writeToUint8(pkNetBytes, pkBytes, 1); // Private key bytes  (32 bytes)\n    pkNetBytes[pkNetBytesLen - 1] = 1; // Leading digit      (1 byte)\n\n    // Double SHA-256 hash\n    const shaObj = dSHA256(pkNetBytes);\n\n    // WIF Checksum\n    const checksum = shaObj.slice(0, 4);\n    const keyWithChecksum = new Uint8Array(pkNetBytesLen + checksum.length);\n    writeToUint8(keyWithChecksum, pkNetBytes, 0);\n    writeToUint8(keyWithChecksum, checksum, pkNetBytesLen);\n\n    // Return both the raw bytes and the WIF format\n    return { pkBytes, strWIF: bs58.encode(keyWithChecksum) };\n}\n\n/**\n * Compress an uncompressed Public Key in byte form\n * @param {Array<Number> | Uint8Array} pubKeyBytes - The uncompressed public key bytes\n * @returns {Array<Number>} The compressed public key bytes\n */\nfunction compressPublicKey(pubKeyBytes) {\n    if (pubKeyBytes.length != 65)\n        throw new Error('Attempting to compress an invalid uncompressed key');\n    const x = pubKeyBytes.slice(1, 33);\n    const y = pubKeyBytes.slice(33);\n\n    // Compressed key is [key_parity + 2, x]\n    return [y[31] % 2 === 0 ? 2 : 3, ...x];\n}\n\n/**\n * Derive a Secp256k1 network-encoded public key (coin address) from raw private or public key bytes\n * @param {Object} options - The object to deconstruct\n * @param {String} [options.publicKey] - The hex encoded public key. Can be both compressed or uncompressed\n * @param {Array<Number> | Uint8Array} [options.pkBytes] - An array of bytes containing the private key\n * @param {\"ENCODED\" | \"UNCOMPRESSED_HEX\" | \"COMPRESSED_HEX\"} options.output - Output\n * @return {String} the public key with the specified encoding\n */\nexport function deriveAddress({ pkBytes, publicKey, output = 'ENCODED' }) {\n    if (!pkBytes && !publicKey) return null;\n    const compress = output !== 'UNCOMPRESSED_HEX';\n    // Public Key Derivation\n    let pubKeyBytes = publicKey\n        ? hexToBytes(publicKey)\n        : nobleSecp256k1.getPublicKey(pkBytes, compress);\n\n    if (output === 'UNCOMPRESSED_HEX') {\n        if (pubKeyBytes.length !== 65) {\n            // It's actually possible, but it's probably not something that we'll need\n            throw new Error(\"Can't uncompress an already compressed key\");\n        }\n        return bytesToHex(pubKeyBytes);\n    }\n\n    if (pubKeyBytes.length === 65) {\n        pubKeyBytes = compressPublicKey(pubKeyBytes);\n    }\n\n    if (pubKeyBytes.length != 33) {\n        throw new Error('Invalid public key');\n    }\n\n    if (output === 'COMPRESSED_HEX') {\n        return bytesToHex(pubKeyBytes);\n    }\n\n    // First pubkey SHA-256 hash\n    const pubKeyHashing = sha256(new Uint8Array(pubKeyBytes));\n\n    // RIPEMD160 hash\n    const pubKeyHashRipemd160 = ripemd160(pubKeyHashing);\n\n    // Network Encoding\n    const pubKeyHashNetwork = new Uint8Array(pubKeyHashNetworkLen);\n    pubKeyHashNetwork[0] = cChainParams.current.PUBKEY_ADDRESS;\n    writeToUint8(pubKeyHashNetwork, pubKeyHashRipemd160, 1);\n\n    // Double SHA-256 hash\n    const pubKeyHashingSF = dSHA256(pubKeyHashNetwork);\n\n    // Checksum\n    const checksumPubKey = pubKeyHashingSF.slice(0, 4);\n\n    // Public key pre-base58\n    const pubKeyPreBase = new Uint8Array(pubPrebaseLen);\n    writeToUint8(pubKeyPreBase, pubKeyHashNetwork, 0);\n    writeToUint8(pubKeyPreBase, checksumPubKey, pubKeyHashNetworkLen);\n\n    // Encode as Base58 human-readable network address\n    return bs58.encode(pubKeyPreBase);\n}\n\n// Wallet Import\nexport async function importWallet({\n    newWif = false,\n    fRaw = false,\n    isHardwareWallet = false,\n    skipConfirmation = false,\n} = {}) {\n    const strImportConfirm =\n        \"Do you really want to import a new address? If you haven't saved the last private key, the wallet will be LOST forever.\";\n    const walletConfirm =\n        fWalletLoaded && !skipConfirmation\n            ? await confirmPopup({ html: strImportConfirm })\n            : true;\n\n    if (walletConfirm) {\n        if (isHardwareWallet) {\n            // Firefox does NOT support WebUSB, thus cannot work with Hardware wallets out-of-the-box\n            if (navigator.userAgent.includes('Firefox')) {\n                return createAlert(\n                    'warning',\n                    ALERTS.WALLET_FIREFOX_UNSUPPORTED,\n                    [],\n                    7500\n                );\n            }\n\n            const publicKey = await getHardwareWalletKeys(\n                getDerivationPath(true)\n            );\n            // Errors are handled within the above function, so there's no need for an 'else' here, just silent ignore.\n            if (!publicKey) return;\n\n            // Derive our hardware address and import!\n            masterKey = new HardwareWalletMasterKey();\n\n            // Hide the 'export wallet' button, it's not relevant to hardware wallets\n            doms.domExportWallet.style.display = 'none';\n\n            createAlert(\n                'info',\n                ALERTS.WALLET_HARDWARE_WALLET,\n                [{ hardwareWallet: strHardwareName }],\n                12500\n            );\n        } else {\n            // If raw bytes: purely encode the given bytes rather than generating our own bytes\n            if (fRaw) {\n                newWif = generateOrEncodePrivkey(newWif).strWIF;\n\n                // A raw import likely means non-user owned key (i.e: created via VanityGen), thus, we assume safety first and add an exit blocking listener\n                addEventListener('beforeunload', beforeUnloadListener, {\n                    capture: true,\n                });\n            }\n\n            // Select WIF from internal source OR user input (could be: WIF, Mnemonic or xpriv)\n            const privateImportValue = newWif || doms.domPrivKey.value;\n            doms.domPrivKey.value = '';\n\n            if (await verifyMnemonic(privateImportValue)) {\n                // Generate our masterkey via Mnemonic Phrase\n                const seed = await mnemonicToSeed(privateImportValue);\n                masterKey = new HdMasterKey({ seed });\n            } else {\n                // Public Key Derivation\n                try {\n                    if (privateImportValue.startsWith('xpub')) {\n                        masterKey = new HdMasterKey({\n                            xpub: privateImportValue,\n                        });\n                    } else if (privateImportValue.startsWith('xprv')) {\n                        masterKey = new HdMasterKey({\n                            xpriv: privateImportValue,\n                        });\n                    } else if (\n                        privateImportValue.length === 34 &&\n                        cChainParams.current.PUBKEY_PREFIX.includes(\n                            privateImportValue[0]\n                        )\n                    ) {\n                        masterKey = new LegacyMasterKey({\n                            address: privateImportValue,\n                        });\n                    } else {\n                        // Lastly, attempt to parse as a WIF private key\n                        const pkBytes = parseWIF(privateImportValue);\n\n                        // Hide the 'new address' button, since non-HD wallets are essentially single-address MPW wallets\n                        doms.domNewAddress.style.display = 'none';\n\n                        // Import the raw private key\n                        masterKey = new LegacyMasterKey({ pkBytes });\n                    }\n                } catch (e) {\n                    return createAlert(\n                        'warning',\n                        ALERTS.FAILED_TO_IMPORT + e.message,\n                        [],\n                        6000\n                    );\n                }\n            }\n        }\n\n        // Reaching here: the deserialisation was a full cryptographic success, so a wallet is now imported!\n        fWalletLoaded = true;\n\n        // Hide wipe wallet button if there is no private key\n        if (masterKey.isViewOnly || masterKey.isHardwareWallet) {\n            doms.domWipeWallet.hidden = true;\n            if (hasEncryptedWallet()) {\n                doms.domRestoreWallet.hidden = false;\n            }\n        }\n\n        getNewAddress({ updateGUI: true });\n        // Display Text\n        doms.domGuiWallet.style.display = 'block';\n\n        // Update identicon\n        doms.domIdenticon.dataset.jdenticonValue = masterKey.getAddress(\n            getDerivationPath()\n        );\n        jdenticon.update('#identicon');\n\n        // Hide the encryption warning if the user pasted the private key\n        // Or in Testnet mode or is using a hardware wallet or is view-only mode\n        if (\n            !(\n                newWif ||\n                cChainParams.current.isTestnet ||\n                isHardwareWallet ||\n                masterKey.isViewOnly\n            )\n        )\n            doms.domGenKeyWarning.style.display = 'block';\n\n        // Fetch state from explorer\n        if (networkEnabled) refreshChainData();\n\n        // Hide all wallet starter options\n        hideAllWalletOptions();\n    }\n}\n\n// Wallet Generation\nexport async function generateWallet(noUI = false) {\n    const strImportConfirm =\n        \"Do you really want to import a new address? If you haven't saved the last private key, the wallet will be LOST forever.\";\n    const walletConfirm =\n        fWalletLoaded && !noUI\n            ? await confirmPopup({ html: strImportConfirm })\n            : true;\n    if (walletConfirm) {\n        const mnemonic = generateMnemonic();\n\n        if (!noUI) await informUserOfMnemonic(mnemonic);\n        const seed = await mnemonicToSeed(mnemonic);\n\n        // Prompt the user to encrypt the seed\n        masterKey = new HdMasterKey({ seed });\n        fWalletLoaded = true;\n\n        if (!cChainParams.current.isTestnet)\n            doms.domGenKeyWarning.style.display = 'block';\n        // Add a listener to block page unloads until we are sure the user has saved their keys, safety first!\n        addEventListener('beforeunload', beforeUnloadListener, {\n            capture: true,\n        });\n\n        // Display the dashboard\n        doms.domGuiWallet.style.display = 'block';\n        hideAllWalletOptions();\n\n        // Update identicon\n        doms.domIdenticon.dataset.jdenticonValue = masterKey.getAddress(\n            getDerivationPath()\n        );\n        jdenticon.update('#identicon');\n\n        getNewAddress({ updateGUI: true });\n\n        // Refresh the balance UI (why? because it'll also display any 'get some funds!' alerts)\n        getBalance(true);\n        getStakingBalance(true);\n    }\n\n    return masterKey;\n}\n\nexport async function verifyMnemonic(strMnemonic = '', fPopupConfirm = true) {\n    const nWordCount = strMnemonic.trim().split(/\\s+/g).length;\n\n    // Sanity check: Convert to lowercase\n    strMnemonic = strMnemonic.toLowerCase();\n\n    // Ensure it's a word count that makes sense\n    if (nWordCount >= 12 && nWordCount <= 24) {\n        if (!validateMnemonic(strMnemonic)) {\n            // The reason we want to ask the user for confirmation is that the mnemonic\n            // Could have been generated with another app that has a different dictionary\n            return (\n                fPopupConfirm &&\n                (await confirmPopup({\n                    title: 'Unexpected Seed Phrase',\n                    html: 'The seed phrase is either invalid, or was not generated by MPW.<br>Do you still want to proceed?',\n                }))\n            );\n        } else {\n            // Valid count and mnemonic\n            return true;\n        }\n    } else {\n        // Invalid count\n        return false;\n    }\n}\n\nfunction informUserOfMnemonic(mnemonic) {\n    return new Promise((res, _) => {\n        $('#mnemonicModal').modal({ keyboard: false });\n        doms.domMnemonicModalContent.innerText = mnemonic;\n        doms.domMnemonicModalButton.onclick = () => {\n            res();\n            $('#mnemonicModal').modal('hide');\n        };\n        $('#mnemonicModal').modal('show');\n    });\n}\n\nexport async function encryptWallet(strPassword = '') {\n    // Encrypt the wallet WIF with AES-GCM and a user-chosen password - suitable for browser storage\n    let strEncWIF = await encrypt(masterKey.keyToBackup, strPassword);\n    if (!strEncWIF) return false;\n\n    // Set the encrypted wallet in localStorage\n    localStorage.setItem('encwif', strEncWIF);\n    localStorage.setItem('publicKey', await masterKey.keyToExport);\n\n    // Hide the encryption warning\n    doms.domGenKeyWarning.style.display = 'none';\n\n    // Remove the exit blocker, we can annoy the user less knowing the key is safe in their localstorage!\n    removeEventListener('beforeunload', beforeUnloadListener, {\n        capture: true,\n    });\n}\n\nexport async function decryptWallet(strPassword = '') {\n    // Check if there's any encrypted WIF available\n    const strEncWIF = localStorage.getItem('encwif');\n    if (!strEncWIF || strEncWIF.length < 1) return false;\n\n    // Prompt to decrypt it via password\n    const strDecWIF = await decrypt(strEncWIF, strPassword);\n    if (!strDecWIF || strDecWIF === 'decryption failed!') {\n        if (strDecWIF)\n            return createAlert('warning', 'Incorrect password!', 6000);\n    } else {\n        await importWallet({\n            newWif: strDecWIF,\n            skipConfirmation: true,\n        });\n        // Ensure publicKey is set\n        localStorage.setItem('publicKey', await masterKey.keyToExport);\n        return true;\n    }\n}\n\nexport function hasEncryptedWallet() {\n    return localStorage.getItem('encwif') ? true : false;\n}\n\n// If the privateKey is null then the user connected a hardware wallet\nexport function hasHardwareWallet() {\n    if (!masterKey) return false;\n    return masterKey.isHardwareWallet == true;\n}\n\nexport function hasWalletUnlocked(fIncludeNetwork = false) {\n    if (fIncludeNetwork && !networkEnabled)\n        return createAlert(\n            'warning',\n            ALERTS.WALLET_OFFLINE_AUTOMATIC,\n            [],\n            5500\n        );\n    if (!masterKey) {\n        return createAlert(\n            'warning',\n            ALERTS.WALLET_UNLOCK_IMPORT,\n            [{ unlock: hasEncryptedWallet() ? 'unlock ' : 'import/create' }],\n            3500\n        );\n    } else {\n        return true;\n    }\n}\n\nlet addressIndex = 0;\nexport async function isYourAddress(address) {\n    let i = 0;\n    while (i < addressIndex) {\n        const path = getDerivationPath(masterKey.isHardwareWallet, 0, 0, i);\n        const testAddress = await masterKey.getAddress(path);\n        if (address === testAddress) {\n            return [true, path];\n        }\n        i++;\n    }\n    return [false, 0];\n}\n\nfunction createAddressConfirmation(address) {\n    return `Please confirm this is the address you see on your ${strHardwareName}.\n              <div class=\"seed-phrase\">${address}</div>`;\n}\n\nexport async function getNewAddress({\n    updateGUI = false,\n    verify = false,\n} = {}) {\n    const last = lastWallet || 0;\n    addressIndex = addressIndex > last ? addressIndex : last + 1;\n    if (addressIndex - last > MAX_ACCOUNT_GAP) {\n        // If the user creates more than ${MAX_ACCOUNT_GAP} empty wallets we will not be able to sync them!\n        addressIndex = last;\n    }\n    const path = getDerivationPath(\n        masterKey.isHardwareWallet,\n        0,\n        0,\n        addressIndex\n    );\n    // Use Xpub?\n    const address = await masterKey.getAddress(path);\n    if (verify && masterKey.isHardwareWallet) {\n        // Generate address to present to the user without asking to verify\n        const confAddress = await confirmPopup({\n            title: ALERTS.CONFIRM_POPUP_VERIFY_ADDR,\n            html: createAddressConfirmation(address),\n            resolvePromise: masterKey.getAddress(path, { verify }),\n        });\n        if (address !== confAddress) {\n            throw new Error('User did not verify address');\n        }\n    }\n\n    if (updateGUI) {\n        createQR('pivx:' + address, doms.domModalQR);\n        doms.domModalQrLabel.innerHTML = 'pivx:' + address + `<i onclick=\"MPW.toClipboard('${address}', this)\" id=\"guiAddressCopy\" class=\"fas fa-clipboard\" style=\"cursor: pointer; width: 20px;\"></i>`;\n        doms.domModalQR.firstChild.style.width = '100%';\n        doms.domModalQR.firstChild.style.height = 'auto';\n        doms.domModalQR.firstChild.classList.add('no-antialias');\n        document.getElementById('clipboard').value = address;\n    }\n    addressIndex++;\n    return [address, path];\n}\n\nexport let cHardwareWallet = null;\nexport let strHardwareName = '';\nlet transport;\nasync function getHardwareWalletKeys(\n    path,\n    xpub = false,\n    verify = false,\n    _attempts = 0\n) {\n    try {\n        // Check if we haven't setup a connection yet OR the previous connection disconnected\n        if (!cHardwareWallet || transport._disconnectEmitted) {\n            transport = await TransportWebUSB.create();\n            cHardwareWallet = new AppBtc({ transport, currency: 'PIVX' });\n        }\n\n        // Update device info and fetch the pubkey\n        strHardwareName =\n            transport.device.manufacturerName +\n            ' ' +\n            transport.device.productName;\n\n        // Prompt the user in both UIs\n        if (verify) createAlert('info', ALERTS.WALLET_CONFIRM_L, [], 3500);\n        const cPubKey = await cHardwareWallet.getWalletPublicKey(path, {\n            verify,\n            format: 'legacy',\n        });\n\n        if (xpub) {\n            return createXpub({\n                depth: 3,\n                childNumber: 2147483648,\n                chainCode: cPubKey.chainCode,\n                publicKey: cPubKey.publicKey,\n            });\n        } else {\n            return cPubKey.publicKey;\n        }\n    } catch (e) {\n        if (e.message.includes('denied by the user')) {\n            // User denied an operation\n            return false;\n        }\n\n        // If there's no device, nudge the user to plug it in.\n        if (e.message.toLowerCase().includes('no device selected')) {\n            createAlert('info', ALERTS.WALLET_NO_HARDWARE, [], 10000);\n            return false;\n        }\n\n        // If the device is unplugged, or connection lost through other means (such as spontanious device explosion)\n        if (e.message.includes(\"Failed to execute 'transferIn'\")) {\n            createAlert(\n                'info',\n                ALERTS.WALLET_HARDWARE_CONNECTION_LOST,\n                [\n                    {\n                        hardwareWallet: strHardwareName,\n                    },\n                ],\n                10000\n            );\n            return false;\n        }\n        if (_attempts < 10) {\n            // This is an ugly hack :(\n            // in the event where multiple parts of the code decide to ask for an address, just\n            // Retry at most 10 times waiting 200ms each time\n            await sleep(200);\n            return getHardwareWalletKeys(path, xpub, verify, _attempts + 1);\n        }\n\n        // If the ledger is busy, just nudge the user.\n        if (e.message.includes('is busy')) {\n            createAlert(\n                'info',\n                ALERTS.WALLET_HARDWARE_BUSY,\n                [\n                    {\n                        hardwareWallet: strHardwareName,\n                    },\n                ],\n                7500\n            );\n            return false;\n        }\n\n        // Check if this is an expected error\n        if (!e.statusCode || !LEDGER_ERRS.has(e.statusCode)) {\n            console.error(\n                'MISSING LEDGER ERROR-CODE TRANSLATION! - Please report this below error on our GitHub so we can handle it more nicely!'\n            );\n            console.error(e);\n        }\n\n        // Translate the error to a user-friendly string (if possible)\n        createAlert(\n            'warning',\n            ALERTS.WALLET_HARDWARE_ERROR,\n            [\n                {\n                    hardwareWallet: strHardwareName,\n                },\n                {\n                    error: LEDGER_ERRS.get(e.statusCode),\n                },\n            ],\n            5500\n        );\n\n        return false;\n    }\n}\n","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [\"vendors-node_modules_ledgerhq_hw-app-btc_lib-es_Btc_js-node_modules_ledgerhq_hw-transport-web-ba78a5\"], () => (__webpack_require__(\"./scripts/vanitygen_worker.js\")))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));\n\t}\n\tdef['default'] = () => (value);\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"./\" + chunkId + \".mpw.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = self.location + \"\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t\"scripts_misc_js\": 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkMPW\"] = self[\"webpackChunkMPW\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(\"vendors-node_modules_ledgerhq_hw-app-btc_lib-es_Btc_js-node_modules_ledgerhq_hw-transport-web-ba78a5\").then(next);\n};","","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n",""],"names":[],"sourceRoot":""}